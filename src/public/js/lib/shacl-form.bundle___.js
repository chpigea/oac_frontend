var Fi = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ef(i) {
    return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i
}
function mg(i) {
    if (Object.prototype.hasOwnProperty.call(i, "__esModule"))
        return i;
    var e = i.default;
    if (typeof e == "function") {
        var n = function r() {
            var o = !1;
            try {
                o = this instanceof r
            } catch {}
            return o ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments)
        };
        n.prototype = e.prototype
    } else
        n = {};
    return Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    Object.keys(i).forEach(function(r) {
        var o = Object.getOwnPropertyDescriptor(i, r);
        Object.defineProperty(n, r, o.get ? o : {
            enumerable: !0,
            get: function() {
                return i[r]
            }
        })
    }),
    n
}
var Co = {}, ur = {}, Ku;
function _g() {
    if (Ku)
        return ur;
    Ku = 1,
    ur.byteLength = u,
    ur.toByteArray = h,
    ur.fromByteArray = d;
    for (var i = [], e = [], n = typeof Uint8Array < "u" ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", o = 0, a = r.length; o < a; ++o)
        i[o] = r[o],
        e[r.charCodeAt(o)] = o;
    e[45] = 62,
    e[95] = 63;
    function l(g) {
        var b = g.length;
        if (b % 4 > 0)
            throw new Error("Invalid string. Length must be a multiple of 4");
        var T = g.indexOf("=");
        T === -1 && (T = b);
        var N = T === b ? 0 : 4 - T % 4;
        return [T, N]
    }
    function u(g) {
        var b = l(g)
          , T = b[0]
          , N = b[1];
        return (T + N) * 3 / 4 - N
    }
    function f(g, b, T) {
        return (b + T) * 3 / 4 - T
    }
    function h(g) {
        var b, T = l(g), N = T[0], A = T[1], R = new n(f(g, N, A)), S = 0, y = A > 0 ? N - 4 : N, x;
        for (x = 0; x < y; x += 4)
            b = e[g.charCodeAt(x)] << 18 | e[g.charCodeAt(x + 1)] << 12 | e[g.charCodeAt(x + 2)] << 6 | e[g.charCodeAt(x + 3)],
            R[S++] = b >> 16 & 255,
            R[S++] = b >> 8 & 255,
            R[S++] = b & 255;
        return A === 2 && (b = e[g.charCodeAt(x)] << 2 | e[g.charCodeAt(x + 1)] >> 4,
        R[S++] = b & 255),
        A === 1 && (b = e[g.charCodeAt(x)] << 10 | e[g.charCodeAt(x + 1)] << 4 | e[g.charCodeAt(x + 2)] >> 2,
        R[S++] = b >> 8 & 255,
        R[S++] = b & 255),
        R
    }
    function m(g) {
        return i[g >> 18 & 63] + i[g >> 12 & 63] + i[g >> 6 & 63] + i[g & 63]
    }
    function _(g, b, T) {
        for (var N, A = [], R = b; R < T; R += 3)
            N = (g[R] << 16 & 16711680) + (g[R + 1] << 8 & 65280) + (g[R + 2] & 255),
            A.push(m(N));
        return A.join("")
    }
    function d(g) {
        for (var b, T = g.length, N = T % 3, A = [], R = 16383, S = 0, y = T - N; S < y; S += R)
            A.push(_(g, S, S + R > y ? y : S + R));
        return N === 1 ? (b = g[T - 1],
        A.push(i[b >> 2] + i[b << 4 & 63] + "==")) : N === 2 && (b = (g[T - 2] << 8) + g[T - 1],
        A.push(i[b >> 10] + i[b >> 4 & 63] + i[b << 2 & 63] + "=")),
        A.join("")
    }
    return ur
}
var hs = {};
var Yu;
function yg() {
    return Yu || (Yu = 1,
    hs.read = function(i, e, n, r, o) {
        var a, l, u = o * 8 - r - 1, f = (1 << u) - 1, h = f >> 1, m = -7, _ = n ? o - 1 : 0, d = n ? -1 : 1, g = i[e + _];
        for (_ += d,
        a = g & (1 << -m) - 1,
        g >>= -m,
        m += u; m > 0; a = a * 256 + i[e + _],
        _ += d,
        m -= 8)
            ;
        for (l = a & (1 << -m) - 1,
        a >>= -m,
        m += r; m > 0; l = l * 256 + i[e + _],
        _ += d,
        m -= 8)
            ;
        if (a === 0)
            a = 1 - h;
        else {
            if (a === f)
                return l ? NaN : (g ? -1 : 1) * (1 / 0);
            l = l + Math.pow(2, r),
            a = a - h
        }
        return (g ? -1 : 1) * l * Math.pow(2, a - r)
    }
    ,
    hs.write = function(i, e, n, r, o, a) {
        var l, u, f, h = a * 8 - o - 1, m = (1 << h) - 1, _ = m >> 1, d = o === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g = r ? 0 : a - 1, b = r ? 1 : -1, T = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
        for (e = Math.abs(e),
        isNaN(e) || e === 1 / 0 ? (u = isNaN(e) ? 1 : 0,
        l = m) : (l = Math.floor(Math.log(e) / Math.LN2),
        e * (f = Math.pow(2, -l)) < 1 && (l--,
        f *= 2),
        l + _ >= 1 ? e += d / f : e += d * Math.pow(2, 1 - _),
        e * f >= 2 && (l++,
        f /= 2),
        l + _ >= m ? (u = 0,
        l = m) : l + _ >= 1 ? (u = (e * f - 1) * Math.pow(2, o),
        l = l + _) : (u = e * Math.pow(2, _ - 1) * Math.pow(2, o),
        l = 0)); o >= 8; i[n + g] = u & 255,
        g += b,
        u /= 256,
        o -= 8)
            ;
        for (l = l << o | u,
        h += o; h > 0; i[n + g] = l & 255,
        g += b,
        l /= 256,
        h -= 8)
            ;
        i[n + g - b] |= T * 128
    }
    ),
    hs
}
var ec;
function Rn() {
    return ec || (ec = 1,
    (function(i) {
        const e = _g()
          , n = yg()
          , r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
        i.Buffer = u,
        i.SlowBuffer = R,
        i.INSPECT_MAX_BYTES = 50;
        const o = 2147483647;
        i.kMaxLength = o,
        u.TYPED_ARRAY_SUPPORT = a(),
        !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
        function a() {
            try {
                const C = new Uint8Array(1)
                  , v = {
                    foo: function() {
                        return 42
                    }
                };
                return Object.setPrototypeOf(v, Uint8Array.prototype),
                Object.setPrototypeOf(C, v),
                C.foo() === 42
            } catch {
                return !1
            }
        }
        Object.defineProperty(u.prototype, "parent", {
            enumerable: !0,
            get: function() {
                if (u.isBuffer(this))
                    return this.buffer
            }
        }),
        Object.defineProperty(u.prototype, "offset", {
            enumerable: !0,
            get: function() {
                if (u.isBuffer(this))
                    return this.byteOffset
            }
        });
        function l(C) {
            if (C > o)
                throw new RangeError('The value "' + C + '" is invalid for option "size"');
            const v = new Uint8Array(C);
            return Object.setPrototypeOf(v, u.prototype),
            v
        }
        function u(C, v, w) {
            if (typeof C == "number") {
                if (typeof v == "string")
                    throw new TypeError('The "string" argument must be of type string. Received type number');
                return _(C)
            }
            return f(C, v, w)
        }
        u.poolSize = 8192;
        function f(C, v, w) {
            if (typeof C == "string")
                return d(C, v);
            if (ArrayBuffer.isView(C))
                return b(C);
            if (C == null)
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof C);
            if (ve(C, ArrayBuffer) || C && ve(C.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ve(C, SharedArrayBuffer) || C && ve(C.buffer, SharedArrayBuffer)))
                return T(C, v, w);
            if (typeof C == "number")
                throw new TypeError('The "value" argument must not be of type number. Received type number');
            const H = C.valueOf && C.valueOf();
            if (H != null && H !== C)
                return u.from(H, v, w);
            const re = N(C);
            if (re)
                return re;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof C[Symbol.toPrimitive] == "function")
                return u.from(C[Symbol.toPrimitive]("string"), v, w);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof C)
        }
        u.from = function(C, v, w) {
            return f(C, v, w)
        }
        ,
        Object.setPrototypeOf(u.prototype, Uint8Array.prototype),
        Object.setPrototypeOf(u, Uint8Array);
        function h(C) {
            if (typeof C != "number")
                throw new TypeError('"size" argument must be of type number');
            if (C < 0)
                throw new RangeError('The value "' + C + '" is invalid for option "size"')
        }
        function m(C, v, w) {
            return h(C),
            C <= 0 ? l(C) : v !== void 0 ? typeof w == "string" ? l(C).fill(v, w) : l(C).fill(v) : l(C)
        }
        u.alloc = function(C, v, w) {
            return m(C, v, w)
        }
        ;
        function _(C) {
            return h(C),
            l(C < 0 ? 0 : A(C) | 0)
        }
        u.allocUnsafe = function(C) {
            return _(C)
        }
        ,
        u.allocUnsafeSlow = function(C) {
            return _(C)
        }
        ;
        function d(C, v) {
            if ((typeof v != "string" || v === "") && (v = "utf8"),
            !u.isEncoding(v))
                throw new TypeError("Unknown encoding: " + v);
            const w = S(C, v) | 0;
            let H = l(w);
            const re = H.write(C, v);
            return re !== w && (H = H.slice(0, re)),
            H
        }
        function g(C) {
            const v = C.length < 0 ? 0 : A(C.length) | 0
              , w = l(v);
            for (let H = 0; H < v; H += 1)
                w[H] = C[H] & 255;
            return w
        }
        function b(C) {
            if (ve(C, Uint8Array)) {
                const v = new Uint8Array(C);
                return T(v.buffer, v.byteOffset, v.byteLength)
            }
            return g(C)
        }
        function T(C, v, w) {
            if (v < 0 || C.byteLength < v)
                throw new RangeError('"offset" is outside of buffer bounds');
            if (C.byteLength < v + (w || 0))
                throw new RangeError('"length" is outside of buffer bounds');
            let H;
            return v === void 0 && w === void 0 ? H = new Uint8Array(C) : w === void 0 ? H = new Uint8Array(C,v) : H = new Uint8Array(C,v,w),
            Object.setPrototypeOf(H, u.prototype),
            H
        }
        function N(C) {
            if (u.isBuffer(C)) {
                const v = A(C.length) | 0
                  , w = l(v);
                return w.length === 0 || C.copy(w, 0, 0, v),
                w
            }
            if (C.length !== void 0)
                return typeof C.length != "number" || $e(C.length) ? l(0) : g(C);
            if (C.type === "Buffer" && Array.isArray(C.data))
                return g(C.data)
        }
        function A(C) {
            if (C >= o)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
            return C | 0
        }
        function R(C) {
            return +C != C && (C = 0),
            u.alloc(+C)
        }
        u.isBuffer = function(v) {
            return v != null && v._isBuffer === !0 && v !== u.prototype
        }
        ,
        u.compare = function(v, w) {
            if (ve(v, Uint8Array) && (v = u.from(v, v.offset, v.byteLength)),
            ve(w, Uint8Array) && (w = u.from(w, w.offset, w.byteLength)),
            !u.isBuffer(v) || !u.isBuffer(w))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (v === w)
                return 0;
            let H = v.length
              , re = w.length;
            for (let _e = 0, we = Math.min(H, re); _e < we; ++_e)
                if (v[_e] !== w[_e]) {
                    H = v[_e],
                    re = w[_e];
                    break
                }
            return H < re ? -1 : re < H ? 1 : 0
        }
        ,
        u.isEncoding = function(v) {
            switch (String(v).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return !0;
            default:
                return !1
            }
        }
        ,
        u.concat = function(v, w) {
            if (!Array.isArray(v))
                throw new TypeError('"list" argument must be an Array of Buffers');
            if (v.length === 0)
                return u.alloc(0);
            let H;
            if (w === void 0)
                for (w = 0,
                H = 0; H < v.length; ++H)
                    w += v[H].length;
            const re = u.allocUnsafe(w);
            let _e = 0;
            for (H = 0; H < v.length; ++H) {
                let we = v[H];
                if (ve(we, Uint8Array))
                    _e + we.length > re.length ? (u.isBuffer(we) || (we = u.from(we)),
                    we.copy(re, _e)) : Uint8Array.prototype.set.call(re, we, _e);
                else if (u.isBuffer(we))
                    we.copy(re, _e);
                else
                    throw new TypeError('"list" argument must be an Array of Buffers');
                _e += we.length
            }
            return re
        }
        ;
        function S(C, v) {
            if (u.isBuffer(C))
                return C.length;
            if (ArrayBuffer.isView(C) || ve(C, ArrayBuffer))
                return C.byteLength;
            if (typeof C != "string")
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof C);
            const w = C.length
              , H = arguments.length > 2 && arguments[2] === !0;
            if (!H && w === 0)
                return 0;
            let re = !1;
            for (; ; )
                switch (v) {
                case "ascii":
                case "latin1":
                case "binary":
                    return w;
                case "utf8":
                case "utf-8":
                    return Se(C).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return w * 2;
                case "hex":
                    return w >>> 1;
                case "base64":
                    return be(C).length;
                default:
                    if (re)
                        return H ? -1 : Se(C).length;
                    v = ("" + v).toLowerCase(),
                    re = !0
                }
        }
        u.byteLength = S;
        function y(C, v, w) {
            let H = !1;
            if ((v === void 0 || v < 0) && (v = 0),
            v > this.length || ((w === void 0 || w > this.length) && (w = this.length),
            w <= 0) || (w >>>= 0,
            v >>>= 0,
            w <= v))
                return "";
            for (C || (C = "utf8"); ; )
                switch (C) {
                case "hex":
                    return ae(this, v, w);
                case "utf8":
                case "utf-8":
                    return B(this, v, w);
                case "ascii":
                    return oe(this, v, w);
                case "latin1":
                case "binary":
                    return j(this, v, w);
                case "base64":
                    return F(this, v, w);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return I(this, v, w);
                default:
                    if (H)
                        throw new TypeError("Unknown encoding: " + C);
                    C = (C + "").toLowerCase(),
                    H = !0
                }
        }
        u.prototype._isBuffer = !0;
        function x(C, v, w) {
            const H = C[v];
            C[v] = C[w],
            C[w] = H
        }
        u.prototype.swap16 = function() {
            const v = this.length;
            if (v % 2 !== 0)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (let w = 0; w < v; w += 2)
                x(this, w, w + 1);
            return this
        }
        ,
        u.prototype.swap32 = function() {
            const v = this.length;
            if (v % 4 !== 0)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (let w = 0; w < v; w += 4)
                x(this, w, w + 3),
                x(this, w + 1, w + 2);
            return this
        }
        ,
        u.prototype.swap64 = function() {
            const v = this.length;
            if (v % 8 !== 0)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (let w = 0; w < v; w += 8)
                x(this, w, w + 7),
                x(this, w + 1, w + 6),
                x(this, w + 2, w + 5),
                x(this, w + 3, w + 4);
            return this
        }
        ,
        u.prototype.toString = function() {
            const v = this.length;
            return v === 0 ? "" : arguments.length === 0 ? B(this, 0, v) : y.apply(this, arguments)
        }
        ,
        u.prototype.toLocaleString = u.prototype.toString,
        u.prototype.equals = function(v) {
            if (!u.isBuffer(v))
                throw new TypeError("Argument must be a Buffer");
            return this === v ? !0 : u.compare(this, v) === 0
        }
        ,
        u.prototype.inspect = function() {
            let v = "";
            const w = i.INSPECT_MAX_BYTES;
            return v = this.toString("hex", 0, w).replace(/(.{2})/g, "$1 ").trim(),
            this.length > w && (v += " ... "),
            "<Buffer " + v + ">"
        }
        ,
        r && (u.prototype[r] = u.prototype.inspect),
        u.prototype.compare = function(v, w, H, re, _e) {
            if (ve(v, Uint8Array) && (v = u.from(v, v.offset, v.byteLength)),
            !u.isBuffer(v))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof v);
            if (w === void 0 && (w = 0),
            H === void 0 && (H = v ? v.length : 0),
            re === void 0 && (re = 0),
            _e === void 0 && (_e = this.length),
            w < 0 || H > v.length || re < 0 || _e > this.length)
                throw new RangeError("out of range index");
            if (re >= _e && w >= H)
                return 0;
            if (re >= _e)
                return -1;
            if (w >= H)
                return 1;
            if (w >>>= 0,
            H >>>= 0,
            re >>>= 0,
            _e >>>= 0,
            this === v)
                return 0;
            let we = _e - re
              , Oe = H - w;
            const Ye = Math.min(we, Oe)
              , Qe = this.slice(re, _e)
              , We = v.slice(w, H);
            for (let Ze = 0; Ze < Ye; ++Ze)
                if (Qe[Ze] !== We[Ze]) {
                    we = Qe[Ze],
                    Oe = We[Ze];
                    break
                }
            return we < Oe ? -1 : Oe < we ? 1 : 0
        }
        ;
        function M(C, v, w, H, re) {
            if (C.length === 0)
                return -1;
            if (typeof w == "string" ? (H = w,
            w = 0) : w > 2147483647 ? w = 2147483647 : w < -2147483648 && (w = -2147483648),
            w = +w,
            $e(w) && (w = re ? 0 : C.length - 1),
            w < 0 && (w = C.length + w),
            w >= C.length) {
                if (re)
                    return -1;
                w = C.length - 1
            } else if (w < 0)
                if (re)
                    w = 0;
                else
                    return -1;
            if (typeof v == "string" && (v = u.from(v, H)),
            u.isBuffer(v))
                return v.length === 0 ? -1 : U(C, v, w, H, re);
            if (typeof v == "number")
                return v = v & 255,
                typeof Uint8Array.prototype.indexOf == "function" ? re ? Uint8Array.prototype.indexOf.call(C, v, w) : Uint8Array.prototype.lastIndexOf.call(C, v, w) : U(C, [v], w, H, re);
            throw new TypeError("val must be string, number or Buffer")
        }
        function U(C, v, w, H, re) {
            let _e = 1
              , we = C.length
              , Oe = v.length;
            if (H !== void 0 && (H = String(H).toLowerCase(),
            H === "ucs2" || H === "ucs-2" || H === "utf16le" || H === "utf-16le")) {
                if (C.length < 2 || v.length < 2)
                    return -1;
                _e = 2,
                we /= 2,
                Oe /= 2,
                w /= 2
            }
            function Ye(We, Ze) {
                return _e === 1 ? We[Ze] : We.readUInt16BE(Ze * _e)
            }
            let Qe;
            if (re) {
                let We = -1;
                for (Qe = w; Qe < we; Qe++)
                    if (Ye(C, Qe) === Ye(v, We === -1 ? 0 : Qe - We)) {
                        if (We === -1 && (We = Qe),
                        Qe - We + 1 === Oe)
                            return We * _e
                    } else
                        We !== -1 && (Qe -= Qe - We),
                        We = -1
            } else
                for (w + Oe > we && (w = we - Oe),
                Qe = w; Qe >= 0; Qe--) {
                    let We = !0;
                    for (let Ze = 0; Ze < Oe; Ze++)
                        if (Ye(C, Qe + Ze) !== Ye(v, Ze)) {
                            We = !1;
                            break
                        }
                    if (We)
                        return Qe
                }
            return -1
        }
        u.prototype.includes = function(v, w, H) {
            return this.indexOf(v, w, H) !== -1
        }
        ,
        u.prototype.indexOf = function(v, w, H) {
            return M(this, v, w, H, !0)
        }
        ,
        u.prototype.lastIndexOf = function(v, w, H) {
            return M(this, v, w, H, !1)
        }
        ;
        function O(C, v, w, H) {
            w = Number(w) || 0;
            const re = C.length - w;
            H ? (H = Number(H),
            H > re && (H = re)) : H = re;
            const _e = v.length;
            H > _e / 2 && (H = _e / 2);
            let we;
            for (we = 0; we < H; ++we) {
                const Oe = parseInt(v.substr(we * 2, 2), 16);
                if ($e(Oe))
                    return we;
                C[w + we] = Oe
            }
            return we
        }
        function Q(C, v, w, H) {
            return Ne(Se(v, C.length - w), C, w, H)
        }
        function D(C, v, w, H) {
            return Ne(Ie(v), C, w, H)
        }
        function $(C, v, w, H) {
            return Ne(be(v), C, w, H)
        }
        function X(C, v, w, H) {
            return Ne(se(v, C.length - w), C, w, H)
        }
        u.prototype.write = function(v, w, H, re) {
            if (w === void 0)
                re = "utf8",
                H = this.length,
                w = 0;
            else if (H === void 0 && typeof w == "string")
                re = w,
                H = this.length,
                w = 0;
            else if (isFinite(w))
                w = w >>> 0,
                isFinite(H) ? (H = H >>> 0,
                re === void 0 && (re = "utf8")) : (re = H,
                H = void 0);
            else
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            const _e = this.length - w;
            if ((H === void 0 || H > _e) && (H = _e),
            v.length > 0 && (H < 0 || w < 0) || w > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
            re || (re = "utf8");
            let we = !1;
            for (; ; )
                switch (re) {
                case "hex":
                    return O(this, v, w, H);
                case "utf8":
                case "utf-8":
                    return Q(this, v, w, H);
                case "ascii":
                case "latin1":
                case "binary":
                    return D(this, v, w, H);
                case "base64":
                    return $(this, v, w, H);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                    return X(this, v, w, H);
                default:
                    if (we)
                        throw new TypeError("Unknown encoding: " + re);
                    re = ("" + re).toLowerCase(),
                    we = !0
                }
        }
        ,
        u.prototype.toJSON = function() {
            return {
                type: "Buffer",
                data: Array.prototype.slice.call(this._arr || this, 0)
            }
        }
        ;
        function F(C, v, w) {
            return v === 0 && w === C.length ? e.fromByteArray(C) : e.fromByteArray(C.slice(v, w))
        }
        function B(C, v, w) {
            w = Math.min(C.length, w);
            const H = [];
            let re = v;
            for (; re < w; ) {
                const _e = C[re];
                let we = null
                  , Oe = _e > 239 ? 4 : _e > 223 ? 3 : _e > 191 ? 2 : 1;
                if (re + Oe <= w) {
                    let Ye, Qe, We, Ze;
                    switch (Oe) {
                    case 1:
                        _e < 128 && (we = _e);
                        break;
                    case 2:
                        Ye = C[re + 1],
                        (Ye & 192) === 128 && (Ze = (_e & 31) << 6 | Ye & 63,
                        Ze > 127 && (we = Ze));
                        break;
                    case 3:
                        Ye = C[re + 1],
                        Qe = C[re + 2],
                        (Ye & 192) === 128 && (Qe & 192) === 128 && (Ze = (_e & 15) << 12 | (Ye & 63) << 6 | Qe & 63,
                        Ze > 2047 && (Ze < 55296 || Ze > 57343) && (we = Ze));
                        break;
                    case 4:
                        Ye = C[re + 1],
                        Qe = C[re + 2],
                        We = C[re + 3],
                        (Ye & 192) === 128 && (Qe & 192) === 128 && (We & 192) === 128 && (Ze = (_e & 15) << 18 | (Ye & 63) << 12 | (Qe & 63) << 6 | We & 63,
                        Ze > 65535 && Ze < 1114112 && (we = Ze))
                    }
                }
                we === null ? (we = 65533,
                Oe = 1) : we > 65535 && (we -= 65536,
                H.push(we >>> 10 & 1023 | 55296),
                we = 56320 | we & 1023),
                H.push(we),
                re += Oe
            }
            return P(H)
        }
        const ue = 4096;
        function P(C) {
            const v = C.length;
            if (v <= ue)
                return String.fromCharCode.apply(String, C);
            let w = ""
              , H = 0;
            for (; H < v; )
                w += String.fromCharCode.apply(String, C.slice(H, H += ue));
            return w
        }
        function oe(C, v, w) {
            let H = "";
            w = Math.min(C.length, w);
            for (let re = v; re < w; ++re)
                H += String.fromCharCode(C[re] & 127);
            return H
        }
        function j(C, v, w) {
            let H = "";
            w = Math.min(C.length, w);
            for (let re = v; re < w; ++re)
                H += String.fromCharCode(C[re]);
            return H
        }
        function ae(C, v, w) {
            const H = C.length;
            (!v || v < 0) && (v = 0),
            (!w || w < 0 || w > H) && (w = H);
            let re = "";
            for (let _e = v; _e < w; ++_e)
                re += mt[C[_e]];
            return re
        }
        function I(C, v, w) {
            const H = C.slice(v, w);
            let re = "";
            for (let _e = 0; _e < H.length - 1; _e += 2)
                re += String.fromCharCode(H[_e] + H[_e + 1] * 256);
            return re
        }
        u.prototype.slice = function(v, w) {
            const H = this.length;
            v = ~~v,
            w = w === void 0 ? H : ~~w,
            v < 0 ? (v += H,
            v < 0 && (v = 0)) : v > H && (v = H),
            w < 0 ? (w += H,
            w < 0 && (w = 0)) : w > H && (w = H),
            w < v && (w = v);
            const re = this.subarray(v, w);
            return Object.setPrototypeOf(re, u.prototype),
            re
        }
        ;
        function Z(C, v, w) {
            if (C % 1 !== 0 || C < 0)
                throw new RangeError("offset is not uint");
            if (C + v > w)
                throw new RangeError("Trying to access beyond buffer length")
        }
        u.prototype.readUintLE = u.prototype.readUIntLE = function(v, w, H) {
            v = v >>> 0,
            w = w >>> 0,
            H || Z(v, w, this.length);
            let re = this[v]
              , _e = 1
              , we = 0;
            for (; ++we < w && (_e *= 256); )
                re += this[v + we] * _e;
            return re
        }
        ,
        u.prototype.readUintBE = u.prototype.readUIntBE = function(v, w, H) {
            v = v >>> 0,
            w = w >>> 0,
            H || Z(v, w, this.length);
            let re = this[v + --w]
              , _e = 1;
            for (; w > 0 && (_e *= 256); )
                re += this[v + --w] * _e;
            return re
        }
        ,
        u.prototype.readUint8 = u.prototype.readUInt8 = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 1, this.length),
            this[v]
        }
        ,
        u.prototype.readUint16LE = u.prototype.readUInt16LE = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 2, this.length),
            this[v] | this[v + 1] << 8
        }
        ,
        u.prototype.readUint16BE = u.prototype.readUInt16BE = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 2, this.length),
            this[v] << 8 | this[v + 1]
        }
        ,
        u.prototype.readUint32LE = u.prototype.readUInt32LE = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 4, this.length),
            (this[v] | this[v + 1] << 8 | this[v + 2] << 16) + this[v + 3] * 16777216
        }
        ,
        u.prototype.readUint32BE = u.prototype.readUInt32BE = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 4, this.length),
            this[v] * 16777216 + (this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3])
        }
        ,
        u.prototype.readBigUInt64LE = Be(function(v) {
            v = v >>> 0,
            q(v, "offset");
            const w = this[v]
              , H = this[v + 7];
            (w === void 0 || H === void 0) && te(v, this.length - 8);
            const re = w + this[++v] * 2 ** 8 + this[++v] * 2 ** 16 + this[++v] * 2 ** 24
              , _e = this[++v] + this[++v] * 2 ** 8 + this[++v] * 2 ** 16 + H * 2 ** 24;
            return BigInt(re) + (BigInt(_e) << BigInt(32))
        }),
        u.prototype.readBigUInt64BE = Be(function(v) {
            v = v >>> 0,
            q(v, "offset");
            const w = this[v]
              , H = this[v + 7];
            (w === void 0 || H === void 0) && te(v, this.length - 8);
            const re = w * 2 ** 24 + this[++v] * 2 ** 16 + this[++v] * 2 ** 8 + this[++v]
              , _e = this[++v] * 2 ** 24 + this[++v] * 2 ** 16 + this[++v] * 2 ** 8 + H;
            return (BigInt(re) << BigInt(32)) + BigInt(_e)
        }),
        u.prototype.readIntLE = function(v, w, H) {
            v = v >>> 0,
            w = w >>> 0,
            H || Z(v, w, this.length);
            let re = this[v]
              , _e = 1
              , we = 0;
            for (; ++we < w && (_e *= 256); )
                re += this[v + we] * _e;
            return _e *= 128,
            re >= _e && (re -= Math.pow(2, 8 * w)),
            re
        }
        ,
        u.prototype.readIntBE = function(v, w, H) {
            v = v >>> 0,
            w = w >>> 0,
            H || Z(v, w, this.length);
            let re = w
              , _e = 1
              , we = this[v + --re];
            for (; re > 0 && (_e *= 256); )
                we += this[v + --re] * _e;
            return _e *= 128,
            we >= _e && (we -= Math.pow(2, 8 * w)),
            we
        }
        ,
        u.prototype.readInt8 = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 1, this.length),
            this[v] & 128 ? (255 - this[v] + 1) * -1 : this[v]
        }
        ,
        u.prototype.readInt16LE = function(v, w) {
            v = v >>> 0,
            w || Z(v, 2, this.length);
            const H = this[v] | this[v + 1] << 8;
            return H & 32768 ? H | 4294901760 : H
        }
        ,
        u.prototype.readInt16BE = function(v, w) {
            v = v >>> 0,
            w || Z(v, 2, this.length);
            const H = this[v + 1] | this[v] << 8;
            return H & 32768 ? H | 4294901760 : H
        }
        ,
        u.prototype.readInt32LE = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 4, this.length),
            this[v] | this[v + 1] << 8 | this[v + 2] << 16 | this[v + 3] << 24
        }
        ,
        u.prototype.readInt32BE = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 4, this.length),
            this[v] << 24 | this[v + 1] << 16 | this[v + 2] << 8 | this[v + 3]
        }
        ,
        u.prototype.readBigInt64LE = Be(function(v) {
            v = v >>> 0,
            q(v, "offset");
            const w = this[v]
              , H = this[v + 7];
            (w === void 0 || H === void 0) && te(v, this.length - 8);
            const re = this[v + 4] + this[v + 5] * 2 ** 8 + this[v + 6] * 2 ** 16 + (H << 24);
            return (BigInt(re) << BigInt(32)) + BigInt(w + this[++v] * 2 ** 8 + this[++v] * 2 ** 16 + this[++v] * 2 ** 24)
        }),
        u.prototype.readBigInt64BE = Be(function(v) {
            v = v >>> 0,
            q(v, "offset");
            const w = this[v]
              , H = this[v + 7];
            (w === void 0 || H === void 0) && te(v, this.length - 8);
            const re = (w << 24) + this[++v] * 2 ** 16 + this[++v] * 2 ** 8 + this[++v];
            return (BigInt(re) << BigInt(32)) + BigInt(this[++v] * 2 ** 24 + this[++v] * 2 ** 16 + this[++v] * 2 ** 8 + H)
        }),
        u.prototype.readFloatLE = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 4, this.length),
            n.read(this, v, !0, 23, 4)
        }
        ,
        u.prototype.readFloatBE = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 4, this.length),
            n.read(this, v, !1, 23, 4)
        }
        ,
        u.prototype.readDoubleLE = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 8, this.length),
            n.read(this, v, !0, 52, 8)
        }
        ,
        u.prototype.readDoubleBE = function(v, w) {
            return v = v >>> 0,
            w || Z(v, 8, this.length),
            n.read(this, v, !1, 52, 8)
        }
        ;
        function ie(C, v, w, H, re, _e) {
            if (!u.isBuffer(C))
                throw new TypeError('"buffer" argument must be a Buffer instance');
            if (v > re || v < _e)
                throw new RangeError('"value" argument is out of bounds');
            if (w + H > C.length)
                throw new RangeError("Index out of range")
        }
        u.prototype.writeUintLE = u.prototype.writeUIntLE = function(v, w, H, re) {
            if (v = +v,
            w = w >>> 0,
            H = H >>> 0,
            !re) {
                const Oe = Math.pow(2, 8 * H) - 1;
                ie(this, v, w, H, Oe, 0)
            }
            let _e = 1
              , we = 0;
            for (this[w] = v & 255; ++we < H && (_e *= 256); )
                this[w + we] = v / _e & 255;
            return w + H
        }
        ,
        u.prototype.writeUintBE = u.prototype.writeUIntBE = function(v, w, H, re) {
            if (v = +v,
            w = w >>> 0,
            H = H >>> 0,
            !re) {
                const Oe = Math.pow(2, 8 * H) - 1;
                ie(this, v, w, H, Oe, 0)
            }
            let _e = H - 1
              , we = 1;
            for (this[w + _e] = v & 255; --_e >= 0 && (we *= 256); )
                this[w + _e] = v / we & 255;
            return w + H
        }
        ,
        u.prototype.writeUint8 = u.prototype.writeUInt8 = function(v, w, H) {
            return v = +v,
            w = w >>> 0,
            H || ie(this, v, w, 1, 255, 0),
            this[w] = v & 255,
            w + 1
        }
        ,
        u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(v, w, H) {
            return v = +v,
            w = w >>> 0,
            H || ie(this, v, w, 2, 65535, 0),
            this[w] = v & 255,
            this[w + 1] = v >>> 8,
            w + 2
        }
        ,
        u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(v, w, H) {
            return v = +v,
            w = w >>> 0,
            H || ie(this, v, w, 2, 65535, 0),
            this[w] = v >>> 8,
            this[w + 1] = v & 255,
            w + 2
        }
        ,
        u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(v, w, H) {
            return v = +v,
            w = w >>> 0,
            H || ie(this, v, w, 4, 4294967295, 0),
            this[w + 3] = v >>> 24,
            this[w + 2] = v >>> 16,
            this[w + 1] = v >>> 8,
            this[w] = v & 255,
            w + 4
        }
        ,
        u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(v, w, H) {
            return v = +v,
            w = w >>> 0,
            H || ie(this, v, w, 4, 4294967295, 0),
            this[w] = v >>> 24,
            this[w + 1] = v >>> 16,
            this[w + 2] = v >>> 8,
            this[w + 3] = v & 255,
            w + 4
        }
        ;
        function ee(C, v, w, H, re) {
            Te(v, H, re, C, w, 7);
            let _e = Number(v & BigInt(4294967295));
            C[w++] = _e,
            _e = _e >> 8,
            C[w++] = _e,
            _e = _e >> 8,
            C[w++] = _e,
            _e = _e >> 8,
            C[w++] = _e;
            let we = Number(v >> BigInt(32) & BigInt(4294967295));
            return C[w++] = we,
            we = we >> 8,
            C[w++] = we,
            we = we >> 8,
            C[w++] = we,
            we = we >> 8,
            C[w++] = we,
            w
        }
        function me(C, v, w, H, re) {
            Te(v, H, re, C, w, 7);
            let _e = Number(v & BigInt(4294967295));
            C[w + 7] = _e,
            _e = _e >> 8,
            C[w + 6] = _e,
            _e = _e >> 8,
            C[w + 5] = _e,
            _e = _e >> 8,
            C[w + 4] = _e;
            let we = Number(v >> BigInt(32) & BigInt(4294967295));
            return C[w + 3] = we,
            we = we >> 8,
            C[w + 2] = we,
            we = we >> 8,
            C[w + 1] = we,
            we = we >> 8,
            C[w] = we,
            w + 8
        }
        u.prototype.writeBigUInt64LE = Be(function(v, w=0) {
            return ee(this, v, w, BigInt(0), BigInt("0xffffffffffffffff"))
        }),
        u.prototype.writeBigUInt64BE = Be(function(v, w=0) {
            return me(this, v, w, BigInt(0), BigInt("0xffffffffffffffff"))
        }),
        u.prototype.writeIntLE = function(v, w, H, re) {
            if (v = +v,
            w = w >>> 0,
            !re) {
                const Ye = Math.pow(2, 8 * H - 1);
                ie(this, v, w, H, Ye - 1, -Ye)
            }
            let _e = 0
              , we = 1
              , Oe = 0;
            for (this[w] = v & 255; ++_e < H && (we *= 256); )
                v < 0 && Oe === 0 && this[w + _e - 1] !== 0 && (Oe = 1),
                this[w + _e] = (v / we >> 0) - Oe & 255;
            return w + H
        }
        ,
        u.prototype.writeIntBE = function(v, w, H, re) {
            if (v = +v,
            w = w >>> 0,
            !re) {
                const Ye = Math.pow(2, 8 * H - 1);
                ie(this, v, w, H, Ye - 1, -Ye)
            }
            let _e = H - 1
              , we = 1
              , Oe = 0;
            for (this[w + _e] = v & 255; --_e >= 0 && (we *= 256); )
                v < 0 && Oe === 0 && this[w + _e + 1] !== 0 && (Oe = 1),
                this[w + _e] = (v / we >> 0) - Oe & 255;
            return w + H
        }
        ,
        u.prototype.writeInt8 = function(v, w, H) {
            return v = +v,
            w = w >>> 0,
            H || ie(this, v, w, 1, 127, -128),
            v < 0 && (v = 255 + v + 1),
            this[w] = v & 255,
            w + 1
        }
        ,
        u.prototype.writeInt16LE = function(v, w, H) {
            return v = +v,
            w = w >>> 0,
            H || ie(this, v, w, 2, 32767, -32768),
            this[w] = v & 255,
            this[w + 1] = v >>> 8,
            w + 2
        }
        ,
        u.prototype.writeInt16BE = function(v, w, H) {
            return v = +v,
            w = w >>> 0,
            H || ie(this, v, w, 2, 32767, -32768),
            this[w] = v >>> 8,
            this[w + 1] = v & 255,
            w + 2
        }
        ,
        u.prototype.writeInt32LE = function(v, w, H) {
            return v = +v,
            w = w >>> 0,
            H || ie(this, v, w, 4, 2147483647, -2147483648),
            this[w] = v & 255,
            this[w + 1] = v >>> 8,
            this[w + 2] = v >>> 16,
            this[w + 3] = v >>> 24,
            w + 4
        }
        ,
        u.prototype.writeInt32BE = function(v, w, H) {
            return v = +v,
            w = w >>> 0,
            H || ie(this, v, w, 4, 2147483647, -2147483648),
            v < 0 && (v = 4294967295 + v + 1),
            this[w] = v >>> 24,
            this[w + 1] = v >>> 16,
            this[w + 2] = v >>> 8,
            this[w + 3] = v & 255,
            w + 4
        }
        ,
        u.prototype.writeBigInt64LE = Be(function(v, w=0) {
            return ee(this, v, w, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        }),
        u.prototype.writeBigInt64BE = Be(function(v, w=0) {
            return me(this, v, w, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
        });
        function W(C, v, w, H, re, _e) {
            if (w + H > C.length)
                throw new RangeError("Index out of range");
            if (w < 0)
                throw new RangeError("Index out of range")
        }
        function G(C, v, w, H, re) {
            return v = +v,
            w = w >>> 0,
            re || W(C, v, w, 4),
            n.write(C, v, w, H, 23, 4),
            w + 4
        }
        u.prototype.writeFloatLE = function(v, w, H) {
            return G(this, v, w, !0, H)
        }
        ,
        u.prototype.writeFloatBE = function(v, w, H) {
            return G(this, v, w, !1, H)
        }
        ;
        function Y(C, v, w, H, re) {
            return v = +v,
            w = w >>> 0,
            re || W(C, v, w, 8),
            n.write(C, v, w, H, 52, 8),
            w + 8
        }
        u.prototype.writeDoubleLE = function(v, w, H) {
            return Y(this, v, w, !0, H)
        }
        ,
        u.prototype.writeDoubleBE = function(v, w, H) {
            return Y(this, v, w, !1, H)
        }
        ,
        u.prototype.copy = function(v, w, H, re) {
            if (!u.isBuffer(v))
                throw new TypeError("argument should be a Buffer");
            if (H || (H = 0),
            !re && re !== 0 && (re = this.length),
            w >= v.length && (w = v.length),
            w || (w = 0),
            re > 0 && re < H && (re = H),
            re === H || v.length === 0 || this.length === 0)
                return 0;
            if (w < 0)
                throw new RangeError("targetStart out of bounds");
            if (H < 0 || H >= this.length)
                throw new RangeError("Index out of range");
            if (re < 0)
                throw new RangeError("sourceEnd out of bounds");
            re > this.length && (re = this.length),
            v.length - w < re - H && (re = v.length - w + H);
            const _e = re - H;
            return this === v && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(w, H, re) : Uint8Array.prototype.set.call(v, this.subarray(H, re), w),
            _e
        }
        ,
        u.prototype.fill = function(v, w, H, re) {
            if (typeof v == "string") {
                if (typeof w == "string" ? (re = w,
                w = 0,
                H = this.length) : typeof H == "string" && (re = H,
                H = this.length),
                re !== void 0 && typeof re != "string")
                    throw new TypeError("encoding must be a string");
                if (typeof re == "string" && !u.isEncoding(re))
                    throw new TypeError("Unknown encoding: " + re);
                if (v.length === 1) {
                    const we = v.charCodeAt(0);
                    (re === "utf8" && we < 128 || re === "latin1") && (v = we)
                }
            } else
                typeof v == "number" ? v = v & 255 : typeof v == "boolean" && (v = Number(v));
            if (w < 0 || this.length < w || this.length < H)
                throw new RangeError("Out of range index");
            if (H <= w)
                return this;
            w = w >>> 0,
            H = H === void 0 ? this.length : H >>> 0,
            v || (v = 0);
            let _e;
            if (typeof v == "number")
                for (_e = w; _e < H; ++_e)
                    this[_e] = v;
            else {
                const we = u.isBuffer(v) ? v : u.from(v, re)
                  , Oe = we.length;
                if (Oe === 0)
                    throw new TypeError('The value "' + v + '" is invalid for argument "value"');
                for (_e = 0; _e < H - w; ++_e)
                    this[_e + w] = we[_e % Oe]
            }
            return this
        }
        ;
        const K = {};
        function le(C, v, w) {
            K[C] = class extends w {
                constructor() {
                    super(),
                    Object.defineProperty(this, "message", {
                        value: v.apply(this, arguments),
                        writable: !0,
                        configurable: !0
                    }),
                    this.name = `${this.name} [${C}]`,
                    this.stack,
                    delete this.name
                }
                get code() {
                    return C
                }
                set code(re) {
                    Object.defineProperty(this, "code", {
                        configurable: !0,
                        enumerable: !0,
                        value: re,
                        writable: !0
                    })
                }
                toString() {
                    return `${this.name} [${C}]: ${this.message}`
                }
            }
        }
        le("ERR_BUFFER_OUT_OF_BOUNDS", function(C) {
            return C ? `${C} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
        }, RangeError),
        le("ERR_INVALID_ARG_TYPE", function(C, v) {
            return `The "${C}" argument must be of type number. Received type ${typeof v}`
        }, TypeError),
        le("ERR_OUT_OF_RANGE", function(C, v, w) {
            let H = `The value of "${C}" is out of range.`
              , re = w;
            return Number.isInteger(w) && Math.abs(w) > 2 ** 32 ? re = ce(String(w)) : typeof w == "bigint" && (re = String(w),
            (w > BigInt(2) ** BigInt(32) || w < -(BigInt(2) ** BigInt(32))) && (re = ce(re)),
            re += "n"),
            H += ` It must be ${v}. Received ${re}`,
            H
        }, RangeError);
        function ce(C) {
            let v = ""
              , w = C.length;
            const H = C[0] === "-" ? 1 : 0;
            for (; w >= H + 4; w -= 3)
                v = `_ ${C.slice(w - 3, w)}${v}`;
            return `${C.slice(0, w)}${v}`
        }
        function Ee(C, v, w) {
            q(v, "offset"),
            (C[v] === void 0 || C[v + w] === void 0) && te(v, C.length - (w + 1))
        }
        function Te(C, v, w, H, re, _e) {
            if (C > w || C < v) {
                const we = typeof v == "bigint" ? "n" : "";
                let Oe;
                throw v === 0 || v === BigInt(0) ? Oe = `>= 0 ${we} and < 2 ${we} ** ${(_e + 1) * 8}${we}` : Oe = `>= -(2 ${we} ** ${(_e + 1) * 8 - 1}${we}) and < 2 ** ${(_e + 1) * 8 - 1}${we}`,
                new K.ERR_OUT_OF_RANGE("value",Oe,C)
            }
            Ee(H, re, _e)
        }
        function q(C, v) {
            if (typeof C != "number")
                throw new K.ERR_INVALID_ARG_TYPE(v,"number",C)
        }
        function te(C, v, w) {
            throw Math.floor(C) !== C ? (q(C, w),
            new K.ERR_OUT_OF_RANGE("offset","an integer",C)) : v < 0 ? new K.ERR_BUFFER_OUT_OF_BOUNDS : new K.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${v}`,C)
        }
        const fe = /[^+/0-9A-Za-z-_]/g;
        function xe(C) {
            if (C = C.split("=")[0],
            C = C.trim().replace(fe, ""),
            C.length < 2)
                return "";
            for (; C.length % 4 !== 0; )
                C = C + "=";
            return C
        }
        function Se(C, v) {
            v = v || 1 / 0;
            let w;
            const H = C.length;
            let re = null;
            const _e = [];
            for (let we = 0; we < H; ++we) {
                if (w = C.charCodeAt(we),
                w > 55295 && w < 57344) {
                    if (!re) {
                        if (w > 56319) {
                            (v -= 3) > -1 && _e.push(239, 191, 189);
                            continue
                        } else if (we + 1 === H) {
                            (v -= 3) > -1 && _e.push(239, 191, 189);
                            continue
                        }
                        re = w;
                        continue
                    }
                    if (w < 56320) {
                        (v -= 3) > -1 && _e.push(239, 191, 189),
                        re = w;
                        continue
                    }
                    w = (re - 55296 << 10 | w - 56320) + 65536
                } else
                    re && (v -= 3) > -1 && _e.push(239, 191, 189);
                if (re = null,
                w < 128) {
                    if ((v -= 1) < 0)
                        break;
                    _e.push(w)
                } else if (w < 2048) {
                    if ((v -= 2) < 0)
                        break;
                    _e.push(w >> 6 | 192, w & 63 | 128)
                } else if (w < 65536) {
                    if ((v -= 3) < 0)
                        break;
                    _e.push(w >> 12 | 224, w >> 6 & 63 | 128, w & 63 | 128)
                } else if (w < 1114112) {
                    if ((v -= 4) < 0)
                        break;
                    _e.push(w >> 18 | 240, w >> 12 & 63 | 128, w >> 6 & 63 | 128, w & 63 | 128)
                } else
                    throw new Error("Invalid code point")
            }
            return _e
        }
        function Ie(C) {
            const v = [];
            for (let w = 0; w < C.length; ++w)
                v.push(C.charCodeAt(w) & 255);
            return v
        }
        function se(C, v) {
            let w, H, re;
            const _e = [];
            for (let we = 0; we < C.length && !((v -= 2) < 0); ++we)
                w = C.charCodeAt(we),
                H = w >> 8,
                re = w % 256,
                _e.push(re),
                _e.push(H);
            return _e
        }
        function be(C) {
            return e.toByteArray(xe(C))
        }
        function Ne(C, v, w, H) {
            let re;
            for (re = 0; re < H && !(re + w >= v.length || re >= C.length); ++re)
                v[re + w] = C[re];
            return re
        }
        function ve(C, v) {
            return C instanceof v || C != null && C.constructor != null && C.constructor.name != null && C.constructor.name === v.name
        }
        function $e(C) {
            return C !== C
        }
        const mt = (function() {
            const C = "0123456789abcdef"
              , v = new Array(256);
            for (let w = 0; w < 16; ++w) {
                const H = w * 16;
                for (let re = 0; re < 16; ++re)
                    v[H + re] = C[w] + C[re]
            }
            return v
        }
        )();
        function Be(C) {
            return typeof BigInt > "u" ? ft : C
        }
        function ft() {
            throw new Error("BigInt not supported")
        }
    }
    )(Co)),
    Co
}
var vg = Rn();
const cr = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  , dr = "http://www.w3.org/2001/XMLSchema#"
  , fs = "http://www.w3.org/2000/10/swap/"
  , Lt = {
    xsd: {
        decimal: `${dr}decimal`,
        boolean: `${dr}boolean`,
        double: `${dr}double`,
        integer: `${dr}integer`,
        string: `${dr}string`
    },
    rdf: {
        type: `${cr}type`,
        nil: `${cr}nil`,
        first: `${cr}first`,
        rest: `${cr}rest`,
        langString: `${cr}langString`
    },
    owl: {
        sameAs: "http://www.w3.org/2002/07/owl#sameAs"
    },
    r: {
        forSome: `${fs}reify#forSome`,
        forAll: `${fs}reify#forAll`
    },
    log: {
        implies: `${fs}log#implies`,
        isImpliedBy: `${fs}log#isImpliedBy`
    }
}
  , {xsd: ps} = Lt
  , bg = /\\u([a-fA-F0-9]{4})|\\U([a-fA-F0-9]{8})|\\([^])/g
  , tc = {
    "\\": "\\",
    "'": "'",
    '"': '"',
    n: `
`,
    r: "\r",
    t: "	",
    f: "\f",
    b: "\b",
    _: "_",
    "~": "~",
    ".": ".",
    "-": "-",
    "!": "!",
    $: "$",
    "&": "&",
    "(": "(",
    ")": ")",
    "*": "*",
    "+": "+",
    ",": ",",
    ";": ";",
    "=": "=",
    "/": "/",
    "?": "?",
    "#": "#",
    "@": "@",
    "%": "%"
}
  , wg = /[\x00-\x20<>\\"\{\}\|\^\`]/
  , xg = {
    _iri: !0,
    _unescapedIri: !0,
    _simpleQuotedString: !0,
    _langcode: !0,
    _blank: !0,
    _newline: !0,
    _comment: !0,
    _whitespace: !0,
    _endOfFile: !0
}
  , Eg = /$0^/;
class Sg {
    constructor(e) {
        if (this._iri = /^<((?:[^ <>{}\\]|\\[uU])+)>[ \t]*/,
        this._unescapedIri = /^<([^\x00-\x20<>\\"\{\}\|\^\`]*)>[ \t]*/,
        this._simpleQuotedString = /^"([^"\\\r\n]*)"(?=[^"])/,
        this._simpleApostropheString = /^'([^'\\\r\n]*)'(?=[^'])/,
        this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\-])/i,
        this._prefix = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:(?=[#\s<])/,
        this._prefixed = /^((?:[A-Za-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)?:((?:(?:[0-:A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])(?:(?:[\.\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~])*(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff]|%[0-9a-fA-F]{2}|\\[!#-\/;=?\-@_~]))?)?)(?:[ \t]+|(?=\.?[,;!\^\s#()\[\]\{\}"'<>]))/,
        this._variable = /^\?(?:(?:[A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:[\-0-:A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?=[.,;!\^\s#()\[\]\{\}"'<>])/,
        this._blank = /^_:((?:[0-9A-Z_a-z\xc0-\xd6\xd8-\xf6\xf8-\u02ff\u0370-\u037d\u037f-\u1fff\u200c\u200d\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])(?:\.?[\-0-9A-Z_a-z\xb7\xc0-\xd6\xd8-\xf6\xf8-\u037d\u037f-\u1fff\u200c\u200d\u203f\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]|[\ud800-\udb7f][\udc00-\udfff])*)(?:[ \t]+|(?=\.?[,;:\s#()\[\]\{\}"'<>]))/,
        this._number = /^[\-+]?(?:(\d+\.\d*|\.?\d+)[eE][\-+]?|\d*(\.)?)\d+(?=\.?[,;:\s#()\[\]\{\}"'<>])/,
        this._boolean = /^(?:true|false)(?=[.,;\s#()\[\]\{\}"'<>])/,
        this._keyword = /^@[a-z]+(?=[\s#<:])/i,
        this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\s#<])/i,
        this._shortPredicates = /^a(?=[\s#()\[\]\{\}"'<>])/,
        this._newline = /^[ \t]*(?:#[^\n\r]*)?(?:\r\n|\n|\r)[ \t]*/,
        this._comment = /#([^\n\r]*)/,
        this._whitespace = /^[ \t]+/,
        this._endOfFile = /^(?:#[^\n\r]*)?$/,
        e = e || {},
        this._isImpliedBy = e.isImpliedBy,
        this._lineMode = !!e.lineMode) {
            this._n3Mode = !1;
            for (const n in this)
                !(n in xg) && this[n]instanceof RegExp && (this[n] = Eg)
        } else
            this._n3Mode = e.n3 !== !1;
        this.comments = !!e.comments,
        this._literalClosingPos = 0
    }
    _tokenizeToEnd(e, n) {
        let r = this._input
          , o = r.length;
        for (; ; ) {
            let u, f;
            for (; u = this._newline.exec(r); )
                this.comments && (f = this._comment.exec(u[0])) && a("comment", f[1], "", this._line, u[0].length),
                r = r.substr(u[0].length, r.length),
                o = r.length,
                this._line++;
            if (!u && (u = this._whitespace.exec(r)) && (r = r.substr(u[0].length, r.length)),
            this._endOfFile.test(r))
                return n && (this.comments && (f = this._comment.exec(r)) && a("comment", f[1], "", this._line, r.length),
                r = null,
                a("eof", "", "", this._line, 0)),
                this._input = r;
            const h = this._line
              , m = r[0];
            let _ = ""
              , d = ""
              , g = ""
              , b = null
              , T = 0
              , N = !1;
            switch (m) {
            case "^":
                if (r.length < 3)
                    break;
                if (r[1] === "^") {
                    if (this._previousMarker = "^^",
                    r = r.substr(2),
                    r[0] !== "<") {
                        N = !0;
                        break
                    }
                } else {
                    this._n3Mode && (T = 1,
                    _ = "^");
                    break
                }
            case "<":
                if (b = this._unescapedIri.exec(r))
                    _ = "IRI",
                    d = b[1];
                else if (b = this._iri.exec(r)) {
                    if (d = this._unescape(b[1]),
                    d === null || wg.test(d))
                        return l(this);
                    _ = "IRI"
                } else
                    r.length > 1 && r[1] === "<" ? (_ = "<<",
                    T = 2) : this._n3Mode && r.length > 1 && r[1] === "=" && (T = 2,
                    this._isImpliedBy ? (_ = "abbreviation",
                    d = "<") : (_ = "inverse",
                    d = ">"));
                break;
            case ">":
                r.length > 1 && r[1] === ">" && (_ = ">>",
                T = 2);
                break;
            case "_":
                ((b = this._blank.exec(r)) || n && (b = this._blank.exec(`${r} `))) && (_ = "blank",
                g = "_",
                d = b[1]);
                break;
            case '"':
                if (b = this._simpleQuotedString.exec(r))
                    d = b[1];
                else if ({value: d, matchLength: T} = this._parseLiteral(r),
                d === null)
                    return l(this);
                (b !== null || T !== 0) && (_ = "literal",
                this._literalClosingPos = 0);
                break;
            case "'":
                if (!this._lineMode) {
                    if (b = this._simpleApostropheString.exec(r))
                        d = b[1];
                    else if ({value: d, matchLength: T} = this._parseLiteral(r),
                    d === null)
                        return l(this);
                    (b !== null || T !== 0) && (_ = "literal",
                    this._literalClosingPos = 0)
                }
                break;
            case "?":
                this._n3Mode && (b = this._variable.exec(r)) && (_ = "var",
                d = b[0]);
                break;
            case "@":
                this._previousMarker === "literal" && (b = this._langcode.exec(r)) ? (_ = "langcode",
                d = b[1]) : (b = this._keyword.exec(r)) && (_ = b[0]);
                break;
            case ".":
                if (r.length === 1 ? n : r[1] < "0" || r[1] > "9") {
                    _ = ".",
                    T = 1;
                    break
                }
            case "0":
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
            case "+":
            case "-":
                (b = this._number.exec(r) || n && (b = this._number.exec(`${r} `))) && (_ = "literal",
                d = b[0],
                g = typeof b[1] == "string" ? ps.double : typeof b[2] == "string" ? ps.decimal : ps.integer);
                break;
            case "B":
            case "b":
            case "p":
            case "P":
            case "G":
            case "g":
                (b = this._sparqlKeyword.exec(r)) ? _ = b[0].toUpperCase() : N = !0;
                break;
            case "f":
            case "t":
                (b = this._boolean.exec(r)) ? (_ = "literal",
                d = b[0],
                g = ps.boolean) : N = !0;
                break;
            case "a":
                (b = this._shortPredicates.exec(r)) ? (_ = "abbreviation",
                d = "a") : N = !0;
                break;
            case "=":
                this._n3Mode && r.length > 1 && (_ = "abbreviation",
                r[1] !== ">" ? (T = 1,
                d = "=") : (T = 2,
                d = ">"));
                break;
            case "!":
                if (!this._n3Mode)
                    break;
            case ",":
            case ";":
            case "[":
            case "]":
            case "(":
            case ")":
            case "}":
                this._lineMode || (T = 1,
                _ = m);
                break;
            case "{":
                !this._lineMode && r.length >= 2 && (r[1] === "|" ? (_ = "{|",
                T = 2) : (_ = m,
                T = 1));
                break;
            case "|":
                r.length >= 2 && r[1] === "}" && (_ = "|}",
                T = 2);
                break;
            default:
                N = !0
            }
            if (N && ((this._previousMarker === "@prefix" || this._previousMarker === "PREFIX") && (b = this._prefix.exec(r)) ? (_ = "prefix",
            d = b[1] || "") : ((b = this._prefixed.exec(r)) || n && (b = this._prefixed.exec(`${r} `))) && (_ = "prefixed",
            g = b[1] || "",
            d = this._unescape(b[2]))),
            this._previousMarker === "^^")
                switch (_) {
                case "prefixed":
                    _ = "type";
                    break;
                case "IRI":
                    _ = "typeIRI";
                    break;
                default:
                    _ = ""
                }
            if (!_)
                return n || !/^'''|^"""/.test(r) && /\n|\r/.test(r) ? l(this) : this._input = r;
            const A = T || b[0].length
              , R = a(_, d, g, h, A);
            this.previousToken = R,
            this._previousMarker = _,
            r = r.substr(A, r.length)
        }
        function a(u, f, h, m, _) {
            const d = r ? o - r.length : o
              , g = d + _
              , b = {
                type: u,
                value: f,
                prefix: h,
                line: m,
                start: d,
                end: g
            };
            return e(null, b),
            b
        }
        function l(u) {
            e(u._syntaxError(/^\S*/.exec(r)[0]))
        }
    }
    _unescape(e) {
        let n = !1;
        const r = e.replace(bg, (o,a,l,u)=>{
            if (typeof a == "string")
                return String.fromCharCode(Number.parseInt(a, 16));
            if (typeof l == "string") {
                let f = Number.parseInt(l, 16);
                return f <= 65535 ? String.fromCharCode(Number.parseInt(l, 16)) : String.fromCharCode(55296 + ((f -= 65536) >> 10), 56320 + (f & 1023))
            }
            return u in tc ? tc[u] : (n = !0,
            "")
        }
        );
        return n ? null : r
    }
    _parseLiteral(e) {
        if (e.length >= 3) {
            const n = e.match(/^(?:"""|"|'''|'|)/)[0]
              , r = n.length;
            let o = Math.max(this._literalClosingPos, r);
            for (; (o = e.indexOf(n, o)) > 0; ) {
                let a = 0;
                for (; e[o - a - 1] === "\\"; )
                    a++;
                if (a % 2 === 0) {
                    const l = e.substring(r, o)
                      , u = l.split(/\r\n|\r|\n/).length - 1
                      , f = o + r;
                    if (r === 1 && u !== 0 || r === 3 && this._lineMode)
                        break;
                    return this._line += u,
                    {
                        value: this._unescape(l),
                        matchLength: f
                    }
                }
                o++
            }
            this._literalClosingPos = e.length - r + 1
        }
        return {
            value: "",
            matchLength: 0
        }
    }
    _syntaxError(e) {
        this._input = null;
        const n = new Error(`Unexpected "${e}" on line ${this._line}.`);
        return n.context = {
            token: void 0,
            line: this._line,
            previousToken: this.previousToken
        },
        n
    }
    _readStartingBom(e) {
        return e.startsWith("\uFEFF") ? e.substr(1) : e
    }
    tokenize(e, n) {
        if (this._line = 1,
        typeof e == "string")
            if (this._input = this._readStartingBom(e),
            typeof n == "function")
                queueMicrotask(()=>this._tokenizeToEnd(n, !0));
            else {
                const r = [];
                let o;
                if (this._tokenizeToEnd((a,l)=>a ? o = a : r.push(l), !0),
                o)
                    throw o;
                return r
            }
        else
            this._pendingBuffer = null,
            typeof e.setEncoding == "function" && e.setEncoding("utf8"),
            e.on("data", r=>{
                this._input !== null && r.length !== 0 && (this._pendingBuffer && (r = vg.Buffer.concat([this._pendingBuffer, r]),
                this._pendingBuffer = null),
                r[r.length - 1] & 128 ? this._pendingBuffer = r : (typeof this._input > "u" ? this._input = this._readStartingBom(typeof r == "string" ? r : r.toString()) : this._input += r,
                this._tokenizeToEnd(n, !1)))
            }
            ),
            e.on("end", ()=>{
                typeof this._input == "string" && this._tokenizeToEnd(n, !0)
            }
            ),
            e.on("error", n)
    }
}
const {rdf: Tg, xsd: di} = Lt;
let Vi, Lg = 0;
const ze = {
    namedNode: nf,
    blankNode: rf,
    variable: of,
    literal: sf,
    defaultGraph: Rg,
    quad: yl,
    triple: yl,
    fromTerm: Cr,
    fromQuad: af
};
class an {
    constructor(e) {
        this.id = e
    }
    get value() {
        return this.id
    }
    equals(e) {
        return e instanceof an ? this.id === e.id : !!e && this.termType === e.termType && this.value === e.value
    }
    hashCode() {
        return 0
    }
    toJSON() {
        return {
            termType: this.termType,
            value: this.value
        }
    }
}
let mi = class extends an {
    get termType() {
        return "NamedNode"
    }
}
  , Wt = class tf extends an {
    get termType() {
        return "Literal"
    }
    get value() {
        return this.id.substring(1, this.id.lastIndexOf('"'))
    }
    get language() {
        const e = this.id;
        let n = e.lastIndexOf('"') + 1;
        return n < e.length && e[n++] === "@" ? e.substr(n).toLowerCase() : ""
    }
    get datatype() {
        return new mi(this.datatypeString)
    }
    get datatypeString() {
        const e = this.id
          , n = e.lastIndexOf('"') + 1
          , r = n < e.length ? e[n] : "";
        return r === "^" ? e.substr(n + 2) : r !== "@" ? di.string : Tg.langString
    }
    equals(e) {
        return e instanceof tf ? this.id === e.id : !!e && !!e.datatype && this.termType === e.termType && this.value === e.value && this.language === e.language && this.datatype.value === e.datatype.value
    }
    toJSON() {
        return {
            termType: this.termType,
            value: this.value,
            language: this.language,
            datatype: {
                termType: "NamedNode",
                value: this.datatypeString
            }
        }
    }
}
  , Ig = class extends an {
    constructor(e) {
        super(`_:${e}`)
    }
    get termType() {
        return "BlankNode"
    }
    get value() {
        return this.id.substr(2)
    }
}
  , Ng = class extends an {
    constructor(e) {
        super(`?${e}`)
    }
    get termType() {
        return "Variable"
    }
    get value() {
        return this.id.substr(1)
    }
}
  , Ag = class extends an {
    constructor() {
        return super(""),
        Vi || this
    }
    get termType() {
        return "DefaultGraph"
    }
    equals(e) {
        return this === e || !!e && this.termType === e.termType
    }
}
;
Vi = new Ag;
function Rr(i, e, n) {
    if (e = e || ze,
    !i)
        return e.defaultGraph();
    switch (i[0]) {
    case "?":
        return e.variable(i.substr(1));
    case "_":
        return e.blankNode(i.substr(2));
    case '"':
        if (e === ze)
            return new Wt(i);
        if (i[i.length - 1] === '"')
            return e.literal(i.substr(1, i.length - 2));
        const r = i.lastIndexOf('"', i.length - 1);
        return e.literal(i.substr(1, r - 1), i[r + 1] === "@" ? i.substr(r + 2) : e.namedNode(i.substr(r + 3)));
    case "[":
        i = JSON.parse(i);
        break;
    default:
        if (!n || !Array.isArray(i))
            return e.namedNode(i)
    }
    return e.quad(Rr(i[0], e, !0), Rr(i[1], e, !0), Rr(i[2], e, !0), i[3] && Rr(i[3], e, !0))
}
function ji(i, e) {
    if (typeof i == "string")
        return i;
    if (i instanceof an && i.termType !== "Quad")
        return i.id;
    if (!i)
        return Vi.id;
    switch (i.termType) {
    case "NamedNode":
        return i.value;
    case "BlankNode":
        return `_:${i.value}`;
    case "Variable":
        return `?${i.value}`;
    case "DefaultGraph":
        return "";
    case "Literal":
        return `"${i.value}"${i.language ? `@${i.language}` : i.datatype && i.datatype.value !== di.string ? `^^${i.datatype.value}` : ""}`;
    case "Quad":
        const n = [ji(i.subject, !0), ji(i.predicate, !0), ji(i.object, !0)];
        return i.graph && i.graph.termType !== "DefaultGraph" && n.push(ji(i.graph, !0)),
        e ? n : JSON.stringify(n);
    default:
        throw new Error(`Unexpected termType: ${i.termType}`)
    }
}
let Us = class extends an {
    constructor(e, n, r, o) {
        super(""),
        this._subject = e,
        this._predicate = n,
        this._object = r,
        this._graph = o || Vi
    }
    get termType() {
        return "Quad"
    }
    get subject() {
        return this._subject
    }
    get predicate() {
        return this._predicate
    }
    get object() {
        return this._object
    }
    get graph() {
        return this._graph
    }
    toJSON() {
        return {
            termType: this.termType,
            subject: this._subject.toJSON(),
            predicate: this._predicate.toJSON(),
            object: this._object.toJSON(),
            graph: this._graph.toJSON()
        }
    }
    equals(e) {
        return !!e && this._subject.equals(e.subject) && this._predicate.equals(e.predicate) && this._object.equals(e.object) && this._graph.equals(e.graph)
    }
}
;
function nf(i) {
    return new mi(i)
}
function rf(i) {
    return new Ig(i || `n3-${Lg++}`)
}
function sf(i, e) {
    if (typeof e == "string")
        return new Wt(`"${i}"@${e.toLowerCase()}`);
    let n = e ? e.value : "";
    return n === "" && (typeof i == "boolean" ? n = di.boolean : typeof i == "number" && (Number.isFinite(i) ? n = Number.isInteger(i) ? di.integer : di.double : (n = di.double,
    Number.isNaN(i) || (i = i > 0 ? "INF" : "-INF")))),
    n === "" || n === di.string ? new Wt(`"${i}"`) : new Wt(`"${i}"^^${n}`)
}
function of(i) {
    return new Ng(i)
}
function Rg() {
    return Vi
}
function yl(i, e, n, r) {
    return new Us(i,e,n,r)
}
function Cr(i) {
    if (i instanceof an)
        return i;
    switch (i.termType) {
    case "NamedNode":
        return nf(i.value);
    case "BlankNode":
        return rf(i.value);
    case "Variable":
        return of(i.value);
    case "DefaultGraph":
        return Vi;
    case "Literal":
        return sf(i.value, i.language || i.datatype);
    case "Quad":
        return af(i);
    default:
        throw new Error(`Unexpected termType: ${i.termType}`)
    }
}
function af(i) {
    if (i instanceof Us)
        return i;
    if (i.termType !== "Quad")
        throw new Error(`Unexpected termType: ${i.termType}`);
    return yl(Cr(i.subject), Cr(i.predicate), Cr(i.object), Cr(i.graph))
}
let nc = 0;
class lf {
    constructor(e) {
        this._contextStack = [],
        this._graph = null,
        e = e || {},
        this._setBase(e.baseIRI),
        e.factory && uf(this, e.factory);
        const n = typeof e.format == "string" ? e.format.match(/\w*$/)[0].toLowerCase() : ""
          , r = /turtle/.test(n)
          , o = /trig/.test(n)
          , a = /triple/.test(n)
          , l = /quad/.test(n)
          , u = this._n3Mode = /n3/.test(n)
          , f = a || l;
        (this._supportsNamedGraphs = !(r || u)) || (this._readPredicateOrNamedGraph = this._readPredicate),
        this._supportsQuads = !(r || o || a || u),
        this._isImpliedBy = e.isImpliedBy,
        this._supportsRDFStar = n === "" || /star|\*$/.test(n),
        f && (this._resolveRelativeIRI = h=>null),
        this._blankNodePrefix = typeof e.blankNodePrefix != "string" ? "" : e.blankNodePrefix.replace(/^(?!_:)/, "_:"),
        this._lexer = e.lexer || new Sg({
            lineMode: f,
            n3: u,
            isImpliedBy: this._isImpliedBy
        }),
        this._explicitQuantifiers = !!e.explicitQuantifiers
    }
    static _resetBlankNodePrefix() {
        nc = 0
    }
    _setBase(e) {
        if (!e)
            this._base = "",
            this._basePath = "";
        else {
            const n = e.indexOf("#");
            n >= 0 && (e = e.substr(0, n)),
            this._base = e,
            this._basePath = e.indexOf("/") < 0 ? e : e.replace(/[^\/?]*(?:\?.*)?$/, ""),
            e = e.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\/\/[^\/]*)?/i),
            this._baseRoot = e[0],
            this._baseScheme = e[1]
        }
    }
    _saveContext(e, n, r, o, a) {
        const l = this._n3Mode;
        this._contextStack.push({
            type: e,
            subject: r,
            predicate: o,
            object: a,
            graph: n,
            inverse: l ? this._inversePredicate : !1,
            blankPrefix: l ? this._prefixes._ : "",
            quantified: l ? this._quantified : null
        }),
        l && (this._inversePredicate = !1,
        this._prefixes._ = this._graph ? `${this._graph.value}.` : ".",
        this._quantified = Object.create(this._quantified))
    }
    _restoreContext(e, n) {
        const r = this._contextStack.pop();
        if (!r || r.type !== e)
            return this._error(`Unexpected ${n.type}`, n);
        this._subject = r.subject,
        this._predicate = r.predicate,
        this._object = r.object,
        this._graph = r.graph,
        this._n3Mode && (this._inversePredicate = r.inverse,
        this._prefixes._ = r.blankPrefix,
        this._quantified = r.quantified)
    }
    _readInTopContext(e) {
        switch (e.type) {
        case "eof":
            return this._graph !== null ? this._error("Unclosed graph", e) : (delete this._prefixes._,
            this._callback(null, null, this._prefixes));
        case "PREFIX":
            this._sparqlStyle = !0;
        case "@prefix":
            return this._readPrefix;
        case "BASE":
            this._sparqlStyle = !0;
        case "@base":
            return this._readBaseIRI;
        case "{":
            if (this._supportsNamedGraphs)
                return this._graph = "",
                this._subject = null,
                this._readSubject;
        case "GRAPH":
            if (this._supportsNamedGraphs)
                return this._readNamedGraphLabel;
        default:
            return this._readSubject(e)
        }
    }
    _readEntity(e, n) {
        let r;
        switch (e.type) {
        case "IRI":
        case "typeIRI":
            const o = this._resolveIRI(e.value);
            if (o === null)
                return this._error("Invalid IRI", e);
            r = this._factory.namedNode(o);
            break;
        case "type":
        case "prefixed":
            const a = this._prefixes[e.prefix];
            if (a === void 0)
                return this._error(`Undefined prefix "${e.prefix}:"`, e);
            r = this._factory.namedNode(a + e.value);
            break;
        case "blank":
            r = this._factory.blankNode(this._prefixes[e.prefix] + e.value);
            break;
        case "var":
            r = this._factory.variable(e.value.substr(1));
            break;
        default:
            return this._error(`Expected entity but got ${e.type}`, e)
        }
        return !n && this._n3Mode && r.id in this._quantified && (r = this._quantified[r.id]),
        r
    }
    _readSubject(e) {
        switch (this._predicate = null,
        e.type) {
        case "[":
            return this._saveContext("blank", this._graph, this._subject = this._factory.blankNode(), null, null),
            this._readBlankNodeHead;
        case "(":
            return this._saveContext("list", this._graph, this.RDF_NIL, null, null),
            this._subject = null,
            this._readListItem;
        case "{":
            return this._n3Mode ? (this._saveContext("formula", this._graph, this._graph = this._factory.blankNode(), null, null),
            this._readSubject) : this._error("Unexpected graph", e);
        case "}":
            return this._readPunctuation(e);
        case "@forSome":
            return this._n3Mode ? (this._subject = null,
            this._predicate = this.N3_FORSOME,
            this._quantifier = "blankNode",
            this._readQuantifierList) : this._error('Unexpected "@forSome"', e);
        case "@forAll":
            return this._n3Mode ? (this._subject = null,
            this._predicate = this.N3_FORALL,
            this._quantifier = "variable",
            this._readQuantifierList) : this._error('Unexpected "@forAll"', e);
        case "literal":
            if (!this._n3Mode)
                return this._error("Unexpected literal", e);
            if (e.prefix.length === 0)
                return this._literalValue = e.value,
                this._completeSubjectLiteral;
            this._subject = this._factory.literal(e.value, this._factory.namedNode(e.prefix));
            break;
        case "<<":
            return this._supportsRDFStar ? (this._saveContext("<<", this._graph, null, null, null),
            this._graph = null,
            this._readSubject) : this._error("Unexpected RDF-star syntax", e);
        default:
            if ((this._subject = this._readEntity(e)) === void 0)
                return;
            if (this._n3Mode)
                return this._getPathReader(this._readPredicateOrNamedGraph)
        }
        return this._readPredicateOrNamedGraph
    }
    _readPredicate(e) {
        const n = e.type;
        switch (n) {
        case "inverse":
            this._inversePredicate = !0;
        case "abbreviation":
            this._predicate = this.ABBREVIATIONS[e.value];
            break;
        case ".":
        case "]":
        case "}":
            return this._predicate === null ? this._error(`Unexpected ${n}`, e) : (this._subject = null,
            n === "]" ? this._readBlankNodeTail(e) : this._readPunctuation(e));
        case ";":
            return this._predicate !== null ? this._readPredicate : this._error("Expected predicate but got ;", e);
        case "[":
            if (this._n3Mode)
                return this._saveContext("blank", this._graph, this._subject, this._subject = this._factory.blankNode(), null),
                this._readBlankNodeHead;
        case "blank":
            if (!this._n3Mode)
                return this._error("Disallowed blank node as predicate", e);
        default:
            if ((this._predicate = this._readEntity(e)) === void 0)
                return
        }
        return this._readObject
    }
    _readObject(e) {
        switch (e.type) {
        case "literal":
            if (e.prefix.length === 0)
                return this._literalValue = e.value,
                this._readDataTypeOrLang;
            this._object = this._factory.literal(e.value, this._factory.namedNode(e.prefix));
            break;
        case "[":
            return this._saveContext("blank", this._graph, this._subject, this._predicate, this._subject = this._factory.blankNode()),
            this._readBlankNodeHead;
        case "(":
            return this._saveContext("list", this._graph, this._subject, this._predicate, this.RDF_NIL),
            this._subject = null,
            this._readListItem;
        case "{":
            return this._n3Mode ? (this._saveContext("formula", this._graph, this._subject, this._predicate, this._graph = this._factory.blankNode()),
            this._readSubject) : this._error("Unexpected graph", e);
        case "<<":
            return this._supportsRDFStar ? (this._saveContext("<<", this._graph, this._subject, this._predicate, null),
            this._graph = null,
            this._readSubject) : this._error("Unexpected RDF-star syntax", e);
        default:
            if ((this._object = this._readEntity(e)) === void 0)
                return;
            if (this._n3Mode)
                return this._getPathReader(this._getContextEndReader())
        }
        return this._getContextEndReader()
    }
    _readPredicateOrNamedGraph(e) {
        return e.type === "{" ? this._readGraph(e) : this._readPredicate(e)
    }
    _readGraph(e) {
        return e.type !== "{" ? this._error(`Expected graph but got ${e.type}`, e) : (this._graph = this._subject,
        this._subject = null,
        this._readSubject)
    }
    _readBlankNodeHead(e) {
        return e.type === "]" ? (this._subject = null,
        this._readBlankNodeTail(e)) : (this._predicate = null,
        this._readPredicate(e))
    }
    _readBlankNodeTail(e) {
        if (e.type !== "]")
            return this._readBlankNodePunctuation(e);
        this._subject !== null && this._emit(this._subject, this._predicate, this._object, this._graph);
        const n = this._predicate === null;
        return this._restoreContext("blank", e),
        this._object !== null ? this._getContextEndReader() : this._predicate !== null ? this._readObject : n ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank
    }
    _readPredicateAfterBlank(e) {
        switch (e.type) {
        case ".":
        case "}":
            return this._subject = null,
            this._readPunctuation(e);
        default:
            return this._readPredicate(e)
        }
    }
    _readListItem(e) {
        let n = null
          , r = null
          , o = this._readListItem;
        const a = this._subject
          , l = this._contextStack
          , u = l[l.length - 1];
        switch (e.type) {
        case "[":
            this._saveContext("blank", this._graph, r = this._factory.blankNode(), this.RDF_FIRST, this._subject = n = this._factory.blankNode()),
            o = this._readBlankNodeHead;
            break;
        case "(":
            this._saveContext("list", this._graph, r = this._factory.blankNode(), this.RDF_FIRST, this.RDF_NIL),
            this._subject = null;
            break;
        case ")":
            if (this._restoreContext("list", e),
            l.length !== 0 && l[l.length - 1].type === "list" && this._emit(this._subject, this._predicate, this._object, this._graph),
            this._predicate === null) {
                if (o = this._readPredicate,
                this._subject === this.RDF_NIL)
                    return o
            } else if (o = this._getContextEndReader(),
            this._object === this.RDF_NIL)
                return o;
            r = this.RDF_NIL;
            break;
        case "literal":
            e.prefix.length === 0 ? (this._literalValue = e.value,
            o = this._readListItemDataTypeOrLang) : (n = this._factory.literal(e.value, this._factory.namedNode(e.prefix)),
            o = this._getContextEndReader());
            break;
        case "{":
            return this._n3Mode ? (this._saveContext("formula", this._graph, this._subject, this._predicate, this._graph = this._factory.blankNode()),
            this._readSubject) : this._error("Unexpected graph", e);
        default:
            if ((n = this._readEntity(e)) === void 0)
                return
        }
        if (r === null && (this._subject = r = this._factory.blankNode()),
        a === null ? u.predicate === null ? u.subject = r : u.object = r : this._emit(a, this.RDF_REST, r, this._graph),
        n !== null) {
            if (this._n3Mode && (e.type === "IRI" || e.type === "prefixed"))
                return this._saveContext("item", this._graph, r, this.RDF_FIRST, n),
                this._subject = n,
                this._predicate = null,
                this._getPathReader(this._readListItem);
            this._emit(r, this.RDF_FIRST, n, this._graph)
        }
        return o
    }
    _readDataTypeOrLang(e) {
        return this._completeObjectLiteral(e, !1)
    }
    _readListItemDataTypeOrLang(e) {
        return this._completeObjectLiteral(e, !0)
    }
    _completeLiteral(e) {
        let n = this._factory.literal(this._literalValue);
        switch (e.type) {
        case "type":
        case "typeIRI":
            const r = this._readEntity(e);
            if (r === void 0)
                return;
            n = this._factory.literal(this._literalValue, r),
            e = null;
            break;
        case "langcode":
            n = this._factory.literal(this._literalValue, e.value),
            e = null;
            break
        }
        return {
            token: e,
            literal: n
        }
    }
    _completeSubjectLiteral(e) {
        return this._subject = this._completeLiteral(e).literal,
        this._readPredicateOrNamedGraph
    }
    _completeObjectLiteral(e, n) {
        const r = this._completeLiteral(e);
        if (r)
            return this._object = r.literal,
            n && this._emit(this._subject, this.RDF_FIRST, this._object, this._graph),
            r.token === null ? this._getContextEndReader() : (this._readCallback = this._getContextEndReader(),
            this._readCallback(r.token))
    }
    _readFormulaTail(e) {
        return e.type !== "}" ? this._readPunctuation(e) : (this._subject !== null && this._emit(this._subject, this._predicate, this._object, this._graph),
        this._restoreContext("formula", e),
        this._object === null ? this._readPredicate : this._getContextEndReader())
    }
    _readPunctuation(e) {
        let n, r = this._graph;
        const o = this._subject
          , a = this._inversePredicate;
        switch (e.type) {
        case "}":
            if (this._graph === null)
                return this._error("Unexpected graph closing", e);
            if (this._n3Mode)
                return this._readFormulaTail(e);
            this._graph = null;
        case ".":
            this._subject = null,
            n = this._contextStack.length ? this._readSubject : this._readInTopContext,
            a && (this._inversePredicate = !1);
            break;
        case ";":
            n = this._readPredicate;
            break;
        case ",":
            n = this._readObject;
            break;
        case "{|":
            if (!this._supportsRDFStar)
                return this._error("Unexpected RDF-star syntax", e);
            const l = this._predicate
              , u = this._object;
            this._subject = this._factory.quad(o, l, u, this.DEFAULTGRAPH),
            n = this._readPredicate;
            break;
        case "|}":
            if (this._subject.termType !== "Quad")
                return this._error("Unexpected asserted triple closing", e);
            this._subject = null,
            n = this._readPunctuation;
            break;
        default:
            if (this._supportsQuads && this._graph === null && (r = this._readEntity(e)) !== void 0) {
                n = this._readQuadPunctuation;
                break
            }
            return this._error(`Expected punctuation to follow "${this._object.id}"`, e)
        }
        if (o !== null) {
            const l = this._predicate
              , u = this._object;
            a ? this._emit(u, l, o, r) : this._emit(o, l, u, r)
        }
        return n
    }
    _readBlankNodePunctuation(e) {
        let n;
        switch (e.type) {
        case ";":
            n = this._readPredicate;
            break;
        case ",":
            n = this._readObject;
            break;
        default:
            return this._error(`Expected punctuation to follow "${this._object.id}"`, e)
        }
        return this._emit(this._subject, this._predicate, this._object, this._graph),
        n
    }
    _readQuadPunctuation(e) {
        return e.type !== "." ? this._error("Expected dot to follow quad", e) : this._readInTopContext
    }
    _readPrefix(e) {
        return e.type !== "prefix" ? this._error("Expected prefix to follow @prefix", e) : (this._prefix = e.value,
        this._readPrefixIRI)
    }
    _readPrefixIRI(e) {
        if (e.type !== "IRI")
            return this._error(`Expected IRI to follow prefix "${this._prefix}:"`, e);
        const n = this._readEntity(e);
        return this._prefixes[this._prefix] = n.value,
        this._prefixCallback(this._prefix, n),
        this._readDeclarationPunctuation
    }
    _readBaseIRI(e) {
        const n = e.type === "IRI" && this._resolveIRI(e.value);
        return n ? (this._setBase(n),
        this._readDeclarationPunctuation) : this._error("Expected valid IRI to follow base declaration", e)
    }
    _readNamedGraphLabel(e) {
        switch (e.type) {
        case "IRI":
        case "blank":
        case "prefixed":
            return this._readSubject(e),
            this._readGraph;
        case "[":
            return this._readNamedGraphBlankLabel;
        default:
            return this._error("Invalid graph label", e)
        }
    }
    _readNamedGraphBlankLabel(e) {
        return e.type !== "]" ? this._error("Invalid graph label", e) : (this._subject = this._factory.blankNode(),
        this._readGraph)
    }
    _readDeclarationPunctuation(e) {
        return this._sparqlStyle ? (this._sparqlStyle = !1,
        this._readInTopContext(e)) : e.type !== "." ? this._error("Expected declaration to end with a dot", e) : this._readInTopContext
    }
    _readQuantifierList(e) {
        let n;
        switch (e.type) {
        case "IRI":
        case "prefixed":
            if ((n = this._readEntity(e, !0)) !== void 0)
                break;
        default:
            return this._error(`Unexpected ${e.type}`, e)
        }
        return this._explicitQuantifiers ? (this._subject === null ? this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._factory.blankNode(), this.QUANTIFIERS_GRAPH) : this._emit(this._subject, this.RDF_REST, this._subject = this._factory.blankNode(), this.QUANTIFIERS_GRAPH),
        this._emit(this._subject, this.RDF_FIRST, n, this.QUANTIFIERS_GRAPH)) : this._quantified[n.id] = this._factory[this._quantifier](this._factory.blankNode().value),
        this._readQuantifierPunctuation
    }
    _readQuantifierPunctuation(e) {
        return e.type === "," ? this._readQuantifierList : (this._explicitQuantifiers && (this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH),
        this._subject = null),
        this._readCallback = this._getContextEndReader(),
        this._readCallback(e))
    }
    _getPathReader(e) {
        return this._afterPath = e,
        this._readPath
    }
    _readPath(e) {
        switch (e.type) {
        case "!":
            return this._readForwardPath;
        case "^":
            return this._readBackwardPath;
        default:
            const n = this._contextStack
              , r = n.length && n[n.length - 1];
            if (r && r.type === "item") {
                const o = this._subject;
                this._restoreContext("item", e),
                this._emit(this._subject, this.RDF_FIRST, o, this._graph)
            }
            return this._afterPath(e)
        }
    }
    _readForwardPath(e) {
        let n, r;
        const o = this._factory.blankNode();
        if ((r = this._readEntity(e)) !== void 0)
            return this._predicate === null ? (n = this._subject,
            this._subject = o) : (n = this._object,
            this._object = o),
            this._emit(n, r, o, this._graph),
            this._readPath
    }
    _readBackwardPath(e) {
        const n = this._factory.blankNode();
        let r, o;
        if ((r = this._readEntity(e)) !== void 0)
            return this._predicate === null ? (o = this._subject,
            this._subject = n) : (o = this._object,
            this._object = n),
            this._emit(n, r, o, this._graph),
            this._readPath
    }
    _readRDFStarTailOrGraph(e) {
        return e.type !== ">>" ? this._supportsQuads && this._graph === null && (this._graph = this._readEntity(e)) !== void 0 ? this._readRDFStarTail : this._error(`Expected >> to follow "${this._object.id}"`, e) : this._readRDFStarTail(e)
    }
    _readRDFStarTail(e) {
        if (e.type !== ">>")
            return this._error(`Expected >> but got ${e.type}`, e);
        const n = this._factory.quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);
        return this._restoreContext("<<", e),
        this._subject === null ? (this._subject = n,
        this._readPredicate) : (this._object = n,
        this._getContextEndReader())
    }
    _getContextEndReader() {
        const e = this._contextStack;
        if (!e.length)
            return this._readPunctuation;
        switch (e[e.length - 1].type) {
        case "blank":
            return this._readBlankNodeTail;
        case "list":
            return this._readListItem;
        case "formula":
            return this._readFormulaTail;
        case "<<":
            return this._readRDFStarTailOrGraph
        }
    }
    _emit(e, n, r, o) {
        this._callback(null, this._factory.quad(e, n, r, o || this.DEFAULTGRAPH))
    }
    _error(e, n) {
        const r = new Error(`${e} on line ${n.line}.`);
        r.context = {
            token: n,
            line: n.line,
            previousToken: this._lexer.previousToken
        },
        this._callback(r),
        this._callback = gs
    }
    _resolveIRI(e) {
        return /^[a-z][a-z0-9+.-]*:/i.test(e) ? e : this._resolveRelativeIRI(e)
    }
    _resolveRelativeIRI(e) {
        if (!e.length)
            return this._base;
        switch (e[0]) {
        case "#":
            return this._base + e;
        case "?":
            return this._base.replace(/(?:\?.*)?$/, e);
        case "/":
            return (e[1] === "/" ? this._baseScheme : this._baseRoot) + this._removeDotSegments(e);
        default:
            return /^[^/:]*:/.test(e) ? null : this._removeDotSegments(this._basePath + e)
        }
    }
    _removeDotSegments(e) {
        if (!/(^|\/)\.\.?($|[/#?])/.test(e))
            return e;
        const n = e.length;
        let r = ""
          , o = -1
          , a = -1
          , l = 0
          , u = "/";
        for (; o < n; ) {
            switch (u) {
            case ":":
                if (a < 0 && e[++o] === "/" && e[++o] === "/")
                    for (; (a = o + 1) < n && e[a] !== "/"; )
                        o = a;
                break;
            case "?":
            case "#":
                o = n;
                break;
            case "/":
                if (e[o + 1] === ".")
                    switch (u = e[++o + 1],
                    u) {
                    case "/":
                        r += e.substring(l, o - 1),
                        l = o + 1;
                        break;
                    case void 0:
                    case "?":
                    case "#":
                        return r + e.substring(l, o) + e.substr(o + 1);
                    case ".":
                        if (u = e[++o + 1],
                        u === void 0 || u === "/" || u === "?" || u === "#") {
                            if (r += e.substring(l, o - 2),
                            (l = r.lastIndexOf("/")) >= a && (r = r.substr(0, l)),
                            u !== "/")
                                return `${r}/${e.substr(o + 1)}`;
                            l = o + 1
                        }
                    }
            }
            u = e[++o]
        }
        return r + e.substring(l)
    }
    parse(e, n, r) {
        let o, a, l;
        if (n && (n.onQuad || n.onPrefix || n.onComment) ? (o = n.onQuad,
        a = n.onPrefix,
        l = n.onComment) : (o = n,
        a = r),
        this._readCallback = this._readInTopContext,
        this._sparqlStyle = !1,
        this._prefixes = Object.create(null),
        this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b ${nc++}_`,
        this._prefixCallback = a || gs,
        this._inversePredicate = !1,
        this._quantified = Object.create(null),
        !o) {
            const f = [];
            let h;
            if (this._callback = (m,_)=>{
                m ? h = m : _ && f.push(_)
            }
            ,
            this._lexer.tokenize(e).every(m=>this._readCallback = this._readCallback(m)),
            h)
                throw h;
            return f
        }
        let u = (f,h)=>{
            f !== null ? (this._callback(f),
            this._callback = gs) : this._readCallback && (this._readCallback = this._readCallback(h))
        }
        ;
        l && (this._lexer.comments = !0,
        u = (f,h)=>{
            f !== null ? (this._callback(f),
            this._callback = gs) : this._readCallback && (h.type === "comment" ? l(h.value) : this._readCallback = this._readCallback(h))
        }
        ),
        this._callback = o,
        this._lexer.tokenize(e, u)
    }
}
function gs() {}
function uf(i, e) {
    i._factory = e,
    i.DEFAULTGRAPH = e.defaultGraph(),
    i.RDF_FIRST = e.namedNode(Lt.rdf.first),
    i.RDF_REST = e.namedNode(Lt.rdf.rest),
    i.RDF_NIL = e.namedNode(Lt.rdf.nil),
    i.N3_FORALL = e.namedNode(Lt.r.forAll),
    i.N3_FORSOME = e.namedNode(Lt.r.forSome),
    i.ABBREVIATIONS = {
        a: e.namedNode(Lt.rdf.type),
        "=": e.namedNode(Lt.owl.sameAs),
        ">": e.namedNode(Lt.log.implies),
        "<": e.namedNode(Lt.log.isImpliedBy)
    },
    i.QUANTIFIERS_GRAPH = e.namedNode("urn:n3:quantifiers")
}
uf(lf.prototype, ze);
function vl(i) {
    return !!i && i.termType === "DefaultGraph"
}
function Ss(i) {
    return i.replace(/[\]\/\(\)\*\+\?\.\\\$]/g, "\\$&")
}
const Cg = /^:?[^:?#]*(?:[?#]|$)|^file:|^[^:]*:\/*[^?#]+?\/(?:\.\.?(?:\/|$)|\/)/i
  , kg = /^(?:(?:[^/?#]{3,}|\.?[^/?#.]\.?)(?:\/[^/?#]{3,}|\.?[^/?#.]\.?)*\/?)?(?:[?#]|$)/
  , ic = "./"
  , Pg = "../"
  , ko = "?"
  , rc = "#";
class Rl {
    constructor(e) {
        this.base = e,
        this._baseLength = 0,
        this._baseMatcher = null,
        this._pathReplacements = new Array(e.length + 1)
    }
    static supports(e) {
        return !Cg.test(e)
    }
    _getBaseMatcher() {
        if (this._baseMatcher)
            return this._baseMatcher;
        if (!Rl.supports(this.base))
            return this._baseMatcher = /.^/;
        const e = /^[^:]*:\/*/.exec(this.base)[0]
          , n = ["^", Ss(e)]
          , r = []
          , o = []
          , a = /[^/?#]*([/?#])/y;
        let l, u = 0, f = 0, h = a.lastIndex = e.length;
        for (; !u && !f && (l = a.exec(this.base)); )
            l[1] === rc ? f = a.lastIndex - 1 : (n.push(Ss(l[0]), "(?:"),
            r.push(")?"),
            l[1] !== ko ? o.push(h = a.lastIndex) : (u = h = a.lastIndex,
            f = this.base.indexOf(rc, u),
            this._pathReplacements[u] = ko));
        for (let m = 0; m < o.length; m++)
            this._pathReplacements[o[m]] = Pg.repeat(o.length - m - 1);
        return this._pathReplacements[o[o.length - 1]] = ic,
        this._baseLength = f > 0 ? f : this.base.length,
        n.push(Ss(this.base.substring(h, this._baseLength)), u ? "(?:#|$)" : "(?:[?#]|$)"),
        this._baseMatcher = new RegExp([...n, ...r].join(""))
    }
    toRelative(e) {
        const n = this._getBaseMatcher().exec(e);
        if (!n)
            return e;
        const r = n[0].length;
        if (r === this._baseLength && r === e.length)
            return "";
        const o = this._pathReplacements[r];
        if (o) {
            const a = e.substring(r);
            return o !== ko && !kg.test(a) ? e : o === ic && /^[^?#]/.test(a) ? a : o + a
        }
        return e.substring(r - 1)
    }
}
const hr = ze.defaultGraph()
  , {rdf: Mg, xsd: Pi} = Lt
  , sc = /["\\\t\n\r\b\f\u0000-\u0019\ud800-\udbff]/
  , oc = /["\\\t\n\r\b\f\u0000-\u0019]|[\ud800-\udbff][\udc00-\udfff]/g
  , Dg = {
    "\\": "\\\\",
    '"': '\\"',
    "	": "\\t",
    "\n": "\\n",
    "\r": "\\r",
    "\b": "\\b",
    "\f": "\\f"
};
class fr extends an {
    equals(e) {
        return e === this
    }
}
class Cl {
    constructor(e, n) {
        if (this._prefixRegex = /$0^/,
        e && typeof e.write != "function" && (n = e,
        e = null),
        n = n || {},
        this._lists = n.lists,
        e)
            this._outputStream = e,
            this._endStream = n.end === void 0 ? !0 : !!n.end;
        else {
            let r = "";
            this._outputStream = {
                write(o, a, l) {
                    r += o,
                    l && l()
                },
                end: o=>{
                    o && o(null, r)
                }
            },
            this._endStream = !0
        }
        this._subject = null,
        /triple|quad/i.test(n.format) ? (this._lineMode = !0,
        this._writeQuad = this._writeQuadLine) : (this._lineMode = !1,
        this._graph = hr,
        this._prefixIRIs = Object.create(null),
        n.prefixes && this.addPrefixes(n.prefixes),
        n.baseIRI && (this._baseIri = new Rl(n.baseIRI)))
    }
    get _inDefaultGraph() {
        return hr.equals(this._graph)
    }
    _write(e, n) {
        this._outputStream.write(e, "utf8", n)
    }
    _writeQuad(e, n, r, o, a) {
        try {
            o.equals(this._graph) || (this._write((this._subject === null ? "" : this._inDefaultGraph ? `.
` : `
}
`) + (hr.equals(o) ? "" : `${this._encodeIriOrBlank(o)} {
`)),
            this._graph = o,
            this._subject = null),
            e.equals(this._subject) ? n.equals(this._predicate) ? this._write(`, ${this._encodeObject(r)}`, a) : this._write(`;
    ${this._encodePredicate(this._predicate = n)} ${this._encodeObject(r)}`, a) : this._write(`${(this._subject === null ? "" : `.
`) + this._encodeSubject(this._subject = e)} ${this._encodePredicate(this._predicate = n)} ${this._encodeObject(r)}`, a)
        } catch (l) {
            a && a(l)
        }
    }
    _writeQuadLine(e, n, r, o, a) {
        delete this._prefixMatch,
        this._write(this.quadToString(e, n, r, o), a)
    }
    quadToString(e, n, r, o) {
        return `${this._encodeSubject(e)} ${this._encodeIriOrBlank(n)} ${this._encodeObject(r)}${o && o.value ? ` ${this._encodeIriOrBlank(o)} .
` : ` .
`}`
    }
    quadsToString(e) {
        let n = "";
        for (const r of e)
            n += this.quadToString(r.subject, r.predicate, r.object, r.graph);
        return n
    }
    _encodeSubject(e) {
        return e.termType === "Quad" ? this._encodeQuad(e) : this._encodeIriOrBlank(e)
    }
    _encodeIriOrBlank(e) {
        if (e.termType !== "NamedNode")
            return this._lists && e.value in this._lists && (e = this.list(this._lists[e.value])),
            "id"in e ? e.id : `_:${e.value}`;
        let n = e.value;
        this._baseIri && (n = this._baseIri.toRelative(n)),
        sc.test(n) && (n = n.replace(oc, ac));
        const r = this._prefixRegex.exec(n);
        return r ? r[1] ? this._prefixIRIs[r[1]] + r[2] : n : `<${n}>`
    }
    _encodeLiteral(e) {
        let n = e.value;
        if (sc.test(n) && (n = n.replace(oc, ac)),
        e.language)
            return `"${n}"@${e.language}`;
        if (this._lineMode) {
            if (e.datatype.value === Pi.string)
                return `"${n}"`
        } else
            switch (e.datatype.value) {
            case Pi.string:
                return `"${n}"`;
            case Pi.boolean:
                if (n === "true" || n === "false")
                    return n;
                break;
            case Pi.integer:
                if (/^[+-]?\d+$/.test(n))
                    return n;
                break;
            case Pi.decimal:
                if (/^[+-]?\d*\.\d+$/.test(n))
                    return n;
                break;
            case Pi.double:
                if (/^[+-]?(?:\d+\.\d*|\.?\d+)[eE][+-]?\d+$/.test(n))
                    return n;
                break
            }
        return `"${n}"^^${this._encodeIriOrBlank(e.datatype)}`
    }
    _encodePredicate(e) {
        return e.value === Mg.type ? "a" : this._encodeIriOrBlank(e)
    }
    _encodeObject(e) {
        switch (e.termType) {
        case "Quad":
            return this._encodeQuad(e);
        case "Literal":
            return this._encodeLiteral(e);
        default:
            return this._encodeIriOrBlank(e)
        }
    }
    _encodeQuad({subject: e, predicate: n, object: r, graph: o}) {
        return `<<${this._encodeSubject(e)} ${this._encodePredicate(n)} ${this._encodeObject(r)}${vl(o) ? "" : ` ${this._encodeIriOrBlank(o)}`}>>`
    }
    _blockedWrite() {
        throw new Error("Cannot write because the writer has been closed.")
    }
    addQuad(e, n, r, o, a) {
        r === void 0 ? this._writeQuad(e.subject, e.predicate, e.object, e.graph, n) : typeof o == "function" ? this._writeQuad(e, n, r, hr, o) : this._writeQuad(e, n, r, o || hr, a)
    }
    addQuads(e) {
        for (let n = 0; n < e.length; n++)
            this.addQuad(e[n])
    }
    addPrefix(e, n, r) {
        const o = {};
        o[e] = n,
        this.addPrefixes(o, r)
    }
    addPrefixes(e, n) {
        if (!this._prefixIRIs)
            return n && n();
        let r = !1;
        for (let o in e) {
            let a = e[o];
            typeof a != "string" && (a = a.value),
            r = !0,
            this._subject !== null && (this._write(this._inDefaultGraph ? `.
` : `
}
`),
            this._subject = null,
            this._graph = ""),
            this._prefixIRIs[a] = o += ":",
            this._write(`@prefix ${o} <${a}>.
`)
        }
        if (r) {
            let o = ""
              , a = "";
            for (const l in this._prefixIRIs)
                o += o ? `|${l}` : l,
                a += (a ? "|" : "") + this._prefixIRIs[l];
            o = Ss(o),
            this._prefixRegex = new RegExp(`^(?:${a})[^/]*$|^(${o})([_a-zA-Z0-9][\\-_a-zA-Z0-9]*)$`)
        }
        this._write(r ? `
` : "", n)
    }
    blank(e, n) {
        let r = e, o, a;
        switch (e === void 0 ? r = [] : e.termType ? r = [{
            predicate: e,
            object: n
        }] : "length"in e || (r = [e]),
        a = r.length) {
        case 0:
            return new fr("[]");
        case 1:
            if (o = r[0],
            !(o.object instanceof fr))
                return new fr(`[ ${this._encodePredicate(o.predicate)} ${this._encodeObject(o.object)} ]`);
        default:
            let l = "[";
            for (let u = 0; u < a; u++)
                o = r[u],
                o.predicate.equals(e) ? l += `, ${this._encodeObject(o.object)}` : (l += `${(u ? `;
  ` : `
  `) + this._encodePredicate(o.predicate)} ${this._encodeObject(o.object)}`,
                e = o.predicate);
            return new fr(`${l}
]`)
        }
    }
    list(e) {
        const n = e && e.length || 0
          , r = new Array(n);
        for (let o = 0; o < n; o++)
            r[o] = this._encodeObject(e[o]);
        return new fr(`(${r.join(" ")})`)
    }
    end(e) {
        this._subject !== null && (this._write(this._inDefaultGraph ? `.
` : `
}
`),
        this._subject = null),
        this._write = this._blockedWrite;
        let n = e && ((r,o)=>{
            n = null,
            e(r, o)
        }
        );
        if (this._endStream)
            try {
                return this._outputStream.end(n)
            } catch {}
        n && n()
    }
}
function ac(i) {
    let e = Dg[i];
    return e === void 0 && (i.length === 1 ? (e = i.charCodeAt(0).toString(16),
    e = "\\u0000".substr(0, 6 - e.length) + e) : (e = ((i.charCodeAt(0) - 55296) * 1024 + i.charCodeAt(1) + 9216).toString(16),
    e = "\\U00000000".substr(0, 10 - e.length) + e)),
    e
}
var Po = {
    exports: {}
}, Mo = {
    exports: {}
}, Do, lc;
function ct() {
    if (lc)
        return Do;
    lc = 1;
    class i extends Error {
        constructor(n) {
            if (!Array.isArray(n))
                throw new TypeError(`Expected input to be an Array, got ${typeof n}`);
            let r = "";
            for (let o = 0; o < n.length; o++)
                r += `    ${n[o].stack}
`;
            super(r),
            this.name = "AggregateError",
            this.errors = n
        }
    }
    return Do = {
        AggregateError: i,
        ArrayIsArray(e) {
            return Array.isArray(e)
        },
        ArrayPrototypeIncludes(e, n) {
            return e.includes(n)
        },
        ArrayPrototypeIndexOf(e, n) {
            return e.indexOf(n)
        },
        ArrayPrototypeJoin(e, n) {
            return e.join(n)
        },
        ArrayPrototypeMap(e, n) {
            return e.map(n)
        },
        ArrayPrototypePop(e, n) {
            return e.pop(n)
        },
        ArrayPrototypePush(e, n) {
            return e.push(n)
        },
        ArrayPrototypeSlice(e, n, r) {
            return e.slice(n, r)
        },
        Error,
        FunctionPrototypeCall(e, n, ...r) {
            return e.call(n, ...r)
        },
        FunctionPrototypeSymbolHasInstance(e, n) {
            return Function.prototype[Symbol.hasInstance].call(e, n)
        },
        MathFloor: Math.floor,
        Number,
        NumberIsInteger: Number.isInteger,
        NumberIsNaN: Number.isNaN,
        NumberMAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER,
        NumberMIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER,
        NumberParseInt: Number.parseInt,
        ObjectDefineProperties(e, n) {
            return Object.defineProperties(e, n)
        },
        ObjectDefineProperty(e, n, r) {
            return Object.defineProperty(e, n, r)
        },
        ObjectGetOwnPropertyDescriptor(e, n) {
            return Object.getOwnPropertyDescriptor(e, n)
        },
        ObjectKeys(e) {
            return Object.keys(e)
        },
        ObjectSetPrototypeOf(e, n) {
            return Object.setPrototypeOf(e, n)
        },
        Promise,
        PromisePrototypeCatch(e, n) {
            return e.catch(n)
        },
        PromisePrototypeThen(e, n, r) {
            return e.then(n, r)
        },
        PromiseReject(e) {
            return Promise.reject(e)
        },
        PromiseResolve(e) {
            return Promise.resolve(e)
        },
        ReflectApply: Reflect.apply,
        RegExpPrototypeTest(e, n) {
            return e.test(n)
        },
        SafeSet: Set,
        String,
        StringPrototypeSlice(e, n, r) {
            return e.slice(n, r)
        },
        StringPrototypeToLowerCase(e) {
            return e.toLowerCase()
        },
        StringPrototypeToUpperCase(e) {
            return e.toUpperCase()
        },
        StringPrototypeTrim(e) {
            return e.trim()
        },
        Symbol,
        SymbolFor: Symbol.for,
        SymbolAsyncIterator: Symbol.asyncIterator,
        SymbolHasInstance: Symbol.hasInstance,
        SymbolIterator: Symbol.iterator,
        SymbolDispose: Symbol.dispose || Symbol("Symbol.dispose"),
        SymbolAsyncDispose: Symbol.asyncDispose || Symbol("Symbol.asyncDispose"),
        TypedArrayPrototypeSet(e, n, r) {
            return e.set(n, r)
        },
        Boolean,
        Uint8Array
    },
    Do
}
var Oo = {
    exports: {}
}, Fo, uc;
function cf() {
    return uc || (uc = 1,
    Fo = {
        format(i, ...e) {
            return i.replace(/%([sdifj])/g, function(...[n,r]) {
                const o = e.shift();
                return r === "f" ? o.toFixed(6) : r === "j" ? JSON.stringify(o) : r === "s" && typeof o == "object" ? `${o.constructor !== Object ? o.constructor.name : ""} {}`.trim() : o.toString()
            })
        },
        inspect(i) {
            switch (typeof i) {
            case "string":
                if (i.includes("'"))
                    if (i.includes('"')) {
                        if (!i.includes("`") && !i.includes("${"))
                            return `\`${i}\``
                    } else
                        return `"${i}"`;
                return `'${i}'`;
            case "number":
                return isNaN(i) ? "NaN" : Object.is(i, -0) ? String(i) : i;
            case "bigint":
                return `${String(i)}n`;
            case "boolean":
            case "undefined":
                return String(i);
            case "object":
                return "{}"
            }
        }
    }),
    Fo
}
var jo, cc;
function kt() {
    if (cc)
        return jo;
    cc = 1;
    const {format: i, inspect: e} = cf()
      , {AggregateError: n} = ct()
      , r = globalThis.AggregateError || n
      , o = Symbol("kIsNodeError")
      , a = ["string", "function", "number", "object", "Function", "Object", "boolean", "bigint", "symbol"]
      , l = /^([A-Z][a-z0-9]*)+$/
      , u = "__node_internal_"
      , f = {};
    function h(N, A) {
        if (!N)
            throw new f.ERR_INTERNAL_ASSERTION(A)
    }
    function m(N) {
        let A = ""
          , R = N.length;
        const S = N[0] === "-" ? 1 : 0;
        for (; R >= S + 4; R -= 3)
            A = `_ ${N.slice(R - 3, R)}${A}`;
        return `${N.slice(0, R)}${A}`
    }
    function _(N, A, R) {
        if (typeof A == "function")
            return h(A.length <= R.length, `Code: ${N}; The provided arguments length (${R.length}) does not match the required ones (${A.length}).`),
            A(...R);
        const S = (A.match(/%[dfijoOs]/g) || []).length;
        return h(S === R.length, `Code: ${N}; The provided arguments length (${R.length}) does not match the required ones (${S}).`),
        R.length === 0 ? A : i(A, ...R)
    }
    function d(N, A, R) {
        R || (R = Error);
        class S extends R {
            constructor(...x) {
                super(_(N, A, x))
            }
            toString() {
                return `${this.name} [${N}]: ${this.message}`
            }
        }
        Object.defineProperties(S.prototype, {
            name: {
                value: R.name,
                writable: !0,
                enumerable: !1,
                configurable: !0
            },
            toString: {
                value() {
                    return `${this.name} [${N}]: ${this.message}`
                },
                writable: !0,
                enumerable: !1,
                configurable: !0
            }
        }),
        S.prototype.code = N,
        S.prototype[o] = !0,
        f[N] = S
    }
    function g(N) {
        const A = u + N.name;
        return Object.defineProperty(N, "name", {
            value: A
        }),
        N
    }
    function b(N, A) {
        if (N && A && N !== A) {
            if (Array.isArray(A.errors))
                return A.errors.push(N),
                A;
            const R = new r([A, N],A.message);
            return R.code = A.code,
            R
        }
        return N || A
    }
    class T extends Error {
        constructor(A="The operation was aborted", R=void 0) {
            if (R !== void 0 && typeof R != "object")
                throw new f.ERR_INVALID_ARG_TYPE("options","Object",R);
            super(A, R),
            this.code = "ABORT_ERR",
            this.name = "AbortError"
        }
    }
    return d("ERR_ASSERTION", "%s", Error),
    d("ERR_INVALID_ARG_TYPE", (N,A,R)=>{
        h(typeof N == "string", "'name' must be a string"),
        Array.isArray(A) || (A = [A]);
        let S = "The ";
        N.endsWith(" argument") ? S += `${N} ` : S += `"${N}" ${N.includes(".") ? "property" : "argument"} `,
        S += "must be ";
        const y = []
          , x = []
          , M = [];
        for (const O of A)
            h(typeof O == "string", "All expected entries have to be of type string"),
            a.includes(O) ? y.push(O.toLowerCase()) : l.test(O) ? x.push(O) : (h(O !== "object", 'The value "object" should be written as "Object"'),
            M.push(O));
        if (x.length > 0) {
            const O = y.indexOf("object");
            O !== -1 && (y.splice(y, O, 1),
            x.push("Object"))
        }
        if (y.length > 0) {
            switch (y.length) {
            case 1:
                S += `of type ${y[0]}`;
                break;
            case 2:
                S += `one of type ${y[0]} or ${y[1]}`;
                break;
            default:
                {
                    const O = y.pop();
                    S += `one of type ${y.join(", ")}, or ${O}`
                }
            }
            (x.length > 0 || M.length > 0) && (S += " or ")
        }
        if (x.length > 0) {
            switch (x.length) {
            case 1:
                S += `an instance of ${x[0]}`;
                break;
            case 2:
                S += `an instance of ${x[0]} or ${x[1]}`;
                break;
            default:
                {
                    const O = x.pop();
                    S += `an instance of ${x.join(", ")}, or ${O}`
                }
            }
            M.length > 0 && (S += " or ")
        }
        switch (M.length) {
        case 0:
            break;
        case 1:
            M[0].toLowerCase() !== M[0] && (S += "an "),
            S += `${M[0]}`;
            break;
        case 2:
            S += `one of ${M[0]} or ${M[1]}`;
            break;
        default:
            {
                const O = M.pop();
                S += `one of ${M.join(", ")}, or ${O}`
            }
        }
        if (R == null)
            S += `. Received ${R}`;
        else if (typeof R == "function" && R.name)
            S += `. Received function ${R.name}`;
        else if (typeof R == "object") {
            var U;
            if ((U = R.constructor) !== null && U !== void 0 && U.name)
                S += `. Received an instance of ${R.constructor.name}`;
            else {
                const O = e(R, {
                    depth: -1
                });
                S += `. Received ${O}`
            }
        } else {
            let O = e(R, {
                colors: !1
            });
            O.length > 25 && (O = `${O.slice(0, 25)}...`),
            S += `. Received type ${typeof R} (${O})`
        }
        return S
    }
    , TypeError),
    d("ERR_INVALID_ARG_VALUE", (N,A,R="is invalid")=>{
        let S = e(A);
        return S.length > 128 && (S = S.slice(0, 128) + "..."),
        `The ${N.includes(".") ? "property" : "argument"} '${N}' ${R}. Received ${S}`
    }
    , TypeError),
    d("ERR_INVALID_RETURN_VALUE", (N,A,R)=>{
        var S;
        const y = R != null && (S = R.constructor) !== null && S !== void 0 && S.name ? `instance of ${R.constructor.name}` : `type ${typeof R}`;
        return `Expected ${N} to be returned from the "${A}" function but got ${y}.`
    }
    , TypeError),
    d("ERR_MISSING_ARGS", (...N)=>{
        h(N.length > 0, "At least one arg needs to be specified");
        let A;
        const R = N.length;
        switch (N = (Array.isArray(N) ? N : [N]).map(S=>`"${S}"`).join(" or "),
        R) {
        case 1:
            A += `The ${N[0]} argument`;
            break;
        case 2:
            A += `The ${N[0]} and ${N[1]} arguments`;
            break;
        default:
            {
                const S = N.pop();
                A += `The ${N.join(", ")}, and ${S} arguments`
            }
            break
        }
        return `${A} must be specified`
    }
    , TypeError),
    d("ERR_OUT_OF_RANGE", (N,A,R)=>{
        h(A, 'Missing "range" argument');
        let S;
        if (Number.isInteger(R) && Math.abs(R) > 2 ** 32)
            S = m(String(R));
        else if (typeof R == "bigint") {
            S = String(R);
            const y = BigInt(2) ** BigInt(32);
            (R > y || R < -y) && (S = m(S)),
            S += "n"
        } else
            S = e(R);
        return `The value of "${N}" is out of range. It must be ${A}. Received ${S}`
    }
    , RangeError),
    d("ERR_MULTIPLE_CALLBACK", "Callback called multiple times", Error),
    d("ERR_METHOD_NOT_IMPLEMENTED", "The %s method is not implemented", Error),
    d("ERR_STREAM_ALREADY_FINISHED", "Cannot call %s after a stream was finished", Error),
    d("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable", Error),
    d("ERR_STREAM_DESTROYED", "Cannot call %s after a stream was destroyed", Error),
    d("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError),
    d("ERR_STREAM_PREMATURE_CLOSE", "Premature close", Error),
    d("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF", Error),
    d("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event", Error),
    d("ERR_STREAM_WRITE_AFTER_END", "write after end", Error),
    d("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s", TypeError),
    jo = {
        AbortError: T,
        aggregateTwoErrors: g(b),
        hideStackFrames: g,
        codes: f
    },
    jo
}
var pr = {
    exports: {}
}, dc;
function Br() {
    if (dc)
        return pr.exports;
    dc = 1;
    const {AbortController: i, AbortSignal: e} = typeof self < "u" ? self : typeof window < "u" ? window : void 0;
    return pr.exports = i,
    pr.exports.AbortSignal = e,
    pr.exports.default = i,
    pr.exports
}
var ms = {
    exports: {}
}, hc;
function Hs() {
    if (hc)
        return ms.exports;
    hc = 1;
    var i = typeof Reflect == "object" ? Reflect : null, e = i && typeof i.apply == "function" ? i.apply : function(x, M, U) {
        return Function.prototype.apply.call(x, M, U)
    }
    , n;
    i && typeof i.ownKeys == "function" ? n = i.ownKeys : Object.getOwnPropertySymbols ? n = function(x) {
        return Object.getOwnPropertyNames(x).concat(Object.getOwnPropertySymbols(x))
    }
    : n = function(x) {
        return Object.getOwnPropertyNames(x)
    }
    ;
    function r(y) {
        console && console.warn && console.warn(y)
    }
    var o = Number.isNaN || function(x) {
        return x !== x
    }
    ;
    function a() {
        a.init.call(this)
    }
    ms.exports = a,
    ms.exports.once = A,
    a.EventEmitter = a,
    a.prototype._events = void 0,
    a.prototype._eventsCount = 0,
    a.prototype._maxListeners = void 0;
    var l = 10;
    function u(y) {
        if (typeof y != "function")
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof y)
    }
    Object.defineProperty(a, "defaultMaxListeners", {
        enumerable: !0,
        get: function() {
            return l
        },
        set: function(y) {
            if (typeof y != "number" || y < 0 || o(y))
                throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + y + ".");
            l = y
        }
    }),
    a.init = function() {
        (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = Object.create(null),
        this._eventsCount = 0),
        this._maxListeners = this._maxListeners || void 0
    }
    ,
    a.prototype.setMaxListeners = function(x) {
        if (typeof x != "number" || x < 0 || o(x))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + x + ".");
        return this._maxListeners = x,
        this
    }
    ;
    function f(y) {
        return y._maxListeners === void 0 ? a.defaultMaxListeners : y._maxListeners
    }
    a.prototype.getMaxListeners = function() {
        return f(this)
    }
    ,
    a.prototype.emit = function(x) {
        for (var M = [], U = 1; U < arguments.length; U++)
            M.push(arguments[U]);
        var O = x === "error"
          , Q = this._events;
        if (Q !== void 0)
            O = O && Q.error === void 0;
        else if (!O)
            return !1;
        if (O) {
            var D;
            if (M.length > 0 && (D = M[0]),
            D instanceof Error)
                throw D;
            var $ = new Error("Unhandled error." + (D ? " (" + D.message + ")" : ""));
            throw $.context = D,
            $
        }
        var X = Q[x];
        if (X === void 0)
            return !1;
        if (typeof X == "function")
            e(X, this, M);
        else
            for (var F = X.length, B = b(X, F), U = 0; U < F; ++U)
                e(B[U], this, M);
        return !0
    }
    ;
    function h(y, x, M, U) {
        var O, Q, D;
        if (u(M),
        Q = y._events,
        Q === void 0 ? (Q = y._events = Object.create(null),
        y._eventsCount = 0) : (Q.newListener !== void 0 && (y.emit("newListener", x, M.listener ? M.listener : M),
        Q = y._events),
        D = Q[x]),
        D === void 0)
            D = Q[x] = M,
            ++y._eventsCount;
        else if (typeof D == "function" ? D = Q[x] = U ? [M, D] : [D, M] : U ? D.unshift(M) : D.push(M),
        O = f(y),
        O > 0 && D.length > O && !D.warned) {
            D.warned = !0;
            var $ = new Error("Possible EventEmitter memory leak detected. " + D.length + " " + String(x) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            $.name = "MaxListenersExceededWarning",
            $.emitter = y,
            $.type = x,
            $.count = D.length,
            r($)
        }
        return y
    }
    a.prototype.addListener = function(x, M) {
        return h(this, x, M, !1)
    }
    ,
    a.prototype.on = a.prototype.addListener,
    a.prototype.prependListener = function(x, M) {
        return h(this, x, M, !0)
    }
    ;
    function m() {
        if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn),
            this.fired = !0,
            arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments)
    }
    function _(y, x, M) {
        var U = {
            fired: !1,
            wrapFn: void 0,
            target: y,
            type: x,
            listener: M
        }
          , O = m.bind(U);
        return O.listener = M,
        U.wrapFn = O,
        O
    }
    a.prototype.once = function(x, M) {
        return u(M),
        this.on(x, _(this, x, M)),
        this
    }
    ,
    a.prototype.prependOnceListener = function(x, M) {
        return u(M),
        this.prependListener(x, _(this, x, M)),
        this
    }
    ,
    a.prototype.removeListener = function(x, M) {
        var U, O, Q, D, $;
        if (u(M),
        O = this._events,
        O === void 0)
            return this;
        if (U = O[x],
        U === void 0)
            return this;
        if (U === M || U.listener === M)
            --this._eventsCount === 0 ? this._events = Object.create(null) : (delete O[x],
            O.removeListener && this.emit("removeListener", x, U.listener || M));
        else if (typeof U != "function") {
            for (Q = -1,
            D = U.length - 1; D >= 0; D--)
                if (U[D] === M || U[D].listener === M) {
                    $ = U[D].listener,
                    Q = D;
                    break
                }
            if (Q < 0)
                return this;
            Q === 0 ? U.shift() : T(U, Q),
            U.length === 1 && (O[x] = U[0]),
            O.removeListener !== void 0 && this.emit("removeListener", x, $ || M)
        }
        return this
    }
    ,
    a.prototype.off = a.prototype.removeListener,
    a.prototype.removeAllListeners = function(x) {
        var M, U, O;
        if (U = this._events,
        U === void 0)
            return this;
        if (U.removeListener === void 0)
            return arguments.length === 0 ? (this._events = Object.create(null),
            this._eventsCount = 0) : U[x] !== void 0 && (--this._eventsCount === 0 ? this._events = Object.create(null) : delete U[x]),
            this;
        if (arguments.length === 0) {
            var Q = Object.keys(U), D;
            for (O = 0; O < Q.length; ++O)
                D = Q[O],
                D !== "removeListener" && this.removeAllListeners(D);
            return this.removeAllListeners("removeListener"),
            this._events = Object.create(null),
            this._eventsCount = 0,
            this
        }
        if (M = U[x],
        typeof M == "function")
            this.removeListener(x, M);
        else if (M !== void 0)
            for (O = M.length - 1; O >= 0; O--)
                this.removeListener(x, M[O]);
        return this
    }
    ;
    function d(y, x, M) {
        var U = y._events;
        if (U === void 0)
            return [];
        var O = U[x];
        return O === void 0 ? [] : typeof O == "function" ? M ? [O.listener || O] : [O] : M ? N(O) : b(O, O.length)
    }
    a.prototype.listeners = function(x) {
        return d(this, x, !0)
    }
    ,
    a.prototype.rawListeners = function(x) {
        return d(this, x, !1)
    }
    ,
    a.listenerCount = function(y, x) {
        return typeof y.listenerCount == "function" ? y.listenerCount(x) : g.call(y, x)
    }
    ,
    a.prototype.listenerCount = g;
    function g(y) {
        var x = this._events;
        if (x !== void 0) {
            var M = x[y];
            if (typeof M == "function")
                return 1;
            if (M !== void 0)
                return M.length
        }
        return 0
    }
    a.prototype.eventNames = function() {
        return this._eventsCount > 0 ? n(this._events) : []
    }
    ;
    function b(y, x) {
        for (var M = new Array(x), U = 0; U < x; ++U)
            M[U] = y[U];
        return M
    }
    function T(y, x) {
        for (; x + 1 < y.length; x++)
            y[x] = y[x + 1];
        y.pop()
    }
    function N(y) {
        for (var x = new Array(y.length), M = 0; M < x.length; ++M)
            x[M] = y[M].listener || y[M];
        return x
    }
    function A(y, x) {
        return new Promise(function(M, U) {
            function O(D) {
                y.removeListener(x, Q),
                U(D)
            }
            function Q() {
                typeof y.removeListener == "function" && y.removeListener("error", O),
                M([].slice.call(arguments))
            }
            S(y, x, Q, {
                once: !0
            }),
            x !== "error" && R(y, O, {
                once: !0
            })
        }
        )
    }
    function R(y, x, M) {
        typeof y.on == "function" && S(y, "error", x, M)
    }
    function S(y, x, M, U) {
        if (typeof y.on == "function")
            U.once ? y.once(x, M) : y.on(x, M);
        else if (typeof y.addEventListener == "function")
            y.addEventListener(x, function O(Q) {
                U.once && y.removeEventListener(x, O),
                M(Q)
            });
        else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof y)
    }
    return ms.exports
}
var fc;
function Ot() {
    return fc || (fc = 1,
    (function(i) {
        const e = Rn()
          , {format: n, inspect: r} = cf()
          , {codes: {ERR_INVALID_ARG_TYPE: o}} = kt()
          , {kResistStopPropagation: a, AggregateError: l, SymbolDispose: u} = ct()
          , f = globalThis.AbortSignal || Br().AbortSignal
          , h = globalThis.AbortController || Br().AbortController
          , m = Object.getPrototypeOf(async function() {}).constructor
          , _ = globalThis.Blob || e.Blob
          , d = typeof _ < "u" ? function(N) {
            return N instanceof _
        }
        : function(N) {
            return !1
        }
          , g = (T,N)=>{
            if (T !== void 0 && (T === null || typeof T != "object" || !("aborted"in T)))
                throw new o(N,"AbortSignal",T)
        }
          , b = (T,N)=>{
            if (typeof T != "function")
                throw new o(N,"Function",T)
        }
        ;
        i.exports = {
            AggregateError: l,
            kEmptyObject: Object.freeze({}),
            once(T) {
                let N = !1;
                return function(...A) {
                    N || (N = !0,
                    T.apply(this, A))
                }
            },
            createDeferredPromise: function() {
                let T, N;
                return {
                    promise: new Promise((R,S)=>{
                        T = R,
                        N = S
                    }
                    ),
                    resolve: T,
                    reject: N
                }
            },
            promisify(T) {
                return new Promise((N,A)=>{
                    T((R,...S)=>R ? A(R) : N(...S))
                }
                )
            },
            debuglog() {
                return function() {}
            },
            format: n,
            inspect: r,
            types: {
                isAsyncFunction(T) {
                    return T instanceof m
                },
                isArrayBufferView(T) {
                    return ArrayBuffer.isView(T)
                }
            },
            isBlob: d,
            deprecate(T, N) {
                return T
            },
            addAbortListener: Hs().addAbortListener || function(N, A) {
                if (N === void 0)
                    throw new o("signal","AbortSignal",N);
                g(N, "signal"),
                b(A, "listener");
                let R;
                return N.aborted ? queueMicrotask(()=>A()) : (N.addEventListener("abort", A, {
                    __proto__: null,
                    once: !0,
                    [a]: !0
                }),
                R = ()=>{
                    N.removeEventListener("abort", A)
                }
                ),
                {
                    __proto__: null,
                    [u]() {
                        var S;
                        (S = R) === null || S === void 0 || S()
                    }
                }
            }
            ,
            AbortSignalAny: f.any || function(N) {
                if (N.length === 1)
                    return N[0];
                const A = new h
                  , R = ()=>A.abort();
                return N.forEach(S=>{
                    g(S, "signals"),
                    S.addEventListener("abort", R, {
                        once: !0
                    })
                }
                ),
                A.signal.addEventListener("abort", ()=>{
                    N.forEach(S=>S.removeEventListener("abort", R))
                }
                , {
                    once: !0
                }),
                A.signal
            }
        },
        i.exports.promisify.custom = Symbol.for("nodejs.util.promisify.custom")
    }
    )(Oo)),
    Oo.exports
}
var _s = {}, Bo, pc;
function Vr() {
    if (pc)
        return Bo;
    pc = 1;
    const {ArrayIsArray: i, ArrayPrototypeIncludes: e, ArrayPrototypeJoin: n, ArrayPrototypeMap: r, NumberIsInteger: o, NumberIsNaN: a, NumberMAX_SAFE_INTEGER: l, NumberMIN_SAFE_INTEGER: u, NumberParseInt: f, ObjectPrototypeHasOwnProperty: h, RegExpPrototypeExec: m, String: _, StringPrototypeToUpperCase: d, StringPrototypeTrim: g} = ct()
      , {hideStackFrames: b, codes: {ERR_SOCKET_BAD_PORT: T, ERR_INVALID_ARG_TYPE: N, ERR_INVALID_ARG_VALUE: A, ERR_OUT_OF_RANGE: R, ERR_UNKNOWN_SIGNAL: S}} = kt()
      , {normalizeEncoding: y} = Ot()
      , {isAsyncFunction: x, isArrayBufferView: M} = Ot().types
      , U = {};
    function O(se) {
        return se === (se | 0)
    }
    function Q(se) {
        return se === se >>> 0
    }
    const D = /^[0-7]+$/
      , $ = "must be a 32-bit unsigned integer or an octal string";
    function X(se, be, Ne) {
        if (typeof se > "u" && (se = Ne),
        typeof se == "string") {
            if (m(D, se) === null)
                throw new A(be,se,$);
            se = f(se, 8)
        }
        return ue(se, be),
        se
    }
    const F = b((se,be,Ne=u,ve=l)=>{
        if (typeof se != "number")
            throw new N(be,"number",se);
        if (!o(se))
            throw new R(be,"an integer",se);
        if (se < Ne || se > ve)
            throw new R(be,`>= ${Ne} && <= ${ve}`,se)
    }
    )
      , B = b((se,be,Ne=-2147483648,ve=2147483647)=>{
        if (typeof se != "number")
            throw new N(be,"number",se);
        if (!o(se))
            throw new R(be,"an integer",se);
        if (se < Ne || se > ve)
            throw new R(be,`>= ${Ne} && <= ${ve}`,se)
    }
    )
      , ue = b((se,be,Ne=!1)=>{
        if (typeof se != "number")
            throw new N(be,"number",se);
        if (!o(se))
            throw new R(be,"an integer",se);
        const ve = Ne ? 1 : 0
          , $e = 4294967295;
        if (se < ve || se > $e)
            throw new R(be,`>= ${ve} && <= ${$e}`,se)
    }
    );
    function P(se, be) {
        if (typeof se != "string")
            throw new N(be,"string",se)
    }
    function oe(se, be, Ne=void 0, ve) {
        if (typeof se != "number")
            throw new N(be,"number",se);
        if (Ne != null && se < Ne || ve != null && se > ve || (Ne != null || ve != null) && a(se))
            throw new R(be,`${Ne != null ? `>= ${Ne}` : ""}${Ne != null && ve != null ? " && " : ""}${ve != null ? `<= ${ve}` : ""}`,se)
    }
    const j = b((se,be,Ne)=>{
        if (!e(Ne, se)) {
            const $e = "must be one of: " + n(r(Ne, mt=>typeof mt == "string" ? `'${mt}'` : _(mt)), ", ");
            throw new A(be,se,$e)
        }
    }
    );
    function ae(se, be) {
        if (typeof se != "boolean")
            throw new N(be,"boolean",se)
    }
    function I(se, be, Ne) {
        return se == null || !h(se, be) ? Ne : se[be]
    }
    const Z = b((se,be,Ne=null)=>{
        const ve = I(Ne, "allowArray", !1)
          , $e = I(Ne, "allowFunction", !1);
        if (!I(Ne, "nullable", !1) && se === null || !ve && i(se) || typeof se != "object" && (!$e || typeof se != "function"))
            throw new N(be,"Object",se)
    }
    )
      , ie = b((se,be)=>{
        if (se != null && typeof se != "object" && typeof se != "function")
            throw new N(be,"a dictionary",se)
    }
    )
      , ee = b((se,be,Ne=0)=>{
        if (!i(se))
            throw new N(be,"Array",se);
        if (se.length < Ne) {
            const ve = `must be longer than ${Ne}`;
            throw new A(be,se,ve)
        }
    }
    );
    function me(se, be) {
        ee(se, be);
        for (let Ne = 0; Ne < se.length; Ne++)
            P(se[Ne], `${be}[${Ne}]`)
    }
    function W(se, be) {
        ee(se, be);
        for (let Ne = 0; Ne < se.length; Ne++)
            ae(se[Ne], `${be}[${Ne}]`)
    }
    function G(se, be) {
        ee(se, be);
        for (let Ne = 0; Ne < se.length; Ne++) {
            const ve = se[Ne]
              , $e = `${be}[${Ne}]`;
            if (ve == null)
                throw new N($e,"AbortSignal",ve);
            Ee(ve, $e)
        }
    }
    function Y(se, be="signal") {
        if (P(se, be),
        U[se] === void 0)
            throw U[d(se)] !== void 0 ? new S(se + " (signals must use all capital letters)") : new S(se)
    }
    const K = b((se,be="buffer")=>{
        if (!M(se))
            throw new N(be,["Buffer", "TypedArray", "DataView"],se)
    }
    );
    function le(se, be) {
        const Ne = y(be)
          , ve = se.length;
        if (Ne === "hex" && ve % 2 !== 0)
            throw new A("encoding",be,`is invalid for data of length ${ve}`)
    }
    function ce(se, be="Port", Ne=!0) {
        if (typeof se != "number" && typeof se != "string" || typeof se == "string" && g(se).length === 0 || +se !== +se >>> 0 || se > 65535 || se === 0 && !Ne)
            throw new T(be,se,Ne);
        return se | 0
    }
    const Ee = b((se,be)=>{
        if (se !== void 0 && (se === null || typeof se != "object" || !("aborted"in se)))
            throw new N(be,"AbortSignal",se)
    }
    )
      , Te = b((se,be)=>{
        if (typeof se != "function")
            throw new N(be,"Function",se)
    }
    )
      , q = b((se,be)=>{
        if (typeof se != "function" || x(se))
            throw new N(be,"Function",se)
    }
    )
      , te = b((se,be)=>{
        if (se !== void 0)
            throw new N(be,"undefined",se)
    }
    );
    function fe(se, be, Ne) {
        if (!e(Ne, se))
            throw new N(be,`('${n(Ne, "|")}')`,se)
    }
    const xe = /^(?:<[^>]*>)(?:\s*;\s*[^;"\s]+(?:=(")?[^;"\s]*\1)?)*$/;
    function Se(se, be) {
        if (typeof se > "u" || !m(xe, se))
            throw new A(be,se,'must be an array or string of format "</styles.css>; rel=preload; as=style"')
    }
    function Ie(se) {
        if (typeof se == "string")
            return Se(se, "hints"),
            se;
        if (i(se)) {
            const be = se.length;
            let Ne = "";
            if (be === 0)
                return Ne;
            for (let ve = 0; ve < be; ve++) {
                const $e = se[ve];
                Se($e, "hints"),
                Ne += $e,
                ve !== be - 1 && (Ne += ", ")
            }
            return Ne
        }
        throw new A("hints",se,'must be an array or string of format "</styles.css>; rel=preload; as=style"')
    }
    return Bo = {
        isInt32: O,
        isUint32: Q,
        parseFileMode: X,
        validateArray: ee,
        validateStringArray: me,
        validateBooleanArray: W,
        validateAbortSignalArray: G,
        validateBoolean: ae,
        validateBuffer: K,
        validateDictionary: ie,
        validateEncoding: le,
        validateFunction: Te,
        validateInt32: B,
        validateInteger: F,
        validateNumber: oe,
        validateObject: Z,
        validateOneOf: j,
        validatePlainFunction: q,
        validatePort: ce,
        validateSignalName: Y,
        validateString: P,
        validateUint32: ue,
        validateUndefined: te,
        validateUnion: fe,
        validateAbortSignal: Ee,
        validateLinkHeaderValue: Ie
    },
    Bo
}
var ys = {
    exports: {}
}, $o = {
    exports: {}
}, gc;
function xi() {
    if (gc)
        return $o.exports;
    gc = 1;
    var i = $o.exports = {}, e, n;
    function r() {
        throw new Error("setTimeout has not been defined")
    }
    function o() {
        throw new Error("clearTimeout has not been defined")
    }
    (function() {
        try {
            typeof setTimeout == "function" ? e = setTimeout : e = r
        } catch {
            e = r
        }
        try {
            typeof clearTimeout == "function" ? n = clearTimeout : n = o
        } catch {
            n = o
        }
    }
    )();
    function a(T) {
        if (e === setTimeout)
            return setTimeout(T, 0);
        if ((e === r || !e) && setTimeout)
            return e = setTimeout,
            setTimeout(T, 0);
        try {
            return e(T, 0)
        } catch {
            try {
                return e.call(null, T, 0)
            } catch {
                return e.call(this, T, 0)
            }
        }
    }
    function l(T) {
        if (n === clearTimeout)
            return clearTimeout(T);
        if ((n === o || !n) && clearTimeout)
            return n = clearTimeout,
            clearTimeout(T);
        try {
            return n(T)
        } catch {
            try {
                return n.call(null, T)
            } catch {
                return n.call(this, T)
            }
        }
    }
    var u = [], f = !1, h, m = -1;
    function _() {
        !f || !h || (f = !1,
        h.length ? u = h.concat(u) : m = -1,
        u.length && d())
    }
    function d() {
        if (!f) {
            var T = a(_);
            f = !0;
            for (var N = u.length; N; ) {
                for (h = u,
                u = []; ++m < N; )
                    h && h[m].run();
                m = -1,
                N = u.length
            }
            h = null,
            f = !1,
            l(T)
        }
    }
    i.nextTick = function(T) {
        var N = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var A = 1; A < arguments.length; A++)
                N[A - 1] = arguments[A];
        u.push(new g(T,N)),
        u.length === 1 && !f && a(d)
    }
    ;
    function g(T, N) {
        this.fun = T,
        this.array = N
    }
    g.prototype.run = function() {
        this.fun.apply(null, this.array)
    }
    ,
    i.title = "browser",
    i.browser = !0,
    i.env = {},
    i.argv = [],
    i.version = "",
    i.versions = {};
    function b() {}
    return i.on = b,
    i.addListener = b,
    i.once = b,
    i.off = b,
    i.removeListener = b,
    i.removeAllListeners = b,
    i.emit = b,
    i.prependListener = b,
    i.prependOnceListener = b,
    i.listeners = function(T) {
        return []
    }
    ,
    i.binding = function(T) {
        throw new Error("process.binding is not supported")
    }
    ,
    i.cwd = function() {
        return "/"
    }
    ,
    i.chdir = function(T) {
        throw new Error("process.chdir is not supported")
    }
    ,
    i.umask = function() {
        return 0
    }
    ,
    $o.exports
}
var qo, mc;
function Cn() {
    if (mc)
        return qo;
    mc = 1;
    const {SymbolAsyncIterator: i, SymbolIterator: e, SymbolFor: n} = ct()
      , r = n("nodejs.stream.destroyed")
      , o = n("nodejs.stream.errored")
      , a = n("nodejs.stream.readable")
      , l = n("nodejs.stream.writable")
      , u = n("nodejs.stream.disturbed")
      , f = n("nodejs.webstream.isClosedPromise")
      , h = n("nodejs.webstream.controllerErrorFunction");
    function m(I, Z=!1) {
        var ie;
        return !!(I && typeof I.pipe == "function" && typeof I.on == "function" && (!Z || typeof I.pause == "function" && typeof I.resume == "function") && (!I._writableState || ((ie = I._readableState) === null || ie === void 0 ? void 0 : ie.readable) !== !1) && (!I._writableState || I._readableState))
    }
    function _(I) {
        var Z;
        return !!(I && typeof I.write == "function" && typeof I.on == "function" && (!I._readableState || ((Z = I._writableState) === null || Z === void 0 ? void 0 : Z.writable) !== !1))
    }
    function d(I) {
        return !!(I && typeof I.pipe == "function" && I._readableState && typeof I.on == "function" && typeof I.write == "function")
    }
    function g(I) {
        return I && (I._readableState || I._writableState || typeof I.write == "function" && typeof I.on == "function" || typeof I.pipe == "function" && typeof I.on == "function")
    }
    function b(I) {
        return !!(I && !g(I) && typeof I.pipeThrough == "function" && typeof I.getReader == "function" && typeof I.cancel == "function")
    }
    function T(I) {
        return !!(I && !g(I) && typeof I.getWriter == "function" && typeof I.abort == "function")
    }
    function N(I) {
        return !!(I && !g(I) && typeof I.readable == "object" && typeof I.writable == "object")
    }
    function A(I) {
        return b(I) || T(I) || N(I)
    }
    function R(I, Z) {
        return I == null ? !1 : Z === !0 ? typeof I[i] == "function" : Z === !1 ? typeof I[e] == "function" : typeof I[i] == "function" || typeof I[e] == "function"
    }
    function S(I) {
        if (!g(I))
            return null;
        const Z = I._writableState
          , ie = I._readableState
          , ee = Z || ie;
        return !!(I.destroyed || I[r] || ee != null && ee.destroyed)
    }
    function y(I) {
        if (!_(I))
            return null;
        if (I.writableEnded === !0)
            return !0;
        const Z = I._writableState;
        return Z != null && Z.errored ? !1 : typeof Z?.ended != "boolean" ? null : Z.ended
    }
    function x(I, Z) {
        if (!_(I))
            return null;
        if (I.writableFinished === !0)
            return !0;
        const ie = I._writableState;
        return ie != null && ie.errored ? !1 : typeof ie?.finished != "boolean" ? null : !!(ie.finished || Z === !1 && ie.ended === !0 && ie.length === 0)
    }
    function M(I) {
        if (!m(I))
            return null;
        if (I.readableEnded === !0)
            return !0;
        const Z = I._readableState;
        return !Z || Z.errored ? !1 : typeof Z?.ended != "boolean" ? null : Z.ended
    }
    function U(I, Z) {
        if (!m(I))
            return null;
        const ie = I._readableState;
        return ie != null && ie.errored ? !1 : typeof ie?.endEmitted != "boolean" ? null : !!(ie.endEmitted || Z === !1 && ie.ended === !0 && ie.length === 0)
    }
    function O(I) {
        return I && I[a] != null ? I[a] : typeof I?.readable != "boolean" ? null : S(I) ? !1 : m(I) && I.readable && !U(I)
    }
    function Q(I) {
        return I && I[l] != null ? I[l] : typeof I?.writable != "boolean" ? null : S(I) ? !1 : _(I) && I.writable && !y(I)
    }
    function D(I, Z) {
        return g(I) ? S(I) ? !0 : !(Z?.readable !== !1 && O(I) || Z?.writable !== !1 && Q(I)) : null
    }
    function $(I) {
        var Z, ie;
        return g(I) ? I.writableErrored ? I.writableErrored : (Z = (ie = I._writableState) === null || ie === void 0 ? void 0 : ie.errored) !== null && Z !== void 0 ? Z : null : null
    }
    function X(I) {
        var Z, ie;
        return g(I) ? I.readableErrored ? I.readableErrored : (Z = (ie = I._readableState) === null || ie === void 0 ? void 0 : ie.errored) !== null && Z !== void 0 ? Z : null : null
    }
    function F(I) {
        if (!g(I))
            return null;
        if (typeof I.closed == "boolean")
            return I.closed;
        const Z = I._writableState
          , ie = I._readableState;
        return typeof Z?.closed == "boolean" || typeof ie?.closed == "boolean" ? Z?.closed || ie?.closed : typeof I._closed == "boolean" && B(I) ? I._closed : null
    }
    function B(I) {
        return typeof I._closed == "boolean" && typeof I._defaultKeepAlive == "boolean" && typeof I._removedConnection == "boolean" && typeof I._removedContLen == "boolean"
    }
    function ue(I) {
        return typeof I._sent100 == "boolean" && B(I)
    }
    function P(I) {
        var Z;
        return typeof I._consuming == "boolean" && typeof I._dumped == "boolean" && ((Z = I.req) === null || Z === void 0 ? void 0 : Z.upgradeOrConnect) === void 0
    }
    function oe(I) {
        if (!g(I))
            return null;
        const Z = I._writableState
          , ie = I._readableState
          , ee = Z || ie;
        return !ee && ue(I) || !!(ee && ee.autoDestroy && ee.emitClose && ee.closed === !1)
    }
    function j(I) {
        var Z;
        return !!(I && ((Z = I[u]) !== null && Z !== void 0 ? Z : I.readableDidRead || I.readableAborted))
    }
    function ae(I) {
        var Z, ie, ee, me, W, G, Y, K, le, ce;
        return !!(I && ((Z = (ie = (ee = (me = (W = (G = I[o]) !== null && G !== void 0 ? G : I.readableErrored) !== null && W !== void 0 ? W : I.writableErrored) !== null && me !== void 0 ? me : (Y = I._readableState) === null || Y === void 0 ? void 0 : Y.errorEmitted) !== null && ee !== void 0 ? ee : (K = I._writableState) === null || K === void 0 ? void 0 : K.errorEmitted) !== null && ie !== void 0 ? ie : (le = I._readableState) === null || le === void 0 ? void 0 : le.errored) !== null && Z !== void 0 ? Z : !((ce = I._writableState) === null || ce === void 0) && ce.errored))
    }
    return qo = {
        isDestroyed: S,
        kIsDestroyed: r,
        isDisturbed: j,
        kIsDisturbed: u,
        isErrored: ae,
        kIsErrored: o,
        isReadable: O,
        kIsReadable: a,
        kIsClosedPromise: f,
        kControllerErrorFunction: h,
        kIsWritable: l,
        isClosed: F,
        isDuplexNodeStream: d,
        isFinished: D,
        isIterable: R,
        isReadableNodeStream: m,
        isReadableStream: b,
        isReadableEnded: M,
        isReadableFinished: U,
        isReadableErrored: X,
        isNodeStream: g,
        isWebStream: A,
        isWritable: Q,
        isWritableNodeStream: _,
        isWritableStream: T,
        isWritableEnded: y,
        isWritableFinished: x,
        isWritableErrored: $,
        isServerRequest: P,
        isServerResponse: ue,
        willEmitClose: oe,
        isTransformStream: N
    },
    qo
}
var _c;
function Vn() {
    if (_c)
        return ys.exports;
    _c = 1;
    const i = xi()
      , {AbortError: e, codes: n} = kt()
      , {ERR_INVALID_ARG_TYPE: r, ERR_STREAM_PREMATURE_CLOSE: o} = n
      , {kEmptyObject: a, once: l} = Ot()
      , {validateAbortSignal: u, validateFunction: f, validateObject: h, validateBoolean: m} = Vr()
      , {Promise: _, PromisePrototypeThen: d, SymbolDispose: g} = ct()
      , {isClosed: b, isReadable: T, isReadableNodeStream: N, isReadableStream: A, isReadableFinished: R, isReadableErrored: S, isWritable: y, isWritableNodeStream: x, isWritableStream: M, isWritableFinished: U, isWritableErrored: O, isNodeStream: Q, willEmitClose: D, kIsClosedPromise: $} = Cn();
    let X;
    function F(j) {
        return j.setHeader && typeof j.abort == "function"
    }
    const B = ()=>{}
    ;
    function ue(j, ae, I) {
        var Z, ie;
        if (arguments.length === 2 ? (I = ae,
        ae = a) : ae == null ? ae = a : h(ae, "options"),
        f(I, "callback"),
        u(ae.signal, "options.signal"),
        I = l(I),
        A(j) || M(j))
            return P(j, ae, I);
        if (!Q(j))
            throw new r("stream",["ReadableStream", "WritableStream", "Stream"],j);
        const ee = (Z = ae.readable) !== null && Z !== void 0 ? Z : N(j)
          , me = (ie = ae.writable) !== null && ie !== void 0 ? ie : x(j)
          , W = j._writableState
          , G = j._readableState
          , Y = ()=>{
            j.writable || ce()
        }
        ;
        let K = D(j) && N(j) === ee && x(j) === me
          , le = U(j, !1);
        const ce = ()=>{
            le = !0,
            j.destroyed && (K = !1),
            !(K && (!j.readable || ee)) && (!ee || Ee) && I.call(j)
        }
        ;
        let Ee = R(j, !1);
        const Te = ()=>{
            Ee = !0,
            j.destroyed && (K = !1),
            !(K && (!j.writable || me)) && (!me || le) && I.call(j)
        }
          , q = se=>{
            I.call(j, se)
        }
        ;
        let te = b(j);
        const fe = ()=>{
            te = !0;
            const se = O(j) || S(j);
            if (se && typeof se != "boolean")
                return I.call(j, se);
            if (ee && !Ee && N(j, !0) && !R(j, !1))
                return I.call(j, new o);
            if (me && !le && !U(j, !1))
                return I.call(j, new o);
            I.call(j)
        }
          , xe = ()=>{
            te = !0;
            const se = O(j) || S(j);
            if (se && typeof se != "boolean")
                return I.call(j, se);
            I.call(j)
        }
          , Se = ()=>{
            j.req.on("finish", ce)
        }
        ;
        F(j) ? (j.on("complete", ce),
        K || j.on("abort", fe),
        j.req ? Se() : j.on("request", Se)) : me && !W && (j.on("end", Y),
        j.on("close", Y)),
        !K && typeof j.aborted == "boolean" && j.on("aborted", fe),
        j.on("end", Te),
        j.on("finish", ce),
        ae.error !== !1 && j.on("error", q),
        j.on("close", fe),
        te ? i.nextTick(fe) : W != null && W.errorEmitted || G != null && G.errorEmitted ? K || i.nextTick(xe) : (!ee && (!K || T(j)) && (le || y(j) === !1) || !me && (!K || y(j)) && (Ee || T(j) === !1) || G && j.req && j.aborted) && i.nextTick(xe);
        const Ie = ()=>{
            I = B,
            j.removeListener("aborted", fe),
            j.removeListener("complete", ce),
            j.removeListener("abort", fe),
            j.removeListener("request", Se),
            j.req && j.req.removeListener("finish", ce),
            j.removeListener("end", Y),
            j.removeListener("close", Y),
            j.removeListener("finish", ce),
            j.removeListener("end", Te),
            j.removeListener("error", q),
            j.removeListener("close", fe)
        }
        ;
        if (ae.signal && !te) {
            const se = ()=>{
                const be = I;
                Ie(),
                be.call(j, new e(void 0,{
                    cause: ae.signal.reason
                }))
            }
            ;
            if (ae.signal.aborted)
                i.nextTick(se);
            else {
                X = X || Ot().addAbortListener;
                const be = X(ae.signal, se)
                  , Ne = I;
                I = l((...ve)=>{
                    be[g](),
                    Ne.apply(j, ve)
                }
                )
            }
        }
        return Ie
    }
    function P(j, ae, I) {
        let Z = !1
          , ie = B;
        if (ae.signal)
            if (ie = ()=>{
                Z = !0,
                I.call(j, new e(void 0,{
                    cause: ae.signal.reason
                }))
            }
            ,
            ae.signal.aborted)
                i.nextTick(ie);
            else {
                X = X || Ot().addAbortListener;
                const me = X(ae.signal, ie)
                  , W = I;
                I = l((...G)=>{
                    me[g](),
                    W.apply(j, G)
                }
                )
            }
        const ee = (...me)=>{
            Z || i.nextTick(()=>I.apply(j, me))
        }
        ;
        return d(j[$].promise, ee, ee),
        B
    }
    function oe(j, ae) {
        var I;
        let Z = !1;
        return ae === null && (ae = a),
        (I = ae) !== null && I !== void 0 && I.cleanup && (m(ae.cleanup, "cleanup"),
        Z = ae.cleanup),
        new _((ie,ee)=>{
            const me = ue(j, ae, W=>{
                Z && me(),
                W ? ee(W) : ie()
            }
            )
        }
        )
    }
    return ys.exports = ue,
    ys.exports.finished = oe,
    ys.exports
}
var zo, yc;
function Gi() {
    if (yc)
        return zo;
    yc = 1;
    const i = xi()
      , {aggregateTwoErrors: e, codes: {ERR_MULTIPLE_CALLBACK: n}, AbortError: r} = kt()
      , {Symbol: o} = ct()
      , {kIsDestroyed: a, isDestroyed: l, isFinished: u, isServerRequest: f} = Cn()
      , h = o("kDestroy")
      , m = o("kConstruct");
    function _(D, $, X) {
        D && (D.stack,
        $ && !$.errored && ($.errored = D),
        X && !X.errored && (X.errored = D))
    }
    function d(D, $) {
        const X = this._readableState
          , F = this._writableState
          , B = F || X;
        return F != null && F.destroyed || X != null && X.destroyed ? (typeof $ == "function" && $(),
        this) : (_(D, F, X),
        F && (F.destroyed = !0),
        X && (X.destroyed = !0),
        B.constructed ? g(this, D, $) : this.once(h, function(ue) {
            g(this, e(ue, D), $)
        }),
        this)
    }
    function g(D, $, X) {
        let F = !1;
        function B(ue) {
            if (F)
                return;
            F = !0;
            const P = D._readableState
              , oe = D._writableState;
            _(ue, oe, P),
            oe && (oe.closed = !0),
            P && (P.closed = !0),
            typeof X == "function" && X(ue),
            ue ? i.nextTick(b, D, ue) : i.nextTick(T, D)
        }
        try {
            D._destroy($ || null, B)
        } catch (ue) {
            B(ue)
        }
    }
    function b(D, $) {
        N(D, $),
        T(D)
    }
    function T(D) {
        const $ = D._readableState
          , X = D._writableState;
        X && (X.closeEmitted = !0),
        $ && ($.closeEmitted = !0),
        (X != null && X.emitClose || $ != null && $.emitClose) && D.emit("close")
    }
    function N(D, $) {
        const X = D._readableState
          , F = D._writableState;
        F != null && F.errorEmitted || X != null && X.errorEmitted || (F && (F.errorEmitted = !0),
        X && (X.errorEmitted = !0),
        D.emit("error", $))
    }
    function A() {
        const D = this._readableState
          , $ = this._writableState;
        D && (D.constructed = !0,
        D.closed = !1,
        D.closeEmitted = !1,
        D.destroyed = !1,
        D.errored = null,
        D.errorEmitted = !1,
        D.reading = !1,
        D.ended = D.readable === !1,
        D.endEmitted = D.readable === !1),
        $ && ($.constructed = !0,
        $.destroyed = !1,
        $.closed = !1,
        $.closeEmitted = !1,
        $.errored = null,
        $.errorEmitted = !1,
        $.finalCalled = !1,
        $.prefinished = !1,
        $.ended = $.writable === !1,
        $.ending = $.writable === !1,
        $.finished = $.writable === !1)
    }
    function R(D, $, X) {
        const F = D._readableState
          , B = D._writableState;
        if (B != null && B.destroyed || F != null && F.destroyed)
            return this;
        F != null && F.autoDestroy || B != null && B.autoDestroy ? D.destroy($) : $ && ($.stack,
        B && !B.errored && (B.errored = $),
        F && !F.errored && (F.errored = $),
        X ? i.nextTick(N, D, $) : N(D, $))
    }
    function S(D, $) {
        if (typeof D._construct != "function")
            return;
        const X = D._readableState
          , F = D._writableState;
        X && (X.constructed = !1),
        F && (F.constructed = !1),
        D.once(m, $),
        !(D.listenerCount(m) > 1) && i.nextTick(y, D)
    }
    function y(D) {
        let $ = !1;
        function X(F) {
            if ($) {
                R(D, F ?? new n);
                return
            }
            $ = !0;
            const B = D._readableState
              , ue = D._writableState
              , P = ue || B;
            B && (B.constructed = !0),
            ue && (ue.constructed = !0),
            P.destroyed ? D.emit(h, F) : F ? R(D, F, !0) : i.nextTick(x, D)
        }
        try {
            D._construct(F=>{
                i.nextTick(X, F)
            }
            )
        } catch (F) {
            i.nextTick(X, F)
        }
    }
    function x(D) {
        D.emit(m)
    }
    function M(D) {
        return D?.setHeader && typeof D.abort == "function"
    }
    function U(D) {
        D.emit("close")
    }
    function O(D, $) {
        D.emit("error", $),
        i.nextTick(U, D)
    }
    function Q(D, $) {
        !D || l(D) || (!$ && !u(D) && ($ = new r),
        f(D) ? (D.socket = null,
        D.destroy($)) : M(D) ? D.abort() : M(D.req) ? D.req.abort() : typeof D.destroy == "function" ? D.destroy($) : typeof D.close == "function" ? D.close() : $ ? i.nextTick(O, D, $) : i.nextTick(U, D),
        D.destroyed || (D[a] = !0))
    }
    return zo = {
        construct: S,
        destroyer: Q,
        destroy: d,
        undestroy: A,
        errorOrDestroy: R
    },
    zo
}
var Uo, vc;
function kl() {
    if (vc)
        return Uo;
    vc = 1;
    const {ArrayIsArray: i, ObjectSetPrototypeOf: e} = ct()
      , {EventEmitter: n} = Hs();
    function r(a) {
        n.call(this, a)
    }
    e(r.prototype, n.prototype),
    e(r, n),
    r.prototype.pipe = function(a, l) {
        const u = this;
        function f(T) {
            a.writable && a.write(T) === !1 && u.pause && u.pause()
        }
        u.on("data", f);
        function h() {
            u.readable && u.resume && u.resume()
        }
        a.on("drain", h),
        !a._isStdio && (!l || l.end !== !1) && (u.on("end", _),
        u.on("close", d));
        let m = !1;
        function _() {
            m || (m = !0,
            a.end())
        }
        function d() {
            m || (m = !0,
            typeof a.destroy == "function" && a.destroy())
        }
        function g(T) {
            b(),
            n.listenerCount(this, "error") === 0 && this.emit("error", T)
        }
        o(u, "error", g),
        o(a, "error", g);
        function b() {
            u.removeListener("data", f),
            a.removeListener("drain", h),
            u.removeListener("end", _),
            u.removeListener("close", d),
            u.removeListener("error", g),
            a.removeListener("error", g),
            u.removeListener("end", b),
            u.removeListener("close", b),
            a.removeListener("close", b)
        }
        return u.on("end", b),
        u.on("close", b),
        a.on("close", b),
        a.emit("pipe", u),
        a
    }
    ;
    function o(a, l, u) {
        if (typeof a.prependListener == "function")
            return a.prependListener(l, u);
        !a._events || !a._events[l] ? a.on(l, u) : i(a._events[l]) ? a._events[l].unshift(u) : a._events[l] = [u, a._events[l]]
    }
    return Uo = {
        Stream: r,
        prependListener: o
    },
    Uo
}
var Ho = {
    exports: {}
}, bc;
function Vs() {
    return bc || (bc = 1,
    (function(i) {
        const {SymbolDispose: e} = ct()
          , {AbortError: n, codes: r} = kt()
          , {isNodeStream: o, isWebStream: a, kControllerErrorFunction: l} = Cn()
          , u = Vn()
          , {ERR_INVALID_ARG_TYPE: f} = r;
        let h;
        const m = (_,d)=>{
            if (typeof _ != "object" || !("aborted"in _))
                throw new f(d,"AbortSignal",_)
        }
        ;
        i.exports.addAbortSignal = function(d, g) {
            if (m(d, "signal"),
            !o(g) && !a(g))
                throw new f("stream",["ReadableStream", "WritableStream", "Stream"],g);
            return i.exports.addAbortSignalNoValidate(d, g)
        }
        ,
        i.exports.addAbortSignalNoValidate = function(_, d) {
            if (typeof _ != "object" || !("aborted"in _))
                return d;
            const g = o(d) ? ()=>{
                d.destroy(new n(void 0,{
                    cause: _.reason
                }))
            }
            : ()=>{
                d[l](new n(void 0,{
                    cause: _.reason
                }))
            }
            ;
            if (_.aborted)
                g();
            else {
                h = h || Ot().addAbortListener;
                const b = h(_, g);
                u(d, b[e])
            }
            return d
        }
    }
    )(Ho)),
    Ho.exports
}
var Vo, wc;
function Og() {
    if (wc)
        return Vo;
    wc = 1;
    const {StringPrototypeSlice: i, SymbolIterator: e, TypedArrayPrototypeSet: n, Uint8Array: r} = ct()
      , {Buffer: o} = Rn()
      , {inspect: a} = Ot();
    return Vo = class {
        constructor() {
            this.head = null,
            this.tail = null,
            this.length = 0
        }
        push(u) {
            const f = {
                data: u,
                next: null
            };
            this.length > 0 ? this.tail.next = f : this.head = f,
            this.tail = f,
            ++this.length
        }
        unshift(u) {
            const f = {
                data: u,
                next: this.head
            };
            this.length === 0 && (this.tail = f),
            this.head = f,
            ++this.length
        }
        shift() {
            if (this.length === 0)
                return;
            const u = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next,
            --this.length,
            u
        }
        clear() {
            this.head = this.tail = null,
            this.length = 0
        }
        join(u) {
            if (this.length === 0)
                return "";
            let f = this.head
              , h = "" + f.data;
            for (; (f = f.next) !== null; )
                h += u + f.data;
            return h
        }
        concat(u) {
            if (this.length === 0)
                return o.alloc(0);
            const f = o.allocUnsafe(u >>> 0);
            let h = this.head
              , m = 0;
            for (; h; )
                n(f, h.data, m),
                m += h.data.length,
                h = h.next;
            return f
        }
        consume(u, f) {
            const h = this.head.data;
            if (u < h.length) {
                const m = h.slice(0, u);
                return this.head.data = h.slice(u),
                m
            }
            return u === h.length ? this.shift() : f ? this._getString(u) : this._getBuffer(u)
        }
        first() {
            return this.head.data
        }
        *[e]() {
            for (let u = this.head; u; u = u.next)
                yield u.data
        }
        _getString(u) {
            let f = ""
              , h = this.head
              , m = 0;
            do {
                const _ = h.data;
                if (u > _.length)
                    f += _,
                    u -= _.length;
                else {
                    u === _.length ? (f += _,
                    ++m,
                    h.next ? this.head = h.next : this.head = this.tail = null) : (f += i(_, 0, u),
                    this.head = h,
                    h.data = i(_, u));
                    break
                }
                ++m
            } while ((h = h.next) !== null);
            return this.length -= m,
            f
        }
        _getBuffer(u) {
            const f = o.allocUnsafe(u)
              , h = u;
            let m = this.head
              , _ = 0;
            do {
                const d = m.data;
                if (u > d.length)
                    n(f, d, h - u),
                    u -= d.length;
                else {
                    u === d.length ? (n(f, d, h - u),
                    ++_,
                    m.next ? this.head = m.next : this.head = this.tail = null) : (n(f, new r(d.buffer,d.byteOffset,u), h - u),
                    this.head = m,
                    m.data = d.slice(u));
                    break
                }
                ++_
            } while ((m = m.next) !== null);
            return this.length -= _,
            f
        }
        [Symbol.for("nodejs.util.inspect.custom")](u, f) {
            return a(this, {
                ...f,
                depth: 0,
                customInspect: !1
            })
        }
    }
    ,
    Vo
}
var Go, xc;
function Gs() {
    if (xc)
        return Go;
    xc = 1;
    const {MathFloor: i, NumberIsInteger: e} = ct()
      , {validateInteger: n} = Vr()
      , {ERR_INVALID_ARG_VALUE: r} = kt().codes;
    let o = 16 * 1024
      , a = 16;
    function l(m, _, d) {
        return m.highWaterMark != null ? m.highWaterMark : _ ? m[d] : null
    }
    function u(m) {
        return m ? a : o
    }
    function f(m, _) {
        n(_, "value", 0),
        m ? a = _ : o = _
    }
    function h(m, _, d, g) {
        const b = l(_, g, d);
        if (b != null) {
            if (!e(b) || b < 0) {
                const T = g ? `options.${d}` : "options.highWaterMark";
                throw new r(T,b)
            }
            return i(b)
        }
        return u(m.objectMode)
    }
    return Go = {
        getHighWaterMark: h,
        getDefaultHighWaterMark: u,
        setDefaultHighWaterMark: f
    },
    Go
}
var Wo = {}
  , vs = {
    exports: {}
};
var Ec;
function Fg() {
    return Ec || (Ec = 1,
    (function(i, e) {
        var n = Rn()
          , r = n.Buffer;
        function o(l, u) {
            for (var f in l)
                u[f] = l[f]
        }
        r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? i.exports = n : (o(n, e),
        e.Buffer = a);
        function a(l, u, f) {
            return r(l, u, f)
        }
        a.prototype = Object.create(r.prototype),
        o(r, a),
        a.from = function(l, u, f) {
            if (typeof l == "number")
                throw new TypeError("Argument must not be a number");
            return r(l, u, f)
        }
        ,
        a.alloc = function(l, u, f) {
            if (typeof l != "number")
                throw new TypeError("Argument must be a number");
            var h = r(l);
            return u !== void 0 ? typeof f == "string" ? h.fill(u, f) : h.fill(u) : h.fill(0),
            h
        }
        ,
        a.allocUnsafe = function(l) {
            if (typeof l != "number")
                throw new TypeError("Argument must be a number");
            return r(l)
        }
        ,
        a.allocUnsafeSlow = function(l) {
            if (typeof l != "number")
                throw new TypeError("Argument must be a number");
            return n.SlowBuffer(l)
        }
    }
    )(vs, vs.exports)),
    vs.exports
}
var Sc;
function jg() {
    if (Sc)
        return Wo;
    Sc = 1;
    var i = Fg().Buffer
      , e = i.isEncoding || function(A) {
        switch (A = "" + A,
        A && A.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
            return !0;
        default:
            return !1
        }
    }
    ;
    function n(A) {
        if (!A)
            return "utf8";
        for (var R; ; )
            switch (A) {
            case "utf8":
            case "utf-8":
                return "utf8";
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return "utf16le";
            case "latin1":
            case "binary":
                return "latin1";
            case "base64":
            case "ascii":
            case "hex":
                return A;
            default:
                if (R)
                    return;
                A = ("" + A).toLowerCase(),
                R = !0
            }
    }
    function r(A) {
        var R = n(A);
        if (typeof R != "string" && (i.isEncoding === e || !e(A)))
            throw new Error("Unknown encoding: " + A);
        return R || A
    }
    Wo.StringDecoder = o;
    function o(A) {
        this.encoding = r(A);
        var R;
        switch (this.encoding) {
        case "utf16le":
            this.text = _,
            this.end = d,
            R = 4;
            break;
        case "utf8":
            this.fillLast = f,
            R = 4;
            break;
        case "base64":
            this.text = g,
            this.end = b,
            R = 3;
            break;
        default:
            this.write = T,
            this.end = N;
            return
        }
        this.lastNeed = 0,
        this.lastTotal = 0,
        this.lastChar = i.allocUnsafe(R)
    }
    o.prototype.write = function(A) {
        if (A.length === 0)
            return "";
        var R, S;
        if (this.lastNeed) {
            if (R = this.fillLast(A),
            R === void 0)
                return "";
            S = this.lastNeed,
            this.lastNeed = 0
        } else
            S = 0;
        return S < A.length ? R ? R + this.text(A, S) : this.text(A, S) : R || ""
    }
    ,
    o.prototype.end = m,
    o.prototype.text = h,
    o.prototype.fillLast = function(A) {
        if (this.lastNeed <= A.length)
            return A.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal);
        A.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, A.length),
        this.lastNeed -= A.length
    }
    ;
    function a(A) {
        return A <= 127 ? 0 : A >> 5 === 6 ? 2 : A >> 4 === 14 ? 3 : A >> 3 === 30 ? 4 : A >> 6 === 2 ? -1 : -2
    }
    function l(A, R, S) {
        var y = R.length - 1;
        if (y < S)
            return 0;
        var x = a(R[y]);
        return x >= 0 ? (x > 0 && (A.lastNeed = x - 1),
        x) : --y < S || x === -2 ? 0 : (x = a(R[y]),
        x >= 0 ? (x > 0 && (A.lastNeed = x - 2),
        x) : --y < S || x === -2 ? 0 : (x = a(R[y]),
        x >= 0 ? (x > 0 && (x === 2 ? x = 0 : A.lastNeed = x - 3),
        x) : 0))
    }
    function u(A, R, S) {
        if ((R[0] & 192) !== 128)
            return A.lastNeed = 0,
            "";
        if (A.lastNeed > 1 && R.length > 1) {
            if ((R[1] & 192) !== 128)
                return A.lastNeed = 1,
                "";
            if (A.lastNeed > 2 && R.length > 2 && (R[2] & 192) !== 128)
                return A.lastNeed = 2,
                ""
        }
    }
    function f(A) {
        var R = this.lastTotal - this.lastNeed
          , S = u(this, A);
        if (S !== void 0)
            return S;
        if (this.lastNeed <= A.length)
            return A.copy(this.lastChar, R, 0, this.lastNeed),
            this.lastChar.toString(this.encoding, 0, this.lastTotal);
        A.copy(this.lastChar, R, 0, A.length),
        this.lastNeed -= A.length
    }
    function h(A, R) {
        var S = l(this, A, R);
        if (!this.lastNeed)
            return A.toString("utf8", R);
        this.lastTotal = S;
        var y = A.length - (S - this.lastNeed);
        return A.copy(this.lastChar, 0, y),
        A.toString("utf8", R, y)
    }
    function m(A) {
        var R = A && A.length ? this.write(A) : "";
        return this.lastNeed ? R + "" : R
    }
    function _(A, R) {
        if ((A.length - R) % 2 === 0) {
            var S = A.toString("utf16le", R);
            if (S) {
                var y = S.charCodeAt(S.length - 1);
                if (y >= 55296 && y <= 56319)
                    return this.lastNeed = 2,
                    this.lastTotal = 4,
                    this.lastChar[0] = A[A.length - 2],
                    this.lastChar[1] = A[A.length - 1],
                    S.slice(0, -1)
            }
            return S
        }
        return this.lastNeed = 1,
        this.lastTotal = 2,
        this.lastChar[0] = A[A.length - 1],
        A.toString("utf16le", R, A.length - 1)
    }
    function d(A) {
        var R = A && A.length ? this.write(A) : "";
        if (this.lastNeed) {
            var S = this.lastTotal - this.lastNeed;
            return R + this.lastChar.toString("utf16le", 0, S)
        }
        return R
    }
    function g(A, R) {
        var S = (A.length - R) % 3;
        return S === 0 ? A.toString("base64", R) : (this.lastNeed = 3 - S,
        this.lastTotal = 3,
        S === 1 ? this.lastChar[0] = A[A.length - 1] : (this.lastChar[0] = A[A.length - 2],
        this.lastChar[1] = A[A.length - 1]),
        A.toString("base64", R, A.length - S))
    }
    function b(A) {
        var R = A && A.length ? this.write(A) : "";
        return this.lastNeed ? R + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : R
    }
    function T(A) {
        return A.toString(this.encoding)
    }
    function N(A) {
        return A && A.length ? this.write(A) : ""
    }
    return Wo
}
var Zo, Tc;
function df() {
    if (Tc)
        return Zo;
    Tc = 1;
    const i = xi()
      , {PromisePrototypeThen: e, SymbolAsyncIterator: n, SymbolIterator: r} = ct()
      , {Buffer: o} = Rn()
      , {ERR_INVALID_ARG_TYPE: a, ERR_STREAM_NULL_VALUES: l} = kt().codes;
    function u(f, h, m) {
        let _;
        if (typeof h == "string" || h instanceof o)
            return new f({
                objectMode: !0,
                ...m,
                read() {
                    this.push(h),
                    this.push(null)
                }
            });
        let d;
        if (h && h[n])
            d = !0,
            _ = h[n]();
        else if (h && h[r])
            d = !1,
            _ = h[r]();
        else
            throw new a("iterable",["Iterable"],h);
        const g = new f({
            objectMode: !0,
            highWaterMark: 1,
            ...m
        });
        let b = !1;
        g._read = function() {
            b || (b = !0,
            N())
        }
        ,
        g._destroy = function(A, R) {
            e(T(A), ()=>i.nextTick(R, A), S=>i.nextTick(R, S || A))
        }
        ;
        async function T(A) {
            const R = A != null
              , S = typeof _.throw == "function";
            if (R && S) {
                const {value: y, done: x} = await _.throw(A);
                if (await y,
                x)
                    return
            }
            if (typeof _.return == "function") {
                const {value: y} = await _.return();
                await y
            }
        }
        async function N() {
            for (; ; ) {
                try {
                    const {value: A, done: R} = d ? await _.next() : _.next();
                    if (R)
                        g.push(null);
                    else {
                        const S = A && typeof A.then == "function" ? await A : A;
                        if (S === null)
                            throw b = !1,
                            new l;
                        if (g.push(S))
                            continue;
                        b = !1
                    }
                } catch (A) {
                    g.destroy(A)
                }
                break
            }
        }
        return g
    }
    return Zo = u,
    Zo
}
var Xo, Lc;
function Ws() {
    if (Lc)
        return Xo;
    Lc = 1;
    const i = xi()
      , {ArrayPrototypeIndexOf: e, NumberIsInteger: n, NumberIsNaN: r, NumberParseInt: o, ObjectDefineProperties: a, ObjectKeys: l, ObjectSetPrototypeOf: u, Promise: f, SafeSet: h, SymbolAsyncDispose: m, SymbolAsyncIterator: _, Symbol: d} = ct();
    Xo = ve,
    ve.ReadableState = Ne;
    const {EventEmitter: g} = Hs()
      , {Stream: b, prependListener: T} = kl()
      , {Buffer: N} = Rn()
      , {addAbortSignal: A} = Vs()
      , R = Vn();
    let S = Ot().debuglog("stream", z=>{
        S = z
    }
    );
    const y = Og()
      , x = Gi()
      , {getHighWaterMark: M, getDefaultHighWaterMark: U} = Gs()
      , {aggregateTwoErrors: O, codes: {ERR_INVALID_ARG_TYPE: Q, ERR_METHOD_NOT_IMPLEMENTED: D, ERR_OUT_OF_RANGE: $, ERR_STREAM_PUSH_AFTER_EOF: X, ERR_STREAM_UNSHIFT_AFTER_END_EVENT: F}, AbortError: B} = kt()
      , {validateObject: ue} = Vr()
      , P = d("kPaused")
      , {StringDecoder: oe} = jg()
      , j = df();
    u(ve.prototype, b.prototype),
    u(ve, b);
    const ae = ()=>{}
      , {errorOrDestroy: I} = x
      , Z = 1
      , ie = 2
      , ee = 4
      , me = 8
      , W = 16
      , G = 32
      , Y = 64
      , K = 128
      , le = 256
      , ce = 512
      , Ee = 1024
      , Te = 2048
      , q = 4096
      , te = 8192
      , fe = 16384
      , xe = 32768
      , Se = 65536
      , Ie = 1 << 17
      , se = 1 << 18;
    function be(z) {
        return {
            enumerable: !1,
            get() {
                return (this.state & z) !== 0
            },
            set(J) {
                J ? this.state |= z : this.state &= ~z
            }
        }
    }
    a(Ne.prototype, {
        objectMode: be(Z),
        ended: be(ie),
        endEmitted: be(ee),
        reading: be(me),
        constructed: be(W),
        sync: be(G),
        needReadable: be(Y),
        emittedReadable: be(K),
        readableListening: be(le),
        resumeScheduled: be(ce),
        errorEmitted: be(Ee),
        emitClose: be(Te),
        autoDestroy: be(q),
        destroyed: be(te),
        closed: be(fe),
        closeEmitted: be(xe),
        multiAwaitDrain: be(Se),
        readingMore: be(Ie),
        dataEmitted: be(se)
    });
    function Ne(z, J, Ae) {
        typeof Ae != "boolean" && (Ae = J instanceof In()),
        this.state = Te | q | W | G,
        z && z.objectMode && (this.state |= Z),
        Ae && z && z.readableObjectMode && (this.state |= Z),
        this.highWaterMark = z ? M(this, z, "readableHighWaterMark", Ae) : U(!1),
        this.buffer = new y,
        this.length = 0,
        this.pipes = [],
        this.flowing = null,
        this[P] = null,
        z && z.emitClose === !1 && (this.state &= ~Te),
        z && z.autoDestroy === !1 && (this.state &= ~q),
        this.errored = null,
        this.defaultEncoding = z && z.defaultEncoding || "utf8",
        this.awaitDrainWriters = null,
        this.decoder = null,
        this.encoding = null,
        z && z.encoding && (this.decoder = new oe(z.encoding),
        this.encoding = z.encoding)
    }
    function ve(z) {
        if (!(this instanceof ve))
            return new ve(z);
        const J = this instanceof In();
        this._readableState = new Ne(z,this,J),
        z && (typeof z.read == "function" && (this._read = z.read),
        typeof z.destroy == "function" && (this._destroy = z.destroy),
        typeof z.construct == "function" && (this._construct = z.construct),
        z.signal && !J && A(z.signal, this)),
        b.call(this, z),
        x.construct(this, ()=>{
            this._readableState.needReadable && re(this, this._readableState)
        }
        )
    }
    ve.prototype.destroy = x.destroy,
    ve.prototype._undestroy = x.undestroy,
    ve.prototype._destroy = function(z, J) {
        J(z)
    }
    ,
    ve.prototype[g.captureRejectionSymbol] = function(z) {
        this.destroy(z)
    }
    ,
    ve.prototype[m] = function() {
        let z;
        return this.destroyed || (z = this.readableEnded ? null : new B,
        this.destroy(z)),
        new f((J,Ae)=>R(this, Re=>Re && Re !== z ? Ae(Re) : J(null)))
    }
    ,
    ve.prototype.push = function(z, J) {
        return $e(this, z, J, !1)
    }
    ,
    ve.prototype.unshift = function(z, J) {
        return $e(this, z, J, !0)
    }
    ;
    function $e(z, J, Ae, Re) {
        S("readableAddChunk", J);
        const Me = z._readableState;
        let _t;
        if ((Me.state & Z) === 0 && (typeof J == "string" ? (Ae = Ae || Me.defaultEncoding,
        Me.encoding !== Ae && (Re && Me.encoding ? J = N.from(J, Ae).toString(Me.encoding) : (J = N.from(J, Ae),
        Ae = ""))) : J instanceof N ? Ae = "" : b._isUint8Array(J) ? (J = b._uint8ArrayToBuffer(J),
        Ae = "") : J != null && (_t = new Q("chunk",["string", "Buffer", "Uint8Array"],J))),
        _t)
            I(z, _t);
        else if (J === null)
            Me.state &= ~me,
            v(z, Me);
        else if ((Me.state & Z) !== 0 || J && J.length > 0)
            if (Re)
                if ((Me.state & ee) !== 0)
                    I(z, new F);
                else {
                    if (Me.destroyed || Me.errored)
                        return !1;
                    mt(z, Me, J, !0)
                }
            else if (Me.ended)
                I(z, new X);
            else {
                if (Me.destroyed || Me.errored)
                    return !1;
                Me.state &= ~me,
                Me.decoder && !Ae ? (J = Me.decoder.write(J),
                Me.objectMode || J.length !== 0 ? mt(z, Me, J, !1) : re(z, Me)) : mt(z, Me, J, !1)
            }
        else
            Re || (Me.state &= ~me,
            re(z, Me));
        return !Me.ended && (Me.length < Me.highWaterMark || Me.length === 0)
    }
    function mt(z, J, Ae, Re) {
        J.flowing && J.length === 0 && !J.sync && z.listenerCount("data") > 0 ? ((J.state & Se) !== 0 ? J.awaitDrainWriters.clear() : J.awaitDrainWriters = null,
        J.dataEmitted = !0,
        z.emit("data", Ae)) : (J.length += J.objectMode ? 1 : Ae.length,
        Re ? J.buffer.unshift(Ae) : J.buffer.push(Ae),
        (J.state & Y) !== 0 && w(z)),
        re(z, J)
    }
    ve.prototype.isPaused = function() {
        const z = this._readableState;
        return z[P] === !0 || z.flowing === !1
    }
    ,
    ve.prototype.setEncoding = function(z) {
        const J = new oe(z);
        this._readableState.decoder = J,
        this._readableState.encoding = this._readableState.decoder.encoding;
        const Ae = this._readableState.buffer;
        let Re = "";
        for (const Me of Ae)
            Re += J.write(Me);
        return Ae.clear(),
        Re !== "" && Ae.push(Re),
        this._readableState.length = Re.length,
        this
    }
    ;
    const Be = 1073741824;
    function ft(z) {
        if (z > Be)
            throw new $("size","<= 1GiB",z);
        return z--,
        z |= z >>> 1,
        z |= z >>> 2,
        z |= z >>> 4,
        z |= z >>> 8,
        z |= z >>> 16,
        z++,
        z
    }
    function C(z, J) {
        return z <= 0 || J.length === 0 && J.ended ? 0 : (J.state & Z) !== 0 ? 1 : r(z) ? J.flowing && J.length ? J.buffer.first().length : J.length : z <= J.length ? z : J.ended ? J.length : 0
    }
    ve.prototype.read = function(z) {
        S("read", z),
        z === void 0 ? z = NaN : n(z) || (z = o(z, 10));
        const J = this._readableState
          , Ae = z;
        if (z > J.highWaterMark && (J.highWaterMark = ft(z)),
        z !== 0 && (J.state &= ~K),
        z === 0 && J.needReadable && ((J.highWaterMark !== 0 ? J.length >= J.highWaterMark : J.length > 0) || J.ended))
            return S("read: emitReadable", J.length, J.ended),
            J.length === 0 && J.ended ? at(this) : w(this),
            null;
        if (z = C(z, J),
        z === 0 && J.ended)
            return J.length === 0 && at(this),
            null;
        let Re = (J.state & Y) !== 0;
        if (S("need readable", Re),
        (J.length === 0 || J.length - z < J.highWaterMark) && (Re = !0,
        S("length less than watermark", Re)),
        J.ended || J.reading || J.destroyed || J.errored || !J.constructed)
            Re = !1,
            S("reading, ended or constructing", Re);
        else if (Re) {
            S("do read"),
            J.state |= me | G,
            J.length === 0 && (J.state |= Y);
            try {
                this._read(J.highWaterMark)
            } catch (_t) {
                I(this, _t)
            }
            J.state &= ~G,
            J.reading || (z = C(Ae, J))
        }
        let Me;
        return z > 0 ? Me = st(z, J) : Me = null,
        Me === null ? (J.needReadable = J.length <= J.highWaterMark,
        z = 0) : (J.length -= z,
        J.multiAwaitDrain ? J.awaitDrainWriters.clear() : J.awaitDrainWriters = null),
        J.length === 0 && (J.ended || (J.needReadable = !0),
        Ae !== z && J.ended && at(this)),
        Me !== null && !J.errorEmitted && !J.closeEmitted && (J.dataEmitted = !0,
        this.emit("data", Me)),
        Me
    }
    ;
    function v(z, J) {
        if (S("onEofChunk"),
        !J.ended) {
            if (J.decoder) {
                const Ae = J.decoder.end();
                Ae && Ae.length && (J.buffer.push(Ae),
                J.length += J.objectMode ? 1 : Ae.length)
            }
            J.ended = !0,
            J.sync ? w(z) : (J.needReadable = !1,
            J.emittedReadable = !0,
            H(z))
        }
    }
    function w(z) {
        const J = z._readableState;
        S("emitReadable", J.needReadable, J.emittedReadable),
        J.needReadable = !1,
        J.emittedReadable || (S("emitReadable", J.flowing),
        J.emittedReadable = !0,
        i.nextTick(H, z))
    }
    function H(z) {
        const J = z._readableState;
        S("emitReadable_", J.destroyed, J.length, J.ended),
        !J.destroyed && !J.errored && (J.length || J.ended) && (z.emit("readable"),
        J.emittedReadable = !1),
        J.needReadable = !J.flowing && !J.ended && J.length <= J.highWaterMark,
        Ze(z)
    }
    function re(z, J) {
        !J.readingMore && J.constructed && (J.readingMore = !0,
        i.nextTick(_e, z, J))
    }
    function _e(z, J) {
        for (; !J.reading && !J.ended && (J.length < J.highWaterMark || J.flowing && J.length === 0); ) {
            const Ae = J.length;
            if (S("maybeReadMore read 0"),
            z.read(0),
            Ae === J.length)
                break
        }
        J.readingMore = !1
    }
    ve.prototype._read = function(z) {
        throw new D("_read()")
    }
    ,
    ve.prototype.pipe = function(z, J) {
        const Ae = this
          , Re = this._readableState;
        Re.pipes.length === 1 && (Re.multiAwaitDrain || (Re.multiAwaitDrain = !0,
        Re.awaitDrainWriters = new h(Re.awaitDrainWriters ? [Re.awaitDrainWriters] : []))),
        Re.pipes.push(z),
        S("pipe count=%d opts=%j", Re.pipes.length, J);
        const _t = (!J || J.end !== !1) && z !== i.stdout && z !== i.stderr ? Nt : V;
        Re.endEmitted ? i.nextTick(_t) : Ae.once("end", _t),
        z.on("unpipe", bt);
        function bt(de, pe) {
            S("onunpipe"),
            de === Ae && pe && pe.hasUnpiped === !1 && (pe.hasUnpiped = !0,
            Ut())
        }
        function Nt() {
            S("onend"),
            z.end()
        }
        let Pe, Xn = !1;
        function Ut() {
            S("cleanup"),
            z.removeListener("close", Dn),
            z.removeListener("finish", it),
            Pe && z.removeListener("drain", Pe),
            z.removeListener("error", dn),
            z.removeListener("unpipe", bt),
            Ae.removeListener("end", Nt),
            Ae.removeListener("end", V),
            Ae.removeListener("data", bn),
            Xn = !0,
            Pe && Re.awaitDrainWriters && (!z._writableState || z._writableState.needDrain) && Pe()
        }
        function Mn() {
            Xn || (Re.pipes.length === 1 && Re.pipes[0] === z ? (S("false write response, pause", 0),
            Re.awaitDrainWriters = z,
            Re.multiAwaitDrain = !1) : Re.pipes.length > 1 && Re.pipes.includes(z) && (S("false write response, pause", Re.awaitDrainWriters.size),
            Re.awaitDrainWriters.add(z)),
            Ae.pause()),
            Pe || (Pe = we(Ae, z),
            z.on("drain", Pe))
        }
        Ae.on("data", bn);
        function bn(de) {
            S("ondata");
            const pe = z.write(de);
            S("dest.write", pe),
            pe === !1 && Mn()
        }
        function dn(de) {
            if (S("onerror", de),
            V(),
            z.removeListener("error", dn),
            z.listenerCount("error") === 0) {
                const pe = z._writableState || z._readableState;
                pe && !pe.errorEmitted ? I(z, de) : z.emit("error", de)
            }
        }
        T(z, "error", dn);
        function Dn() {
            z.removeListener("finish", it),
            V()
        }
        z.once("close", Dn);
        function it() {
            S("onfinish"),
            z.removeListener("close", Dn),
            V()
        }
        z.once("finish", it);
        function V() {
            S("unpipe"),
            Ae.unpipe(z)
        }
        return z.emit("pipe", Ae),
        z.writableNeedDrain === !0 ? Mn() : Re.flowing || (S("pipe resume"),
        Ae.resume()),
        z
    }
    ;
    function we(z, J) {
        return function() {
            const Re = z._readableState;
            Re.awaitDrainWriters === J ? (S("pipeOnDrain", 1),
            Re.awaitDrainWriters = null) : Re.multiAwaitDrain && (S("pipeOnDrain", Re.awaitDrainWriters.size),
            Re.awaitDrainWriters.delete(J)),
            (!Re.awaitDrainWriters || Re.awaitDrainWriters.size === 0) && z.listenerCount("data") && z.resume()
        }
    }
    ve.prototype.unpipe = function(z) {
        const J = this._readableState
          , Ae = {
            hasUnpiped: !1
        };
        if (J.pipes.length === 0)
            return this;
        if (!z) {
            const Me = J.pipes;
            J.pipes = [],
            this.pause();
            for (let _t = 0; _t < Me.length; _t++)
                Me[_t].emit("unpipe", this, {
                    hasUnpiped: !1
                });
            return this
        }
        const Re = e(J.pipes, z);
        return Re === -1 ? this : (J.pipes.splice(Re, 1),
        J.pipes.length === 0 && this.pause(),
        z.emit("unpipe", this, Ae),
        this)
    }
    ,
    ve.prototype.on = function(z, J) {
        const Ae = b.prototype.on.call(this, z, J)
          , Re = this._readableState;
        return z === "data" ? (Re.readableListening = this.listenerCount("readable") > 0,
        Re.flowing !== !1 && this.resume()) : z === "readable" && !Re.endEmitted && !Re.readableListening && (Re.readableListening = Re.needReadable = !0,
        Re.flowing = !1,
        Re.emittedReadable = !1,
        S("on readable", Re.length, Re.reading),
        Re.length ? w(this) : Re.reading || i.nextTick(Ye, this)),
        Ae
    }
    ,
    ve.prototype.addListener = ve.prototype.on,
    ve.prototype.removeListener = function(z, J) {
        const Ae = b.prototype.removeListener.call(this, z, J);
        return z === "readable" && i.nextTick(Oe, this),
        Ae
    }
    ,
    ve.prototype.off = ve.prototype.removeListener,
    ve.prototype.removeAllListeners = function(z) {
        const J = b.prototype.removeAllListeners.apply(this, arguments);
        return (z === "readable" || z === void 0) && i.nextTick(Oe, this),
        J
    }
    ;
    function Oe(z) {
        const J = z._readableState;
        J.readableListening = z.listenerCount("readable") > 0,
        J.resumeScheduled && J[P] === !1 ? J.flowing = !0 : z.listenerCount("data") > 0 ? z.resume() : J.readableListening || (J.flowing = null)
    }
    function Ye(z) {
        S("readable nexttick read 0"),
        z.read(0)
    }
    ve.prototype.resume = function() {
        const z = this._readableState;
        return z.flowing || (S("resume"),
        z.flowing = !z.readableListening,
        Qe(this, z)),
        z[P] = !1,
        this
    }
    ;
    function Qe(z, J) {
        J.resumeScheduled || (J.resumeScheduled = !0,
        i.nextTick(We, z, J))
    }
    function We(z, J) {
        S("resume", J.reading),
        J.reading || z.read(0),
        J.resumeScheduled = !1,
        z.emit("resume"),
        Ze(z),
        J.flowing && !J.reading && z.read(0)
    }
    ve.prototype.pause = function() {
        return S("call pause flowing=%j", this._readableState.flowing),
        this._readableState.flowing !== !1 && (S("pause"),
        this._readableState.flowing = !1,
        this.emit("pause")),
        this._readableState[P] = !0,
        this
    }
    ;
    function Ze(z) {
        const J = z._readableState;
        for (S("flow", J.flowing); J.flowing && z.read() !== null; )
            ;
    }
    ve.prototype.wrap = function(z) {
        let J = !1;
        z.on("data", Re=>{
            !this.push(Re) && z.pause && (J = !0,
            z.pause())
        }
        ),
        z.on("end", ()=>{
            this.push(null)
        }
        ),
        z.on("error", Re=>{
            I(this, Re)
        }
        ),
        z.on("close", ()=>{
            this.destroy()
        }
        ),
        z.on("destroy", ()=>{
            this.destroy()
        }
        ),
        this._read = ()=>{
            J && z.resume && (J = !1,
            z.resume())
        }
        ;
        const Ae = l(z);
        for (let Re = 1; Re < Ae.length; Re++) {
            const Me = Ae[Re];
            this[Me] === void 0 && typeof z[Me] == "function" && (this[Me] = z[Me].bind(z))
        }
        return this
    }
    ,
    ve.prototype[_] = function() {
        return Bt(this)
    }
    ,
    ve.prototype.iterator = function(z) {
        return z !== void 0 && ue(z, "options"),
        Bt(this, z)
    }
    ;
    function Bt(z, J) {
        typeof z.read != "function" && (z = ve.wrap(z, {
            objectMode: !0
        }));
        const Ae = Yt(z, J);
        return Ae.stream = z,
        Ae
    }
    async function *Yt(z, J) {
        let Ae = ae;
        function Re(bt) {
            this === z ? (Ae(),
            Ae = ae) : Ae = bt
        }
        z.on("readable", Re);
        let Me;
        const _t = R(z, {
            writable: !1
        }, bt=>{
            Me = bt ? O(Me, bt) : null,
            Ae(),
            Ae = ae
        }
        );
        try {
            for (; ; ) {
                const bt = z.destroyed ? null : z.read();
                if (bt !== null)
                    yield bt;
                else {
                    if (Me)
                        throw Me;
                    if (Me === null)
                        return;
                    await new f(Re)
                }
            }
        } catch (bt) {
            throw Me = O(Me, bt),
            Me
        } finally {
            (Me || J?.destroyOnReturn !== !1) && (Me === void 0 || z._readableState.autoDestroy) ? x.destroyer(z, null) : (z.off("readable", Re),
            _t())
        }
    }
    a(ve.prototype, {
        readable: {
            __proto__: null,
            get() {
                const z = this._readableState;
                return !!z && z.readable !== !1 && !z.destroyed && !z.errorEmitted && !z.endEmitted
            },
            set(z) {
                this._readableState && (this._readableState.readable = !!z)
            }
        },
        readableDidRead: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.dataEmitted
            }
        },
        readableAborted: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return !!(this._readableState.readable !== !1 && (this._readableState.destroyed || this._readableState.errored) && !this._readableState.endEmitted)
            }
        },
        readableHighWaterMark: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.highWaterMark
            }
        },
        readableBuffer: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState && this._readableState.buffer
            }
        },
        readableFlowing: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return this._readableState.flowing
            },
            set: function(z) {
                this._readableState && (this._readableState.flowing = z)
            }
        },
        readableLength: {
            __proto__: null,
            enumerable: !1,
            get() {
                return this._readableState.length
            }
        },
        readableObjectMode: {
            __proto__: null,
            enumerable: !1,
            get() {
                return this._readableState ? this._readableState.objectMode : !1
            }
        },
        readableEncoding: {
            __proto__: null,
            enumerable: !1,
            get() {
                return this._readableState ? this._readableState.encoding : null
            }
        },
        errored: {
            __proto__: null,
            enumerable: !1,
            get() {
                return this._readableState ? this._readableState.errored : null
            }
        },
        closed: {
            __proto__: null,
            get() {
                return this._readableState ? this._readableState.closed : !1
            }
        },
        destroyed: {
            __proto__: null,
            enumerable: !1,
            get() {
                return this._readableState ? this._readableState.destroyed : !1
            },
            set(z) {
                this._readableState && (this._readableState.destroyed = z)
            }
        },
        readableEnded: {
            __proto__: null,
            enumerable: !1,
            get() {
                return this._readableState ? this._readableState.endEmitted : !1
            }
        }
    }),
    a(Ne.prototype, {
        pipesCount: {
            __proto__: null,
            get() {
                return this.pipes.length
            }
        },
        paused: {
            __proto__: null,
            get() {
                return this[P] !== !1
            },
            set(z) {
                this[P] = !!z
            }
        }
    }),
    ve._fromList = st;
    function st(z, J) {
        if (J.length === 0)
            return null;
        let Ae;
        return J.objectMode ? Ae = J.buffer.shift() : !z || z >= J.length ? (J.decoder ? Ae = J.buffer.join("") : J.buffer.length === 1 ? Ae = J.buffer.first() : Ae = J.buffer.concat(J.length),
        J.buffer.clear()) : Ae = J.buffer.consume(z, J.decoder),
        Ae
    }
    function at(z) {
        const J = z._readableState;
        S("endReadable", J.endEmitted),
        J.endEmitted || (J.ended = !0,
        i.nextTick(Si, J, z))
    }
    function Si(z, J) {
        if (S("endReadableNT", z.endEmitted, z.length),
        !z.errored && !z.closeEmitted && !z.endEmitted && z.length === 0) {
            if (z.endEmitted = !0,
            J.emit("end"),
            J.writable && J.allowHalfOpen === !1)
                i.nextTick(cn, J);
            else if (z.autoDestroy) {
                const Ae = J._writableState;
                (!Ae || Ae.autoDestroy && (Ae.finished || Ae.writable === !1)) && J.destroy()
            }
        }
    }
    function cn(z) {
        z.writable && !z.writableEnded && !z.destroyed && z.end()
    }
    ve.from = function(z, J) {
        return j(ve, z, J)
    }
    ;
    let Pn;
    function Zn() {
        return Pn === void 0 && (Pn = {}),
        Pn
    }
    return ve.fromWeb = function(z, J) {
        return Zn().newStreamReadableFromReadableStream(z, J)
    }
    ,
    ve.toWeb = function(z, J) {
        return Zn().newReadableStreamFromStreamReadable(z, J)
    }
    ,
    ve.wrap = function(z, J) {
        var Ae, Re;
        return new ve({
            objectMode: (Ae = (Re = z.readableObjectMode) !== null && Re !== void 0 ? Re : z.objectMode) !== null && Ae !== void 0 ? Ae : !0,
            ...J,
            destroy(Me, _t) {
                x.destroyer(z, Me),
                _t(Me)
            }
        }).wrap(z)
    }
    ,
    Xo
}
var Qo, Ic;
function Pl() {
    if (Ic)
        return Qo;
    Ic = 1;
    const i = xi()
      , {ArrayPrototypeSlice: e, Error: n, FunctionPrototypeSymbolHasInstance: r, ObjectDefineProperty: o, ObjectDefineProperties: a, ObjectSetPrototypeOf: l, StringPrototypeToLowerCase: u, Symbol: f, SymbolHasInstance: h} = ct();
    Qo = ue,
    ue.WritableState = F;
    const {EventEmitter: m} = Hs()
      , _ = kl().Stream
      , {Buffer: d} = Rn()
      , g = Gi()
      , {addAbortSignal: b} = Vs()
      , {getHighWaterMark: T, getDefaultHighWaterMark: N} = Gs()
      , {ERR_INVALID_ARG_TYPE: A, ERR_METHOD_NOT_IMPLEMENTED: R, ERR_MULTIPLE_CALLBACK: S, ERR_STREAM_CANNOT_PIPE: y, ERR_STREAM_DESTROYED: x, ERR_STREAM_ALREADY_FINISHED: M, ERR_STREAM_NULL_VALUES: U, ERR_STREAM_WRITE_AFTER_END: O, ERR_UNKNOWN_ENCODING: Q} = kt().codes
      , {errorOrDestroy: D} = g;
    l(ue.prototype, _.prototype),
    l(ue, _);
    function $() {}
    const X = f("kOnFinished");
    function F(q, te, fe) {
        typeof fe != "boolean" && (fe = te instanceof In()),
        this.objectMode = !!(q && q.objectMode),
        fe && (this.objectMode = this.objectMode || !!(q && q.writableObjectMode)),
        this.highWaterMark = q ? T(this, q, "writableHighWaterMark", fe) : N(!1),
        this.finalCalled = !1,
        this.needDrain = !1,
        this.ending = !1,
        this.ended = !1,
        this.finished = !1,
        this.destroyed = !1;
        const xe = !!(q && q.decodeStrings === !1);
        this.decodeStrings = !xe,
        this.defaultEncoding = q && q.defaultEncoding || "utf8",
        this.length = 0,
        this.writing = !1,
        this.corked = 0,
        this.sync = !0,
        this.bufferProcessing = !1,
        this.onwrite = I.bind(void 0, te),
        this.writecb = null,
        this.writelen = 0,
        this.afterWriteTickInfo = null,
        B(this),
        this.pendingcb = 0,
        this.constructed = !0,
        this.prefinished = !1,
        this.errorEmitted = !1,
        this.emitClose = !q || q.emitClose !== !1,
        this.autoDestroy = !q || q.autoDestroy !== !1,
        this.errored = null,
        this.closed = !1,
        this.closeEmitted = !1,
        this[X] = []
    }
    function B(q) {
        q.buffered = [],
        q.bufferedIndex = 0,
        q.allBuffers = !0,
        q.allNoop = !0
    }
    F.prototype.getBuffer = function() {
        return e(this.buffered, this.bufferedIndex)
    }
    ,
    o(F.prototype, "bufferedRequestCount", {
        __proto__: null,
        get() {
            return this.buffered.length - this.bufferedIndex
        }
    });
    function ue(q) {
        const te = this instanceof In();
        if (!te && !r(ue, this))
            return new ue(q);
        this._writableState = new F(q,this,te),
        q && (typeof q.write == "function" && (this._write = q.write),
        typeof q.writev == "function" && (this._writev = q.writev),
        typeof q.destroy == "function" && (this._destroy = q.destroy),
        typeof q.final == "function" && (this._final = q.final),
        typeof q.construct == "function" && (this._construct = q.construct),
        q.signal && b(q.signal, this)),
        _.call(this, q),
        g.construct(this, ()=>{
            const fe = this._writableState;
            fe.writing || me(this, fe),
            K(this, fe)
        }
        )
    }
    o(ue, h, {
        __proto__: null,
        value: function(q) {
            return r(this, q) ? !0 : this !== ue ? !1 : q && q._writableState instanceof F
        }
    }),
    ue.prototype.pipe = function() {
        D(this, new y)
    }
    ;
    function P(q, te, fe, xe) {
        const Se = q._writableState;
        if (typeof fe == "function")
            xe = fe,
            fe = Se.defaultEncoding;
        else {
            if (!fe)
                fe = Se.defaultEncoding;
            else if (fe !== "buffer" && !d.isEncoding(fe))
                throw new Q(fe);
            typeof xe != "function" && (xe = $)
        }
        if (te === null)
            throw new U;
        if (!Se.objectMode)
            if (typeof te == "string")
                Se.decodeStrings !== !1 && (te = d.from(te, fe),
                fe = "buffer");
            else if (te instanceof d)
                fe = "buffer";
            else if (_._isUint8Array(te))
                te = _._uint8ArrayToBuffer(te),
                fe = "buffer";
            else
                throw new A("chunk",["string", "Buffer", "Uint8Array"],te);
        let Ie;
        return Se.ending ? Ie = new O : Se.destroyed && (Ie = new x("write")),
        Ie ? (i.nextTick(xe, Ie),
        D(q, Ie, !0),
        Ie) : (Se.pendingcb++,
        oe(q, Se, te, fe, xe))
    }
    ue.prototype.write = function(q, te, fe) {
        return P(this, q, te, fe) === !0
    }
    ,
    ue.prototype.cork = function() {
        this._writableState.corked++
    }
    ,
    ue.prototype.uncork = function() {
        const q = this._writableState;
        q.corked && (q.corked--,
        q.writing || me(this, q))
    }
    ,
    ue.prototype.setDefaultEncoding = function(te) {
        if (typeof te == "string" && (te = u(te)),
        !d.isEncoding(te))
            throw new Q(te);
        return this._writableState.defaultEncoding = te,
        this
    }
    ;
    function oe(q, te, fe, xe, Se) {
        const Ie = te.objectMode ? 1 : fe.length;
        te.length += Ie;
        const se = te.length < te.highWaterMark;
        return se || (te.needDrain = !0),
        te.writing || te.corked || te.errored || !te.constructed ? (te.buffered.push({
            chunk: fe,
            encoding: xe,
            callback: Se
        }),
        te.allBuffers && xe !== "buffer" && (te.allBuffers = !1),
        te.allNoop && Se !== $ && (te.allNoop = !1)) : (te.writelen = Ie,
        te.writecb = Se,
        te.writing = !0,
        te.sync = !0,
        q._write(fe, xe, te.onwrite),
        te.sync = !1),
        se && !te.errored && !te.destroyed
    }
    function j(q, te, fe, xe, Se, Ie, se) {
        te.writelen = xe,
        te.writecb = se,
        te.writing = !0,
        te.sync = !0,
        te.destroyed ? te.onwrite(new x("write")) : fe ? q._writev(Se, te.onwrite) : q._write(Se, Ie, te.onwrite),
        te.sync = !1
    }
    function ae(q, te, fe, xe) {
        --te.pendingcb,
        xe(fe),
        ee(te),
        D(q, fe)
    }
    function I(q, te) {
        const fe = q._writableState
          , xe = fe.sync
          , Se = fe.writecb;
        if (typeof Se != "function") {
            D(q, new S);
            return
        }
        fe.writing = !1,
        fe.writecb = null,
        fe.length -= fe.writelen,
        fe.writelen = 0,
        te ? (te.stack,
        fe.errored || (fe.errored = te),
        q._readableState && !q._readableState.errored && (q._readableState.errored = te),
        xe ? i.nextTick(ae, q, fe, te, Se) : ae(q, fe, te, Se)) : (fe.buffered.length > fe.bufferedIndex && me(q, fe),
        xe ? fe.afterWriteTickInfo !== null && fe.afterWriteTickInfo.cb === Se ? fe.afterWriteTickInfo.count++ : (fe.afterWriteTickInfo = {
            count: 1,
            cb: Se,
            stream: q,
            state: fe
        },
        i.nextTick(Z, fe.afterWriteTickInfo)) : ie(q, fe, 1, Se))
    }
    function Z({stream: q, state: te, count: fe, cb: xe}) {
        return te.afterWriteTickInfo = null,
        ie(q, te, fe, xe)
    }
    function ie(q, te, fe, xe) {
        for (!te.ending && !q.destroyed && te.length === 0 && te.needDrain && (te.needDrain = !1,
        q.emit("drain")); fe-- > 0; )
            te.pendingcb--,
            xe();
        te.destroyed && ee(te),
        K(q, te)
    }
    function ee(q) {
        if (q.writing)
            return;
        for (let Se = q.bufferedIndex; Se < q.buffered.length; ++Se) {
            var te;
            const {chunk: Ie, callback: se} = q.buffered[Se]
              , be = q.objectMode ? 1 : Ie.length;
            q.length -= be,
            se((te = q.errored) !== null && te !== void 0 ? te : new x("write"))
        }
        const fe = q[X].splice(0);
        for (let Se = 0; Se < fe.length; Se++) {
            var xe;
            fe[Se]((xe = q.errored) !== null && xe !== void 0 ? xe : new x("end"))
        }
        B(q)
    }
    function me(q, te) {
        if (te.corked || te.bufferProcessing || te.destroyed || !te.constructed)
            return;
        const {buffered: fe, bufferedIndex: xe, objectMode: Se} = te
          , Ie = fe.length - xe;
        if (!Ie)
            return;
        let se = xe;
        if (te.bufferProcessing = !0,
        Ie > 1 && q._writev) {
            te.pendingcb -= Ie - 1;
            const be = te.allNoop ? $ : ve=>{
                for (let $e = se; $e < fe.length; ++$e)
                    fe[$e].callback(ve)
            }
              , Ne = te.allNoop && se === 0 ? fe : e(fe, se);
            Ne.allBuffers = te.allBuffers,
            j(q, te, !0, te.length, Ne, "", be),
            B(te)
        } else {
            do {
                const {chunk: be, encoding: Ne, callback: ve} = fe[se];
                fe[se++] = null;
                const $e = Se ? 1 : be.length;
                j(q, te, !1, $e, be, Ne, ve)
            } while (se < fe.length && !te.writing);
            se === fe.length ? B(te) : se > 256 ? (fe.splice(0, se),
            te.bufferedIndex = 0) : te.bufferedIndex = se
        }
        te.bufferProcessing = !1
    }
    ue.prototype._write = function(q, te, fe) {
        if (this._writev)
            this._writev([{
                chunk: q,
                encoding: te
            }], fe);
        else
            throw new R("_write()")
    }
    ,
    ue.prototype._writev = null,
    ue.prototype.end = function(q, te, fe) {
        const xe = this._writableState;
        typeof q == "function" ? (fe = q,
        q = null,
        te = null) : typeof te == "function" && (fe = te,
        te = null);
        let Se;
        if (q != null) {
            const Ie = P(this, q, te);
            Ie instanceof n && (Se = Ie)
        }
        return xe.corked && (xe.corked = 1,
        this.uncork()),
        Se || (!xe.errored && !xe.ending ? (xe.ending = !0,
        K(this, xe, !0),
        xe.ended = !0) : xe.finished ? Se = new M("end") : xe.destroyed && (Se = new x("end"))),
        typeof fe == "function" && (Se || xe.finished ? i.nextTick(fe, Se) : xe[X].push(fe)),
        this
    }
    ;
    function W(q) {
        return q.ending && !q.destroyed && q.constructed && q.length === 0 && !q.errored && q.buffered.length === 0 && !q.finished && !q.writing && !q.errorEmitted && !q.closeEmitted
    }
    function G(q, te) {
        let fe = !1;
        function xe(Se) {
            if (fe) {
                D(q, Se ?? S());
                return
            }
            if (fe = !0,
            te.pendingcb--,
            Se) {
                const Ie = te[X].splice(0);
                for (let se = 0; se < Ie.length; se++)
                    Ie[se](Se);
                D(q, Se, te.sync)
            } else
                W(te) && (te.prefinished = !0,
                q.emit("prefinish"),
                te.pendingcb++,
                i.nextTick(le, q, te))
        }
        te.sync = !0,
        te.pendingcb++;
        try {
            q._final(xe)
        } catch (Se) {
            xe(Se)
        }
        te.sync = !1
    }
    function Y(q, te) {
        !te.prefinished && !te.finalCalled && (typeof q._final == "function" && !te.destroyed ? (te.finalCalled = !0,
        G(q, te)) : (te.prefinished = !0,
        q.emit("prefinish")))
    }
    function K(q, te, fe) {
        W(te) && (Y(q, te),
        te.pendingcb === 0 && (fe ? (te.pendingcb++,
        i.nextTick((xe,Se)=>{
            W(Se) ? le(xe, Se) : Se.pendingcb--
        }
        , q, te)) : W(te) && (te.pendingcb++,
        le(q, te))))
    }
    function le(q, te) {
        te.pendingcb--,
        te.finished = !0;
        const fe = te[X].splice(0);
        for (let xe = 0; xe < fe.length; xe++)
            fe[xe]();
        if (q.emit("finish"),
        te.autoDestroy) {
            const xe = q._readableState;
            (!xe || xe.autoDestroy && (xe.endEmitted || xe.readable === !1)) && q.destroy()
        }
    }
    a(ue.prototype, {
        closed: {
            __proto__: null,
            get() {
                return this._writableState ? this._writableState.closed : !1
            }
        },
        destroyed: {
            __proto__: null,
            get() {
                return this._writableState ? this._writableState.destroyed : !1
            },
            set(q) {
                this._writableState && (this._writableState.destroyed = q)
            }
        },
        writable: {
            __proto__: null,
            get() {
                const q = this._writableState;
                return !!q && q.writable !== !1 && !q.destroyed && !q.errored && !q.ending && !q.ended
            },
            set(q) {
                this._writableState && (this._writableState.writable = !!q)
            }
        },
        writableFinished: {
            __proto__: null,
            get() {
                return this._writableState ? this._writableState.finished : !1
            }
        },
        writableObjectMode: {
            __proto__: null,
            get() {
                return this._writableState ? this._writableState.objectMode : !1
            }
        },
        writableBuffer: {
            __proto__: null,
            get() {
                return this._writableState && this._writableState.getBuffer()
            }
        },
        writableEnded: {
            __proto__: null,
            get() {
                return this._writableState ? this._writableState.ending : !1
            }
        },
        writableNeedDrain: {
            __proto__: null,
            get() {
                const q = this._writableState;
                return q ? !q.destroyed && !q.ending && q.needDrain : !1
            }
        },
        writableHighWaterMark: {
            __proto__: null,
            get() {
                return this._writableState && this._writableState.highWaterMark
            }
        },
        writableCorked: {
            __proto__: null,
            get() {
                return this._writableState ? this._writableState.corked : 0
            }
        },
        writableLength: {
            __proto__: null,
            get() {
                return this._writableState && this._writableState.length
            }
        },
        errored: {
            __proto__: null,
            enumerable: !1,
            get() {
                return this._writableState ? this._writableState.errored : null
            }
        },
        writableAborted: {
            __proto__: null,
            enumerable: !1,
            get: function() {
                return !!(this._writableState.writable !== !1 && (this._writableState.destroyed || this._writableState.errored) && !this._writableState.finished)
            }
        }
    });
    const ce = g.destroy;
    ue.prototype.destroy = function(q, te) {
        const fe = this._writableState;
        return !fe.destroyed && (fe.bufferedIndex < fe.buffered.length || fe[X].length) && i.nextTick(ee, fe),
        ce.call(this, q, te),
        this
    }
    ,
    ue.prototype._undestroy = g.undestroy,
    ue.prototype._destroy = function(q, te) {
        te(q)
    }
    ,
    ue.prototype[m.captureRejectionSymbol] = function(q) {
        this.destroy(q)
    }
    ;
    let Ee;
    function Te() {
        return Ee === void 0 && (Ee = {}),
        Ee
    }
    return ue.fromWeb = function(q, te) {
        return Te().newStreamWritableFromWritableStream(q, te)
    }
    ,
    ue.toWeb = function(q) {
        return Te().newWritableStreamFromStreamWritable(q)
    }
    ,
    Qo
}
var Jo, Nc;
function Bg() {
    if (Nc)
        return Jo;
    Nc = 1;
    const i = xi()
      , e = Rn()
      , {isReadable: n, isWritable: r, isIterable: o, isNodeStream: a, isReadableNodeStream: l, isWritableNodeStream: u, isDuplexNodeStream: f, isReadableStream: h, isWritableStream: m} = Cn()
      , _ = Vn()
      , {AbortError: d, codes: {ERR_INVALID_ARG_TYPE: g, ERR_INVALID_RETURN_VALUE: b}} = kt()
      , {destroyer: T} = Gi()
      , N = In()
      , A = Ws()
      , R = Pl()
      , {createDeferredPromise: S} = Ot()
      , y = df()
      , x = globalThis.Blob || e.Blob
      , M = typeof x < "u" ? function(F) {
        return F instanceof x
    }
    : function(F) {
        return !1
    }
      , U = globalThis.AbortController || Br().AbortController
      , {FunctionPrototypeCall: O} = ct();
    class Q extends N {
        constructor(F) {
            super(F),
            F?.readable === !1 && (this._readableState.readable = !1,
            this._readableState.ended = !0,
            this._readableState.endEmitted = !0),
            F?.writable === !1 && (this._writableState.writable = !1,
            this._writableState.ending = !0,
            this._writableState.ended = !0,
            this._writableState.finished = !0)
        }
    }
    Jo = function X(F, B) {
        if (f(F))
            return F;
        if (l(F))
            return $({
                readable: F
            });
        if (u(F))
            return $({
                writable: F
            });
        if (a(F))
            return $({
                writable: !1,
                readable: !1
            });
        if (h(F))
            return $({
                readable: A.fromWeb(F)
            });
        if (m(F))
            return $({
                writable: R.fromWeb(F)
            });
        if (typeof F == "function") {
            const {value: P, write: oe, final: j, destroy: ae} = D(F);
            if (o(P))
                return y(Q, P, {
                    objectMode: !0,
                    write: oe,
                    final: j,
                    destroy: ae
                });
            const I = P?.then;
            if (typeof I == "function") {
                let Z;
                const ie = O(I, P, ee=>{
                    if (ee != null)
                        throw new b("nully","body",ee)
                }
                , ee=>{
                    T(Z, ee)
                }
                );
                return Z = new Q({
                    objectMode: !0,
                    readable: !1,
                    write: oe,
                    final(ee) {
                        j(async()=>{
                            try {
                                await ie,
                                i.nextTick(ee, null)
                            } catch (me) {
                                i.nextTick(ee, me)
                            }
                        }
                        )
                    },
                    destroy: ae
                })
            }
            throw new b("Iterable, AsyncIterable or AsyncFunction",B,P)
        }
        if (M(F))
            return X(F.arrayBuffer());
        if (o(F))
            return y(Q, F, {
                objectMode: !0,
                writable: !1
            });
        if (h(F?.readable) && m(F?.writable))
            return Q.fromWeb(F);
        if (typeof F?.writable == "object" || typeof F?.readable == "object") {
            const P = F != null && F.readable ? l(F?.readable) ? F?.readable : X(F.readable) : void 0
              , oe = F != null && F.writable ? u(F?.writable) ? F?.writable : X(F.writable) : void 0;
            return $({
                readable: P,
                writable: oe
            })
        }
        const ue = F?.then;
        if (typeof ue == "function") {
            let P;
            return O(ue, F, oe=>{
                oe != null && P.push(oe),
                P.push(null)
            }
            , oe=>{
                T(P, oe)
            }
            ),
            P = new Q({
                objectMode: !0,
                writable: !1,
                read() {}
            })
        }
        throw new g(B,["Blob", "ReadableStream", "WritableStream", "Stream", "Iterable", "AsyncIterable", "Function", "{ readable, writable } pair", "Promise"],F)
    }
    ;
    function D(X) {
        let {promise: F, resolve: B} = S();
        const ue = new U
          , P = ue.signal;
        return {
            value: X((async function*() {
                for (; ; ) {
                    const j = F;
                    F = null;
                    const {chunk: ae, done: I, cb: Z} = await j;
                    if (i.nextTick(Z),
                    I)
                        return;
                    if (P.aborted)
                        throw new d(void 0,{
                            cause: P.reason
                        });
                    ({promise: F, resolve: B} = S()),
                    yield ae
                }
            }
            )(), {
                signal: P
            }),
            write(j, ae, I) {
                const Z = B;
                B = null,
                Z({
                    chunk: j,
                    done: !1,
                    cb: I
                })
            },
            final(j) {
                const ae = B;
                B = null,
                ae({
                    done: !0,
                    cb: j
                })
            },
            destroy(j, ae) {
                ue.abort(),
                ae(j)
            }
        }
    }
    function $(X) {
        const F = X.readable && typeof X.readable.read != "function" ? A.wrap(X.readable) : X.readable
          , B = X.writable;
        let ue = !!n(F), P = !!r(B), oe, j, ae, I, Z;
        function ie(ee) {
            const me = I;
            I = null,
            me ? me(ee) : ee && Z.destroy(ee)
        }
        return Z = new Q({
            readableObjectMode: !!(F != null && F.readableObjectMode),
            writableObjectMode: !!(B != null && B.writableObjectMode),
            readable: ue,
            writable: P
        }),
        P && (_(B, ee=>{
            P = !1,
            ee && T(F, ee),
            ie(ee)
        }
        ),
        Z._write = function(ee, me, W) {
            B.write(ee, me) ? W() : oe = W
        }
        ,
        Z._final = function(ee) {
            B.end(),
            j = ee
        }
        ,
        B.on("drain", function() {
            if (oe) {
                const ee = oe;
                oe = null,
                ee()
            }
        }),
        B.on("finish", function() {
            if (j) {
                const ee = j;
                j = null,
                ee()
            }
        })),
        ue && (_(F, ee=>{
            ue = !1,
            ee && T(F, ee),
            ie(ee)
        }
        ),
        F.on("readable", function() {
            if (ae) {
                const ee = ae;
                ae = null,
                ee()
            }
        }),
        F.on("end", function() {
            Z.push(null)
        }),
        Z._read = function() {
            for (; ; ) {
                const ee = F.read();
                if (ee === null) {
                    ae = Z._read;
                    return
                }
                if (!Z.push(ee))
                    return
            }
        }
        ),
        Z._destroy = function(ee, me) {
            !ee && I !== null && (ee = new d),
            ae = null,
            oe = null,
            j = null,
            I === null ? me(ee) : (I = me,
            T(B, ee),
            T(F, ee))
        }
        ,
        Z
    }
    return Jo
}
var Ko, Ac;
function In() {
    if (Ac)
        return Ko;
    Ac = 1;
    const {ObjectDefineProperties: i, ObjectGetOwnPropertyDescriptor: e, ObjectKeys: n, ObjectSetPrototypeOf: r} = ct();
    Ko = l;
    const o = Ws()
      , a = Pl();
    r(l.prototype, o.prototype),
    r(l, o);
    {
        const m = n(a.prototype);
        for (let _ = 0; _ < m.length; _++) {
            const d = m[_];
            l.prototype[d] || (l.prototype[d] = a.prototype[d])
        }
    }
    function l(m) {
        if (!(this instanceof l))
            return new l(m);
        o.call(this, m),
        a.call(this, m),
        m ? (this.allowHalfOpen = m.allowHalfOpen !== !1,
        m.readable === !1 && (this._readableState.readable = !1,
        this._readableState.ended = !0,
        this._readableState.endEmitted = !0),
        m.writable === !1 && (this._writableState.writable = !1,
        this._writableState.ending = !0,
        this._writableState.ended = !0,
        this._writableState.finished = !0)) : this.allowHalfOpen = !0
    }
    i(l.prototype, {
        writable: {
            __proto__: null,
            ...e(a.prototype, "writable")
        },
        writableHighWaterMark: {
            __proto__: null,
            ...e(a.prototype, "writableHighWaterMark")
        },
        writableObjectMode: {
            __proto__: null,
            ...e(a.prototype, "writableObjectMode")
        },
        writableBuffer: {
            __proto__: null,
            ...e(a.prototype, "writableBuffer")
        },
        writableLength: {
            __proto__: null,
            ...e(a.prototype, "writableLength")
        },
        writableFinished: {
            __proto__: null,
            ...e(a.prototype, "writableFinished")
        },
        writableCorked: {
            __proto__: null,
            ...e(a.prototype, "writableCorked")
        },
        writableEnded: {
            __proto__: null,
            ...e(a.prototype, "writableEnded")
        },
        writableNeedDrain: {
            __proto__: null,
            ...e(a.prototype, "writableNeedDrain")
        },
        destroyed: {
            __proto__: null,
            get() {
                return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed
            },
            set(m) {
                this._readableState && this._writableState && (this._readableState.destroyed = m,
                this._writableState.destroyed = m)
            }
        }
    });
    let u;
    function f() {
        return u === void 0 && (u = {}),
        u
    }
    l.fromWeb = function(m, _) {
        return f().newStreamDuplexFromReadableWritablePair(m, _)
    }
    ,
    l.toWeb = function(m) {
        return f().newReadableWritablePairFromDuplex(m)
    }
    ;
    let h;
    return l.from = function(m) {
        return h || (h = Bg()),
        h(m, "body")
    }
    ,
    Ko
}
var Yo, Rc;
function hf() {
    if (Rc)
        return Yo;
    Rc = 1;
    const {ObjectSetPrototypeOf: i, Symbol: e} = ct();
    Yo = l;
    const {ERR_METHOD_NOT_IMPLEMENTED: n} = kt().codes
      , r = In()
      , {getHighWaterMark: o} = Gs();
    i(l.prototype, r.prototype),
    i(l, r);
    const a = e("kCallback");
    function l(h) {
        if (!(this instanceof l))
            return new l(h);
        const m = h ? o(this, h, "readableHighWaterMark", !0) : null;
        m === 0 && (h = {
            ...h,
            highWaterMark: null,
            readableHighWaterMark: m,
            writableHighWaterMark: h.writableHighWaterMark || 0
        }),
        r.call(this, h),
        this._readableState.sync = !1,
        this[a] = null,
        h && (typeof h.transform == "function" && (this._transform = h.transform),
        typeof h.flush == "function" && (this._flush = h.flush)),
        this.on("prefinish", f)
    }
    function u(h) {
        typeof this._flush == "function" && !this.destroyed ? this._flush((m,_)=>{
            if (m) {
                h ? h(m) : this.destroy(m);
                return
            }
            _ != null && this.push(_),
            this.push(null),
            h && h()
        }
        ) : (this.push(null),
        h && h())
    }
    function f() {
        this._final !== u && u.call(this)
    }
    return l.prototype._final = u,
    l.prototype._transform = function(h, m, _) {
        throw new n("_transform()")
    }
    ,
    l.prototype._write = function(h, m, _) {
        const d = this._readableState
          , g = this._writableState
          , b = d.length;
        this._transform(h, m, (T,N)=>{
            if (T) {
                _(T);
                return
            }
            N != null && this.push(N),
            g.ended || b === d.length || d.length < d.highWaterMark ? _() : this[a] = _
        }
        )
    }
    ,
    l.prototype._read = function() {
        if (this[a]) {
            const h = this[a];
            this[a] = null,
            h()
        }
    }
    ,
    Yo
}
var ea, Cc;
function ff() {
    if (Cc)
        return ea;
    Cc = 1;
    const {ObjectSetPrototypeOf: i} = ct();
    ea = n;
    const e = hf();
    i(n.prototype, e.prototype),
    i(n, e);
    function n(r) {
        if (!(this instanceof n))
            return new n(r);
        e.call(this, r)
    }
    return n.prototype._transform = function(r, o, a) {
        a(null, r)
    }
    ,
    ea
}
var ta, kc;
function Ml() {
    if (kc)
        return ta;
    kc = 1;
    const i = xi()
      , {ArrayIsArray: e, Promise: n, SymbolAsyncIterator: r, SymbolDispose: o} = ct()
      , a = Vn()
      , {once: l} = Ot()
      , u = Gi()
      , f = In()
      , {aggregateTwoErrors: h, codes: {ERR_INVALID_ARG_TYPE: m, ERR_INVALID_RETURN_VALUE: _, ERR_MISSING_ARGS: d, ERR_STREAM_DESTROYED: g, ERR_STREAM_PREMATURE_CLOSE: b}, AbortError: T} = kt()
      , {validateFunction: N, validateAbortSignal: A} = Vr()
      , {isIterable: R, isReadable: S, isReadableNodeStream: y, isNodeStream: x, isTransformStream: M, isWebStream: U, isReadableStream: O, isReadableFinished: Q} = Cn()
      , D = globalThis.AbortController || Br().AbortController;
    let $, X, F;
    function B(ee, me, W) {
        let G = !1;
        ee.on("close", ()=>{
            G = !0
        }
        );
        const Y = a(ee, {
            readable: me,
            writable: W
        }, K=>{
            G = !K
        }
        );
        return {
            destroy: K=>{
                G || (G = !0,
                u.destroyer(ee, K || new g("pipe")))
            }
            ,
            cleanup: Y
        }
    }
    function ue(ee) {
        return N(ee[ee.length - 1], "streams[stream.length - 1]"),
        ee.pop()
    }
    function P(ee) {
        if (R(ee))
            return ee;
        if (y(ee))
            return oe(ee);
        throw new m("val",["Readable", "Iterable", "AsyncIterable"],ee)
    }
    async function *oe(ee) {
        X || (X = Ws()),
        yield*X.prototype[r].call(ee)
    }
    async function j(ee, me, W, {end: G}) {
        let Y, K = null;
        const le = Te=>{
            if (Te && (Y = Te),
            K) {
                const q = K;
                K = null,
                q()
            }
        }
          , ce = ()=>new n((Te,q)=>{
            Y ? q(Y) : K = ()=>{
                Y ? q(Y) : Te()
            }
        }
        );
        me.on("drain", le);
        const Ee = a(me, {
            readable: !1
        }, le);
        try {
            me.writableNeedDrain && await ce();
            for await(const Te of ee)
                me.write(Te) || await ce();
            G && (me.end(),
            await ce()),
            W()
        } catch (Te) {
            W(Y !== Te ? h(Y, Te) : Te)
        } finally {
            Ee(),
            me.off("drain", le)
        }
    }
    async function ae(ee, me, W, {end: G}) {
        M(me) && (me = me.writable);
        const Y = me.getWriter();
        try {
            for await(const K of ee)
                await Y.ready,
                Y.write(K).catch(()=>{}
                );
            await Y.ready,
            G && await Y.close(),
            W()
        } catch (K) {
            try {
                await Y.abort(K),
                W(K)
            } catch (le) {
                W(le)
            }
        }
    }
    function I(...ee) {
        return Z(ee, l(ue(ee)))
    }
    function Z(ee, me, W) {
        if (ee.length === 1 && e(ee[0]) && (ee = ee[0]),
        ee.length < 2)
            throw new d("streams");
        const G = new D
          , Y = G.signal
          , K = W?.signal
          , le = [];
        A(K, "options.signal");
        function ce() {
            Se(new T)
        }
        F = F || Ot().addAbortListener;
        let Ee;
        K && (Ee = F(K, ce));
        let Te, q;
        const te = [];
        let fe = 0;
        function xe(Ne) {
            Se(Ne, --fe === 0)
        }
        function Se(Ne, ve) {
            var $e;
            if (Ne && (!Te || Te.code === "ERR_STREAM_PREMATURE_CLOSE") && (Te = Ne),
            !(!Te && !ve)) {
                for (; te.length; )
                    te.shift()(Te);
                ($e = Ee) === null || $e === void 0 || $e[o](),
                G.abort(),
                ve && (Te || le.forEach(mt=>mt()),
                i.nextTick(me, Te, q))
            }
        }
        let Ie;
        for (let Ne = 0; Ne < ee.length; Ne++) {
            const ve = ee[Ne]
              , $e = Ne < ee.length - 1
              , mt = Ne > 0
              , Be = $e || W?.end !== !1
              , ft = Ne === ee.length - 1;
            if (x(ve)) {
                let C = function(v) {
                    v && v.name !== "AbortError" && v.code !== "ERR_STREAM_PREMATURE_CLOSE" && xe(v)
                };
                if (Be) {
                    const {destroy: v, cleanup: w} = B(ve, $e, mt);
                    te.push(v),
                    S(ve) && ft && le.push(w)
                }
                ve.on("error", C),
                S(ve) && ft && le.push(()=>{
                    ve.removeListener("error", C)
                }
                )
            }
            if (Ne === 0)
                if (typeof ve == "function") {
                    if (Ie = ve({
                        signal: Y
                    }),
                    !R(Ie))
                        throw new _("Iterable, AsyncIterable or Stream","source",Ie)
                } else
                    R(ve) || y(ve) || M(ve) ? Ie = ve : Ie = f.from(ve);
            else if (typeof ve == "function") {
                if (M(Ie)) {
                    var se;
                    Ie = P((se = Ie) === null || se === void 0 ? void 0 : se.readable)
                } else
                    Ie = P(Ie);
                if (Ie = ve(Ie, {
                    signal: Y
                }),
                $e) {
                    if (!R(Ie, !0))
                        throw new _("AsyncIterable",`transform[${Ne - 1}]`,Ie)
                } else {
                    var be;
                    $ || ($ = ff());
                    const C = new $({
                        objectMode: !0
                    })
                      , v = (be = Ie) === null || be === void 0 ? void 0 : be.then;
                    if (typeof v == "function")
                        fe++,
                        v.call(Ie, re=>{
                            q = re,
                            re != null && C.write(re),
                            Be && C.end(),
                            i.nextTick(xe)
                        }
                        , re=>{
                            C.destroy(re),
                            i.nextTick(xe, re)
                        }
                        );
                    else if (R(Ie, !0))
                        fe++,
                        j(Ie, C, xe, {
                            end: Be
                        });
                    else if (O(Ie) || M(Ie)) {
                        const re = Ie.readable || Ie;
                        fe++,
                        j(re, C, xe, {
                            end: Be
                        })
                    } else
                        throw new _("AsyncIterable or Promise","destination",Ie);
                    Ie = C;
                    const {destroy: w, cleanup: H} = B(Ie, !1, !0);
                    te.push(w),
                    ft && le.push(H)
                }
            } else if (x(ve)) {
                if (y(Ie)) {
                    fe += 2;
                    const C = ie(Ie, ve, xe, {
                        end: Be
                    });
                    S(ve) && ft && le.push(C)
                } else if (M(Ie) || O(Ie)) {
                    const C = Ie.readable || Ie;
                    fe++,
                    j(C, ve, xe, {
                        end: Be
                    })
                } else if (R(Ie))
                    fe++,
                    j(Ie, ve, xe, {
                        end: Be
                    });
                else
                    throw new m("val",["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],Ie);
                Ie = ve
            } else if (U(ve)) {
                if (y(Ie))
                    fe++,
                    ae(P(Ie), ve, xe, {
                        end: Be
                    });
                else if (O(Ie) || R(Ie))
                    fe++,
                    ae(Ie, ve, xe, {
                        end: Be
                    });
                else if (M(Ie))
                    fe++,
                    ae(Ie.readable, ve, xe, {
                        end: Be
                    });
                else
                    throw new m("val",["Readable", "Iterable", "AsyncIterable", "ReadableStream", "TransformStream"],Ie);
                Ie = ve
            } else
                Ie = f.from(ve)
        }
        return (Y != null && Y.aborted || K != null && K.aborted) && i.nextTick(ce),
        Ie
    }
    function ie(ee, me, W, {end: G}) {
        let Y = !1;
        if (me.on("close", ()=>{
            Y || W(new b)
        }
        ),
        ee.pipe(me, {
            end: !1
        }),
        G) {
            let K = function() {
                Y = !0,
                me.end()
            };
            Q(ee) ? i.nextTick(K) : ee.once("end", K)
        } else
            W();
        return a(ee, {
            readable: !0,
            writable: !1
        }, K=>{
            const le = ee._readableState;
            K && K.code === "ERR_STREAM_PREMATURE_CLOSE" && le && le.ended && !le.errored && !le.errorEmitted ? ee.once("end", W).once("error", W) : W(K)
        }
        ),
        a(me, {
            readable: !1,
            writable: !0
        }, W)
    }
    return ta = {
        pipelineImpl: Z,
        pipeline: I
    },
    ta
}
var na, Pc;
function pf() {
    if (Pc)
        return na;
    Pc = 1;
    const {pipeline: i} = Ml()
      , e = In()
      , {destroyer: n} = Gi()
      , {isNodeStream: r, isReadable: o, isWritable: a, isWebStream: l, isTransformStream: u, isWritableStream: f, isReadableStream: h} = Cn()
      , {AbortError: m, codes: {ERR_INVALID_ARG_VALUE: _, ERR_MISSING_ARGS: d}} = kt()
      , g = Vn();
    return na = function(...T) {
        if (T.length === 0)
            throw new d("streams");
        if (T.length === 1)
            return e.from(T[0]);
        const N = [...T];
        if (typeof T[0] == "function" && (T[0] = e.from(T[0])),
        typeof T[T.length - 1] == "function") {
            const $ = T.length - 1;
            T[$] = e.from(T[$])
        }
        for (let $ = 0; $ < T.length; ++$)
            if (!(!r(T[$]) && !l(T[$]))) {
                if ($ < T.length - 1 && !(o(T[$]) || h(T[$]) || u(T[$])))
                    throw new _(`streams[${$}]`,N[$],"must be readable");
                if ($ > 0 && !(a(T[$]) || f(T[$]) || u(T[$])))
                    throw new _(`streams[${$}]`,N[$],"must be writable")
            }
        let A, R, S, y, x;
        function M($) {
            const X = y;
            y = null,
            X ? X($) : $ ? x.destroy($) : !D && !Q && x.destroy()
        }
        const U = T[0]
          , O = i(T, M)
          , Q = !!(a(U) || f(U) || u(U))
          , D = !!(o(O) || h(O) || u(O));
        if (x = new e({
            writableObjectMode: !!(U != null && U.writableObjectMode),
            readableObjectMode: !!(O != null && O.readableObjectMode),
            writable: Q,
            readable: D
        }),
        Q) {
            if (r(U))
                x._write = function(X, F, B) {
                    U.write(X, F) ? B() : A = B
                }
                ,
                x._final = function(X) {
                    U.end(),
                    R = X
                }
                ,
                U.on("drain", function() {
                    if (A) {
                        const X = A;
                        A = null,
                        X()
                    }
                });
            else if (l(U)) {
                const F = (u(U) ? U.writable : U).getWriter();
                x._write = async function(B, ue, P) {
                    try {
                        await F.ready,
                        F.write(B).catch(()=>{}
                        ),
                        P()
                    } catch (oe) {
                        P(oe)
                    }
                }
                ,
                x._final = async function(B) {
                    try {
                        await F.ready,
                        F.close().catch(()=>{}
                        ),
                        R = B
                    } catch (ue) {
                        B(ue)
                    }
                }
            }
            const $ = u(O) ? O.readable : O;
            g($, ()=>{
                if (R) {
                    const X = R;
                    R = null,
                    X()
                }
            }
            )
        }
        if (D) {
            if (r(O))
                O.on("readable", function() {
                    if (S) {
                        const $ = S;
                        S = null,
                        $()
                    }
                }),
                O.on("end", function() {
                    x.push(null)
                }),
                x._read = function() {
                    for (; ; ) {
                        const $ = O.read();
                        if ($ === null) {
                            S = x._read;
                            return
                        }
                        if (!x.push($))
                            return
                    }
                }
                ;
            else if (l(O)) {
                const X = (u(O) ? O.readable : O).getReader();
                x._read = async function() {
                    for (; ; )
                        try {
                            const {value: F, done: B} = await X.read();
                            if (!x.push(F))
                                return;
                            if (B) {
                                x.push(null);
                                return
                            }
                        } catch {
                            return
                        }
                }
            }
        }
        return x._destroy = function($, X) {
            !$ && y !== null && ($ = new m),
            S = null,
            A = null,
            R = null,
            y === null ? X($) : (y = X,
            r(O) && n(O, $))
        }
        ,
        x
    }
    ,
    na
}
var Mc;
function $g() {
    if (Mc)
        return _s;
    Mc = 1;
    const i = globalThis.AbortController || Br().AbortController
      , {codes: {ERR_INVALID_ARG_VALUE: e, ERR_INVALID_ARG_TYPE: n, ERR_MISSING_ARGS: r, ERR_OUT_OF_RANGE: o}, AbortError: a} = kt()
      , {validateAbortSignal: l, validateInteger: u, validateObject: f} = Vr()
      , h = ct().Symbol("kWeak")
      , m = ct().Symbol("kResistStopPropagation")
      , {finished: _} = Vn()
      , d = pf()
      , {addAbortSignalNoValidate: g} = Vs()
      , {isWritable: b, isNodeStream: T} = Cn()
      , {deprecate: N} = Ot()
      , {ArrayPrototypePush: A, Boolean: R, MathFloor: S, Number: y, NumberIsNaN: x, Promise: M, PromiseReject: U, PromiseResolve: O, PromisePrototypeThen: Q, Symbol: D} = ct()
      , $ = D("kEmpty")
      , X = D("kEof");
    function F(K, le) {
        if (le != null && f(le, "options"),
        le?.signal != null && l(le.signal, "options.signal"),
        T(K) && !b(K))
            throw new e("stream",K,"must be writable");
        const ce = d(this, K);
        return le != null && le.signal && g(le.signal, ce),
        ce
    }
    function B(K, le) {
        if (typeof K != "function")
            throw new n("fn",["Function", "AsyncFunction"],K);
        le != null && f(le, "options"),
        le?.signal != null && l(le.signal, "options.signal");
        let ce = 1;
        le?.concurrency != null && (ce = S(le.concurrency));
        let Ee = ce - 1;
        return le?.highWaterMark != null && (Ee = S(le.highWaterMark)),
        u(ce, "options.concurrency", 1),
        u(Ee, "options.highWaterMark", 0),
        Ee += ce,
        (async function*() {
            const q = Ot().AbortSignalAny([le?.signal].filter(R))
              , te = this
              , fe = []
              , xe = {
                signal: q
            };
            let Se, Ie, se = !1, be = 0;
            function Ne() {
                se = !0,
                ve()
            }
            function ve() {
                be -= 1,
                $e()
            }
            function $e() {
                Ie && !se && be < ce && fe.length < Ee && (Ie(),
                Ie = null)
            }
            async function mt() {
                try {
                    for await(let Be of te) {
                        if (se)
                            return;
                        if (q.aborted)
                            throw new a;
                        try {
                            if (Be = K(Be, xe),
                            Be === $)
                                continue;
                            Be = O(Be)
                        } catch (ft) {
                            Be = U(ft)
                        }
                        be += 1,
                        Q(Be, ve, Ne),
                        fe.push(Be),
                        Se && (Se(),
                        Se = null),
                        !se && (fe.length >= Ee || be >= ce) && await new M(ft=>{
                            Ie = ft
                        }
                        )
                    }
                    fe.push(X)
                } catch (Be) {
                    const ft = U(Be);
                    Q(ft, ve, Ne),
                    fe.push(ft)
                } finally {
                    se = !0,
                    Se && (Se(),
                    Se = null)
                }
            }
            mt();
            try {
                for (; ; ) {
                    for (; fe.length > 0; ) {
                        const Be = await fe[0];
                        if (Be === X)
                            return;
                        if (q.aborted)
                            throw new a;
                        Be !== $ && (yield Be),
                        fe.shift(),
                        $e()
                    }
                    await new M(Be=>{
                        Se = Be
                    }
                    )
                }
            } finally {
                se = !0,
                Ie && (Ie(),
                Ie = null)
            }
        }
        ).call(this)
    }
    function ue(K=void 0) {
        return K != null && f(K, "options"),
        K?.signal != null && l(K.signal, "options.signal"),
        (async function*() {
            let ce = 0;
            for await(const Te of this) {
                var Ee;
                if (K != null && (Ee = K.signal) !== null && Ee !== void 0 && Ee.aborted)
                    throw new a({
                        cause: K.signal.reason
                    });
                yield[ce++, Te]
            }
        }
        ).call(this)
    }
    async function P(K, le=void 0) {
        for await(const ce of I.call(this, K, le))
            return !0;
        return !1
    }
    async function oe(K, le=void 0) {
        if (typeof K != "function")
            throw new n("fn",["Function", "AsyncFunction"],K);
        return !await P.call(this, async(...ce)=>!await K(...ce), le)
    }
    async function j(K, le) {
        for await(const ce of I.call(this, K, le))
            return ce
    }
    async function ae(K, le) {
        if (typeof K != "function")
            throw new n("fn",["Function", "AsyncFunction"],K);
        async function ce(Ee, Te) {
            return await K(Ee, Te),
            $
        }
        for await(const Ee of B.call(this, ce, le))
            ;
    }
    function I(K, le) {
        if (typeof K != "function")
            throw new n("fn",["Function", "AsyncFunction"],K);
        async function ce(Ee, Te) {
            return await K(Ee, Te) ? Ee : $
        }
        return B.call(this, ce, le)
    }
    class Z extends r {
        constructor() {
            super("reduce"),
            this.message = "Reduce of an empty stream requires an initial value"
        }
    }
    async function ie(K, le, ce) {
        var Ee;
        if (typeof K != "function")
            throw new n("reducer",["Function", "AsyncFunction"],K);
        ce != null && f(ce, "options"),
        ce?.signal != null && l(ce.signal, "options.signal");
        let Te = arguments.length > 1;
        if (ce != null && (Ee = ce.signal) !== null && Ee !== void 0 && Ee.aborted) {
            const Se = new a(void 0,{
                cause: ce.signal.reason
            });
            throw this.once("error", ()=>{}
            ),
            await _(this.destroy(Se)),
            Se
        }
        const q = new i
          , te = q.signal;
        if (ce != null && ce.signal) {
            const Se = {
                once: !0,
                [h]: this,
                [m]: !0
            };
            ce.signal.addEventListener("abort", ()=>q.abort(), Se)
        }
        let fe = !1;
        try {
            for await(const Se of this) {
                var xe;
                if (fe = !0,
                ce != null && (xe = ce.signal) !== null && xe !== void 0 && xe.aborted)
                    throw new a;
                Te ? le = await K(le, Se, {
                    signal: te
                }) : (le = Se,
                Te = !0)
            }
            if (!fe && !Te)
                throw new Z
        } finally {
            q.abort()
        }
        return le
    }
    async function ee(K) {
        K != null && f(K, "options"),
        K?.signal != null && l(K.signal, "options.signal");
        const le = [];
        for await(const Ee of this) {
            var ce;
            if (K != null && (ce = K.signal) !== null && ce !== void 0 && ce.aborted)
                throw new a(void 0,{
                    cause: K.signal.reason
                });
            A(le, Ee)
        }
        return le
    }
    function me(K, le) {
        const ce = B.call(this, K, le);
        return (async function*() {
            for await(const Te of ce)
                yield*Te
        }
        ).call(this)
    }
    function W(K) {
        if (K = y(K),
        x(K))
            return 0;
        if (K < 0)
            throw new o("number",">= 0",K);
        return K
    }
    function G(K, le=void 0) {
        return le != null && f(le, "options"),
        le?.signal != null && l(le.signal, "options.signal"),
        K = W(K),
        (async function*() {
            var Ee;
            if (le != null && (Ee = le.signal) !== null && Ee !== void 0 && Ee.aborted)
                throw new a;
            for await(const q of this) {
                var Te;
                if (le != null && (Te = le.signal) !== null && Te !== void 0 && Te.aborted)
                    throw new a;
                K-- <= 0 && (yield q)
            }
        }
        ).call(this)
    }
    function Y(K, le=void 0) {
        return le != null && f(le, "options"),
        le?.signal != null && l(le.signal, "options.signal"),
        K = W(K),
        (async function*() {
            var Ee;
            if (le != null && (Ee = le.signal) !== null && Ee !== void 0 && Ee.aborted)
                throw new a;
            for await(const q of this) {
                var Te;
                if (le != null && (Te = le.signal) !== null && Te !== void 0 && Te.aborted)
                    throw new a;
                if (K-- > 0 && (yield q),
                K <= 0)
                    return
            }
        }
        ).call(this)
    }
    return _s.streamReturningOperators = {
        asIndexedPairs: N(ue, "readable.asIndexedPairs will be removed in a future version."),
        drop: G,
        filter: I,
        flatMap: me,
        map: B,
        take: Y,
        compose: F
    },
    _s.promiseReturningOperators = {
        every: oe,
        forEach: ae,
        reduce: ie,
        toArray: ee,
        some: P,
        find: j
    },
    _s
}
var ia, Dc;
function gf() {
    if (Dc)
        return ia;
    Dc = 1;
    const {ArrayPrototypePop: i, Promise: e} = ct()
      , {isIterable: n, isNodeStream: r, isWebStream: o} = Cn()
      , {pipelineImpl: a} = Ml()
      , {finished: l} = Vn();
    mf();
    function u(...f) {
        return new e((h,m)=>{
            let _, d;
            const g = f[f.length - 1];
            if (g && typeof g == "object" && !r(g) && !n(g) && !o(g)) {
                const b = i(f);
                _ = b.signal,
                d = b.end
            }
            a(f, (b,T)=>{
                b ? m(b) : h(T)
            }
            , {
                signal: _,
                end: d
            })
        }
        )
    }
    return ia = {
        finished: l,
        pipeline: u
    },
    ia
}
var Oc;
function mf() {
    if (Oc)
        return Mo.exports;
    Oc = 1;
    const {Buffer: i} = Rn()
      , {ObjectDefineProperty: e, ObjectKeys: n, ReflectApply: r} = ct()
      , {promisify: {custom: o}} = Ot()
      , {streamReturningOperators: a, promiseReturningOperators: l} = $g()
      , {codes: {ERR_ILLEGAL_CONSTRUCTOR: u}} = kt()
      , f = pf()
      , {setDefaultHighWaterMark: h, getDefaultHighWaterMark: m} = Gs()
      , {pipeline: _} = Ml()
      , {destroyer: d} = Gi()
      , g = Vn()
      , b = gf()
      , T = Cn()
      , N = Mo.exports = kl().Stream;
    N.isDestroyed = T.isDestroyed,
    N.isDisturbed = T.isDisturbed,
    N.isErrored = T.isErrored,
    N.isReadable = T.isReadable,
    N.isWritable = T.isWritable,
    N.Readable = Ws();
    for (const R of n(a)) {
        let y = function(...x) {
            if (new.target)
                throw u();
            return N.Readable.from(r(S, this, x))
        };
        const S = a[R];
        e(y, "name", {
            __proto__: null,
            value: S.name
        }),
        e(y, "length", {
            __proto__: null,
            value: S.length
        }),
        e(N.Readable.prototype, R, {
            __proto__: null,
            value: y,
            enumerable: !1,
            configurable: !0,
            writable: !0
        })
    }
    for (const R of n(l)) {
        let y = function(...x) {
            if (new.target)
                throw u();
            return r(S, this, x)
        };
        const S = l[R];
        e(y, "name", {
            __proto__: null,
            value: S.name
        }),
        e(y, "length", {
            __proto__: null,
            value: S.length
        }),
        e(N.Readable.prototype, R, {
            __proto__: null,
            value: y,
            enumerable: !1,
            configurable: !0,
            writable: !0
        })
    }
    N.Writable = Pl(),
    N.Duplex = In(),
    N.Transform = hf(),
    N.PassThrough = ff(),
    N.pipeline = _;
    const {addAbortSignal: A} = Vs();
    return N.addAbortSignal = A,
    N.finished = g,
    N.destroy = d,
    N.compose = f,
    N.setDefaultHighWaterMark = h,
    N.getDefaultHighWaterMark = m,
    e(N, "promises", {
        __proto__: null,
        configurable: !0,
        enumerable: !0,
        get() {
            return b
        }
    }),
    e(_, o, {
        __proto__: null,
        enumerable: !0,
        get() {
            return b.pipeline
        }
    }),
    e(g, o, {
        __proto__: null,
        enumerable: !0,
        get() {
            return b.finished
        }
    }),
    N.Stream = N,
    N._isUint8Array = function(S) {
        return S instanceof Uint8Array
    }
    ,
    N._uint8ArrayToBuffer = function(S) {
        return i.from(S.buffer, S.byteOffset, S.byteLength)
    }
    ,
    Mo.exports
}
var Fc;
function _f() {
    return Fc || (Fc = 1,
    (function(i) {
        const e = mf()
          , n = gf()
          , r = e.Readable.destroy;
        i.exports = e.Readable,
        i.exports._uint8ArrayToBuffer = e._uint8ArrayToBuffer,
        i.exports._isUint8Array = e._isUint8Array,
        i.exports.isDisturbed = e.isDisturbed,
        i.exports.isErrored = e.isErrored,
        i.exports.isReadable = e.isReadable,
        i.exports.Readable = e.Readable,
        i.exports.Writable = e.Writable,
        i.exports.Duplex = e.Duplex,
        i.exports.Transform = e.Transform,
        i.exports.PassThrough = e.PassThrough,
        i.exports.addAbortSignal = e.addAbortSignal,
        i.exports.finished = e.finished,
        i.exports.destroy = e.destroy,
        i.exports.destroy = r,
        i.exports.pipeline = e.pipeline,
        i.exports.compose = e.compose,
        Object.defineProperty(e, "promises", {
            configurable: !0,
            enumerable: !0,
            get() {
                return n
            }
        }),
        i.exports.Stream = e.Stream,
        i.exports.default = i.exports
    }
    )(Po)),
    Po.exports
}
var Dl = _f();
const ra = Symbol("iter");
function Dr(i, e, n=4) {
    if (n === 0)
        return Object.assign(i, e);
    for (const r in e)
        i[r] = Dr(i[r] || Object.create(null), e[r], n - 1);
    return i
}
function yf(i, e, n=4) {
    let r = !1;
    for (const o in i)
        if (o in e) {
            const a = n === 0 ? null : yf(i[o], e[o], n - 1);
            if (a !== !1)
                r = r || Object.create(null),
                r[o] = a;
            else if (n === 3)
                return !1
        }
    return r
}
function vf(i, e, n=4) {
    let r = !1;
    for (const o in i)
        if (!(o in e))
            r = r || Object.create(null),
            r[o] = n === 0 ? null : Dr({}, i[o], n - 1);
        else if (n !== 0) {
            const a = vf(i[o], e[o], n - 1);
            if (a !== !1)
                r = r || Object.create(null),
                r[o] = a;
            else if (n === 3)
                return !1
        }
    return r
}
class qg {
    constructor(e={}) {
        this._id = 1,
        this._ids = Object.create(null),
        this._ids[""] = 1,
        this._entities = Object.create(null),
        this._entities[1] = "",
        this._blankNodeIndex = 0,
        this._factory = e.factory || ze
    }
    _termFromId(e) {
        if (e[0] === ".") {
            const n = this._entities
              , r = e.split(".");
            return this._factory.quad(this._termFromId(n[r[1]]), this._termFromId(n[r[2]]), this._termFromId(n[r[3]]), r[4] && this._termFromId(n[r[4]]))
        }
        return Rr(e, this._factory)
    }
    _termToNumericId(e) {
        if (e.termType === "Quad") {
            const n = this._termToNumericId(e.subject)
              , r = this._termToNumericId(e.predicate)
              , o = this._termToNumericId(e.object);
            let a;
            return n && r && o && (vl(e.graph) || (a = this._termToNumericId(e.graph))) && this._ids[a ? `.${n}.${r}.${o}.${a}` : `.${n}.${r}.${o}`]
        }
        return this._ids[ji(e)]
    }
    _termToNewNumericId(e) {
        const n = e && e.termType === "Quad" ? `.${this._termToNewNumericId(e.subject)}.${this._termToNewNumericId(e.predicate)}.${this._termToNewNumericId(e.object)}${vl(e.graph) ? "" : `.${this._termToNewNumericId(e.graph)}`}` : ji(e);
        return this._ids[n] || (this._ids[this._entities[++this._id] = n] = this._id)
    }
    createBlankNode(e) {
        let n, r;
        if (e)
            for (n = e = `_:${e}`,
            r = 1; this._ids[n]; )
                n = e + r++;
        else
            do
                n = `_:b ${this._blankNodeIndex++}`;
            while (this._ids[n]);
        return this._ids[n] = ++this._id,
        this._entities[this._id] = n,
        this._factory.blankNode(n.substr(2))
    }
}
class It {
    constructor(e, n) {
        this._size = 0,
        this._graphs = Object.create(null),
        !n && e && !e[0] && typeof e.match != "function" && (n = e,
        e = null),
        n = n || {},
        this._factory = n.factory || ze,
        this._entityIndex = n.entityIndex || new qg({
            factory: this._factory
        }),
        this._entities = this._entityIndex._entities,
        this._termFromId = this._entityIndex._termFromId.bind(this._entityIndex),
        this._termToNumericId = this._entityIndex._termToNumericId.bind(this._entityIndex),
        this._termToNewNumericId = this._entityIndex._termToNewNumericId.bind(this._entityIndex),
        e && this.addAll(e)
    }
    get size() {
        let e = this._size;
        if (e !== null)
            return e;
        e = 0;
        const n = this._graphs;
        let r, o;
        for (const a in n)
            for (const l in r = n[a].subjects)
                for (const u in o = r[l])
                    e += Object.keys(o[u]).length;
        return this._size = e
    }
    _addToIndex(e, n, r, o) {
        const a = e[n] || (e[n] = {})
          , l = a[r] || (a[r] = {})
          , u = o in l;
        return u || (l[o] = null),
        !u
    }
    _removeFromIndex(e, n, r, o) {
        const a = e[n]
          , l = a[r];
        delete l[o];
        for (const u in l)
            return;
        delete a[r];
        for (const u in a)
            return;
        delete e[n]
    }
    *_findInIndex(e, n, r, o, a, l, u, f) {
        let h, m, _;
        const d = this._entities
          , g = this._termFromId(d[f])
          , b = {
            subject: null,
            predicate: null,
            object: null
        };
        n && ((h = e,
        e = {})[n] = h[n]);
        for (const T in e)
            if (m = e[T]) {
                b[a] = this._termFromId(d[T]),
                r && ((h = m,
                m = {})[r] = h[r]);
                for (const N in m)
                    if (_ = m[N]) {
                        b[l] = this._termFromId(d[N]);
                        const A = o ? o in _ ? [o] : [] : Object.keys(_);
                        for (let R = 0; R < A.length; R++)
                            b[u] = this._termFromId(d[A[R]]),
                            yield this._factory.quad(b.subject, b.predicate, b.object, g)
                    }
            }
    }
    _loop(e, n) {
        for (const r in e)
            n(r)
    }
    _loopByKey0(e, n, r) {
        let o, a;
        if (o = e[n])
            for (a in o)
                r(a)
    }
    _loopByKey1(e, n, r) {
        let o, a;
        for (o in e)
            a = e[o],
            a[n] && r(o)
    }
    _loopBy2Keys(e, n, r, o) {
        let a, l, u;
        if ((a = e[n]) && (l = a[r]))
            for (u in l)
                o(u)
    }
    _countInIndex(e, n, r, o) {
        let a = 0, l, u, f;
        n && ((l = e,
        e = {})[n] = l[n]);
        for (const h in e)
            if (u = e[h]) {
                r && ((l = u,
                u = {})[r] = l[r]);
                for (const m in u)
                    (f = u[m]) && (o ? o in f && a++ : a += Object.keys(f).length)
            }
        return a
    }
    _getGraphs(e) {
        return e = e === "" ? 1 : e && (this._termToNumericId(e) || -1),
        typeof e != "number" ? this._graphs : {
            [e]: this._graphs[e]
        }
    }
    _uniqueEntities(e) {
        const n = Object.create(null);
        return r=>{
            r in n || (n[r] = !0,
            e(this._termFromId(this._entities[r], this._factory)))
        }
    }
    add(e) {
        return this.addQuad(e),
        this
    }
    addQuad(e, n, r, o) {
        n || (o = e.graph,
        r = e.object,
        n = e.predicate,
        e = e.subject),
        o = o ? this._termToNewNumericId(o) : 1;
        let a = this._graphs[o];
        return a || (a = this._graphs[o] = {
            subjects: {},
            predicates: {},
            objects: {}
        },
        Object.freeze(a)),
        e = this._termToNewNumericId(e),
        n = this._termToNewNumericId(n),
        r = this._termToNewNumericId(r),
        this._addToIndex(a.subjects, e, n, r) ? (this._addToIndex(a.predicates, n, r, e),
        this._addToIndex(a.objects, r, e, n),
        this._size = null,
        !0) : !1
    }
    addQuads(e) {
        for (let n = 0; n < e.length; n++)
            this.addQuad(e[n])
    }
    delete(e) {
        return this.removeQuad(e),
        this
    }
    has(e, n, r, o) {
        return e && e.subject && ({subject: e, predicate: n, object: r, graph: o} = e),
        !this.readQuads(e, n, r, o).next().done
    }
    import(e) {
        return e.on("data", n=>{
            this.addQuad(n)
        }
        ),
        e
    }
    removeQuad(e, n, r, o) {
        n || ({subject: e, predicate: n, object: r, graph: o} = e),
        o = o ? this._termToNumericId(o) : 1;
        const a = this._graphs;
        let l, u, f;
        if (!(e = e && this._termToNumericId(e)) || !(n = n && this._termToNumericId(n)) || !(r = r && this._termToNumericId(r)) || !(l = a[o]) || !(u = l.subjects[e]) || !(f = u[n]) || !(r in f))
            return !1;
        this._removeFromIndex(l.subjects, e, n, r),
        this._removeFromIndex(l.predicates, n, r, e),
        this._removeFromIndex(l.objects, r, e, n),
        this._size !== null && this._size--;
        for (e in l.subjects)
            return !0;
        return delete a[o],
        !0
    }
    removeQuads(e) {
        for (let n = 0; n < e.length; n++)
            this.removeQuad(e[n])
    }
    remove(e) {
        return e.on("data", n=>{
            this.removeQuad(n)
        }
        ),
        e
    }
    removeMatches(e, n, r, o) {
        const a = new Dl.Readable({
            objectMode: !0
        })
          , l = this.readQuads(e, n, r, o);
        return a._read = u=>{
            for (; --u >= 0; ) {
                const {done: f, value: h} = l.next();
                if (f) {
                    a.push(null);
                    return
                }
                a.push(h)
            }
        }
        ,
        this.remove(a)
    }
    deleteGraph(e) {
        return this.removeMatches(null, null, null, e)
    }
    getQuads(e, n, r, o) {
        return [...this.readQuads(e, n, r, o)]
    }
    *readQuads(e, n, r, o) {
        const a = this._getGraphs(o);
        let l, u, f, h;
        if (!(e && !(u = this._termToNumericId(e)) || n && !(f = this._termToNumericId(n)) || r && !(h = this._termToNumericId(r))))
            for (const m in a)
                (l = a[m]) && (u ? h ? yield*this._findInIndex(l.objects, h, u, f, "object", "subject", "predicate", m) : yield*this._findInIndex(l.subjects, u, f, null, "subject", "predicate", "object", m) : f ? yield*this._findInIndex(l.predicates, f, h, null, "predicate", "object", "subject", m) : h ? yield*this._findInIndex(l.objects, h, null, null, "object", "subject", "predicate", m) : yield*this._findInIndex(l.subjects, null, null, null, "subject", "predicate", "object", m))
    }
    match(e, n, r, o) {
        return new $n(this,e,n,r,o,{
            entityIndex: this._entityIndex
        })
    }
    countQuads(e, n, r, o) {
        const a = this._getGraphs(o);
        let l = 0, u, f, h, m;
        if (e && !(f = this._termToNumericId(e)) || n && !(h = this._termToNumericId(n)) || r && !(m = this._termToNumericId(r)))
            return 0;
        for (const _ in a)
            (u = a[_]) && (e ? r ? l += this._countInIndex(u.objects, m, f, h) : l += this._countInIndex(u.subjects, f, h, m) : n ? l += this._countInIndex(u.predicates, h, m, f) : l += this._countInIndex(u.objects, m, f, h));
        return l
    }
    forEach(e, n, r, o, a) {
        this.some(l=>(e(l, this),
        !1), n, r, o, a)
    }
    every(e, n, r, o, a) {
        return !this.some(l=>!e(l, this), n, r, o, a)
    }
    some(e, n, r, o, a) {
        for (const l of this.readQuads(n, r, o, a))
            if (e(l, this))
                return !0;
        return !1
    }
    getSubjects(e, n, r) {
        const o = [];
        return this.forSubjects(a=>{
            o.push(a)
        }
        , e, n, r),
        o
    }
    forSubjects(e, n, r, o) {
        const a = this._getGraphs(o);
        let l, u, f;
        if (e = this._uniqueEntities(e),
        !(n && !(u = this._termToNumericId(n)) || r && !(f = this._termToNumericId(r))))
            for (o in a)
                (l = a[o]) && (u ? f ? this._loopBy2Keys(l.predicates, u, f, e) : this._loopByKey1(l.subjects, u, e) : f ? this._loopByKey0(l.objects, f, e) : this._loop(l.subjects, e))
    }
    getPredicates(e, n, r) {
        const o = [];
        return this.forPredicates(a=>{
            o.push(a)
        }
        , e, n, r),
        o
    }
    forPredicates(e, n, r, o) {
        const a = this._getGraphs(o);
        let l, u, f;
        if (e = this._uniqueEntities(e),
        !(n && !(u = this._termToNumericId(n)) || r && !(f = this._termToNumericId(r))))
            for (o in a)
                (l = a[o]) && (u ? f ? this._loopBy2Keys(l.objects, f, u, e) : this._loopByKey0(l.subjects, u, e) : f ? this._loopByKey1(l.predicates, f, e) : this._loop(l.predicates, e))
    }
    getObjects(e, n, r) {
        const o = [];
        return this.forObjects(a=>{
            o.push(a)
        }
        , e, n, r),
        o
    }
    forObjects(e, n, r, o) {
        const a = this._getGraphs(o);
        let l, u, f;
        if (e = this._uniqueEntities(e),
        !(n && !(u = this._termToNumericId(n)) || r && !(f = this._termToNumericId(r))))
            for (o in a)
                (l = a[o]) && (u ? f ? this._loopBy2Keys(l.subjects, u, f, e) : this._loopByKey1(l.objects, u, e) : f ? this._loopByKey0(l.predicates, f, e) : this._loop(l.objects, e))
    }
    getGraphs(e, n, r) {
        const o = [];
        return this.forGraphs(a=>{
            o.push(a)
        }
        , e, n, r),
        o
    }
    forGraphs(e, n, r, o) {
        for (const a in this._graphs)
            this.some(l=>(e(l.graph),
            !0), n, r, o, this._termFromId(this._entities[a]))
    }
    createBlankNode(e) {
        return this._entityIndex.createBlankNode(e)
    }
    extractLists({remove: e=!1, ignoreErrors: n=!1}={}) {
        const r = {}
          , o = n ? (()=>!0) : ((u,f)=>{
            throw new Error(`${u.value} ${f}`)
        }
        )
          , a = this.getQuads(null, Lt.rdf.rest, Lt.rdf.nil, null)
          , l = e ? [...a] : [];
        return a.forEach(u=>{
            const f = [];
            let h = !1, m, _;
            const d = u.graph;
            let g = u.subject;
            for (; g && !h; ) {
                const b = this.getQuads(null, null, g, null)
                  , T = this.getQuads(g, null, null, null);
                let N, A = null, R = null, S = null;
                for (let y = 0; y < T.length && !h; y++)
                    N = T[y],
                    N.graph.equals(d) ? m ? h = o(g, "has non-list arcs out") : N.predicate.value === Lt.rdf.first ? A ? h = o(g, "has multiple rdf:first arcs") : l.push(A = N) : N.predicate.value === Lt.rdf.rest ? R ? h = o(g, "has multiple rdf:rest arcs") : l.push(R = N) : b.length ? h = o(g, "can't be subject and object") : (m = N,
                    _ = "subject") : h = o(g, "not confined to single graph");
                for (let y = 0; y < b.length && !h; ++y)
                    N = b[y],
                    m ? h = o(g, "can't have coreferences") : N.predicate.value === Lt.rdf.rest ? S ? h = o(g, "has incoming rdf:rest arcs") : S = N : (m = N,
                    _ = "object");
                A ? f.unshift(A.object) : h = o(g, "has no list head"),
                g = S && S.subject
            }
            h ? e = !1 : m && (r[m[_].value] = f)
        }
        ),
        e && this.removeQuads(l),
        r
    }
    addAll(e) {
        if (e instanceof $n && (e = e.filtered),
        Array.isArray(e))
            this.addQuads(e);
        else if (e instanceof It && e._entityIndex === this._entityIndex)
            e._size !== 0 && (this._graphs = Dr(this._graphs, e._graphs),
            this._size = null);
        else
            for (const n of e)
                this.add(n);
        return this
    }
    contains(e) {
        if (e instanceof $n && (e = e.filtered),
        e === this)
            return !0;
        if (!(e instanceof It) || this._entityIndex !== e._entityIndex)
            return e.every(h=>this.has(h));
        const n = this._graphs
          , r = e._graphs;
        let o, a, l, u, f;
        for (const h in r) {
            if (!(o = n[h]))
                return !1;
            o = o.subjects;
            for (const m in a = r[h].subjects) {
                if (!(l = o[m]))
                    return !1;
                for (const _ in u = a[m]) {
                    if (!(f = l[_]))
                        return !1;
                    for (const d in u[_])
                        if (!(d in f))
                            return !1
                }
            }
        }
        return !0
    }
    deleteMatches(e, n, r, o) {
        for (const a of this.match(e, n, r, o))
            this.removeQuad(a);
        return this
    }
    difference(e) {
        if (e && e instanceof $n && (e = e.filtered),
        e === this)
            return new It({
                entityIndex: this._entityIndex
            });
        if (e instanceof It && e._entityIndex === this._entityIndex) {
            const n = new It({
                entityIndex: this._entityIndex
            })
              , r = vf(this._graphs, e._graphs);
            return r && (n._graphs = r,
            n._size = null),
            n
        }
        return this.filter(n=>!e.has(n))
    }
    equals(e) {
        return e instanceof $n && (e = e.filtered),
        e === this || this.size === e.size && this.contains(e)
    }
    filter(e) {
        const n = new It({
            entityIndex: this._entityIndex
        });
        for (const r of this)
            e(r, this) && n.add(r);
        return n
    }
    intersection(e) {
        if (e instanceof $n && (e = e.filtered),
        e === this) {
            const n = new It({
                entityIndex: this._entityIndex
            });
            return n._graphs = Dr(Object.create(null), this._graphs),
            n._size = this._size,
            n
        } else if (e instanceof It && this._entityIndex === e._entityIndex) {
            const n = new It({
                entityIndex: this._entityIndex
            })
              , r = yf(e._graphs, this._graphs);
            return r && (n._graphs = r,
            n._size = null),
            n
        }
        return this.filter(n=>e.has(n))
    }
    map(e) {
        const n = new It({
            entityIndex: this._entityIndex
        });
        for (const r of this)
            n.add(e(r, this));
        return n
    }
    reduce(e, n) {
        const r = this.readQuads();
        let o = n === void 0 ? r.next().value : n;
        for (const a of r)
            o = e(o, a, this);
        return o
    }
    toArray() {
        return this.getQuads()
    }
    toCanonical() {
        throw new Error("not implemented")
    }
    toStream() {
        return this.match()
    }
    toString() {
        return new Cl().quadsToString(this)
    }
    union(e) {
        const n = new It({
            entityIndex: this._entityIndex
        });
        return n._graphs = Dr(Object.create(null), this._graphs),
        n._size = this._size,
        n.addAll(e),
        n
    }
    *[Symbol.iterator]() {
        yield*this.readQuads()
    }
}
function mn(i, e, n=0) {
    const r = e[n];
    if (r && !(r in i))
        return !1;
    let o = !1;
    for (const a in r ? {
        [r]: i[r]
    } : i) {
        const l = n === 2 ? null : mn(i[a], e, n + 1);
        l !== !1 && (o = o || Object.create(null),
        o[a] = l)
    }
    return o
}
class $n extends Dl.Readable {
    constructor(e, n, r, o, a, l) {
        super({
            objectMode: !0
        }),
        Object.assign(this, {
            n3Store: e,
            subject: n,
            predicate: r,
            object: o,
            graph: a,
            options: l
        })
    }
    get filtered() {
        if (!this._filtered) {
            const {n3Store: e, graph: n, object: r, predicate: o, subject: a} = this
              , l = this._filtered = new It({
                factory: e._factory,
                entityIndex: this.options.entityIndex
            });
            let u, f, h;
            if (a && !(u = l._termToNumericId(a)) || o && !(f = l._termToNumericId(o)) || r && !(h = l._termToNumericId(r)))
                return l;
            const m = e._getGraphs(n);
            for (const _ in m) {
                let d, g, b, T;
                (T = m[_]) && (!u && f ? (g = mn(T.predicates, [f, h, u])) && (d = mn(T.subjects, [u, f, h]),
                b = mn(T.objects, [h, u, f])) : h ? (b = mn(T.objects, [h, u, f])) && (d = mn(T.subjects, [u, f, h]),
                g = mn(T.predicates, [f, h, u])) : (d = mn(T.subjects, [u, f, h])) && (g = mn(T.predicates, [f, h, u]),
                b = mn(T.objects, [h, u, f])),
                d && (l._graphs[_] = {
                    subjects: d,
                    predicates: g,
                    objects: b
                }))
            }
            l._size = null
        }
        return this._filtered
    }
    get size() {
        return this.filtered.size
    }
    _read(e) {
        e > 0 && !this[ra] && (this[ra] = this[Symbol.iterator]());
        const n = this[ra];
        for (; --e >= 0; ) {
            const {done: r, value: o} = n.next();
            if (r) {
                this.push(null);
                return
            }
            this.push(o)
        }
    }
    addAll(e) {
        return this.filtered.addAll(e)
    }
    contains(e) {
        return this.filtered.contains(e)
    }
    deleteMatches(e, n, r, o) {
        return this.filtered.deleteMatches(e, n, r, o)
    }
    difference(e) {
        return this.filtered.difference(e)
    }
    equals(e) {
        return this.filtered.equals(e)
    }
    every(e, n, r, o, a) {
        return this.filtered.every(e, n, r, o, a)
    }
    filter(e) {
        return this.filtered.filter(e)
    }
    forEach(e, n, r, o, a) {
        return this.filtered.forEach(e, n, r, o, a)
    }
    import(e) {
        return this.filtered.import(e)
    }
    intersection(e) {
        return this.filtered.intersection(e)
    }
    map(e) {
        return this.filtered.map(e)
    }
    some(e, n, r, o, a) {
        return this.filtered.some(e, n, r, o, a)
    }
    toCanonical() {
        return this.filtered.toCanonical()
    }
    toStream() {
        return this._filtered ? this._filtered.toStream() : this.n3Store.match(this.subject, this.predicate, this.object, this.graph)
    }
    union(e) {
        return this._filtered ? this._filtered.union(e) : this.n3Store.match(this.subject, this.predicate, this.object, this.graph).addAll(e)
    }
    toArray() {
        return this._filtered ? this._filtered.toArray() : this.n3Store.getQuads(this.subject, this.predicate, this.object, this.graph)
    }
    reduce(e, n) {
        return this.filtered.reduce(e, n)
    }
    toString() {
        return new Cl().quadsToString(this)
    }
    add(e) {
        return this.filtered.add(e)
    }
    delete(e) {
        return this.filtered.delete(e)
    }
    has(e) {
        return this.filtered.has(e)
    }
    match(e, n, r, o) {
        return new $n(this.filtered,e,n,r,o,this.options)
    }
    *[Symbol.iterator]() {
        yield*this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph)
    }
}
class zg extends Dl.Transform {
    constructor(e) {
        super({
            decodeStrings: !0
        }),
        this._readableState.objectMode = !0;
        const n = new lf(e);
        let r, o;
        const a = {
            onQuad: (l,u)=>{
                l && this.emit("error", l) || u && this.push(u)
            }
            ,
            onPrefix: (l,u)=>{
                this.emit("prefix", l, u)
            }
        };
        e && e.comments && (a.onComment = l=>{
            this.emit("comment", l)
        }
        ),
        n.parse({
            on: (l,u)=>{
                switch (l) {
                case "data":
                    r = u;
                    break;
                case "end":
                    o = u;
                    break
                }
            }
        }, a),
        this._transform = (l,u,f)=>{
            r(l),
            f()
        }
        ,
        this._flush = l=>{
            o(),
            l()
        }
    }
    import(e) {
        return e.on("data", n=>{
            this.write(n)
        }
        ),
        e.on("end", ()=>{
            this.end()
        }
        ),
        e.on("error", n=>{
            this.emit("error", n)
        }
        ),
        this
    }
}
const Fe = "http://www.w3.org/ns/shacl#"
  , jc = "http://datashapes.org/dash#"
  , Un = "http://www.w3.org/2001/XMLSchema#"
  , hi = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  , Ol = "http://www.w3.org/2000/01/rdf-schema#"
  , Fl = "http://www.w3.org/2004/02/skos/core#"
  , Ug = "http://www.w3.org/2002/07/owl#"
  , Hg = "http://www.w3.org/ns/oa#"
  , Vg = "http://purl.org/dc/terms/"
  , Gg = "http://xmlns.com/foaf/0.1/"
  , pi = ze.namedNode("loaded-shapes")
  , on = ze.namedNode("loaded-data")
  , Rt = ze.namedNode(hi + "type")
  , bf = ze.namedNode(hi + "langString")
  , Ds = ze.namedNode(Vg + "conformsTo")
  , Bc = ze.namedNode(Ol + "subClassOf")
  , jl = ze.namedNode(Ug + "imports")
  , Wg = ze.namedNode(Fl + "broader")
  , Zg = ze.namedNode(Fl + "narrower")
  , sa = ze.namedNode(Fe + "NodeShape")
  , wf = ze.namedNode(Fe + "IRI")
  , bl = ze.namedNode(Fe + "property")
  , Bl = ze.namedNode(Fe + "class");
ze.namedNode(Fe + "node");
const Zs = ze.namedNode(Fe + "targetClass")
  , Xg = ze.namedNode(Fe + "nodeKind")
  , Qg = ze.namedNode(Un + "string");
function Or(i, e, n=Fe, r) {
    let o = "";
    const a = Jg(i, e, n, r);
    return a && (o = a.value),
    o
}
function Jg(i, e, n=Fe, r) {
    let o;
    const a = n + e;
    if (r?.length) {
        for (const l of r)
            for (const u of i)
                if (u.predicate.value === a) {
                    if (u.object.id.endsWith(`@${l}`))
                        return u.object;
                    u.object.id.indexOf("@") < 0 ? o = u.object : o || (o = u.object)
                }
    } else
        for (const l of i)
            if (l.predicate.value === a)
                return l.object;
    return o
}
function Kg(i) {
    i.querySelector(".editor")?.focus()
}
function Wi(i, e) {
    return Or(i, "prefLabel", Fl, e) || Or(i, "label", Ol, e) || Or(i, "name", Gg, e)
}
function xf(i, e, n) {
    const r = [];
    for (const o of i)
        r.push({
            value: o,
            label: Wi(e.getQuads(o, null, null, null), n),
            children: []
        });
    return r
}
function wl(i, e) {
    for (const n in e)
        i = i.replace(e[n], "");
    return i
}
function Ef(i, e, n, r, o=new Set) {
    for (const a of e.owlImports)
        o.has(a.id) || (o.add(a.id),
        r.push(...n.getSubjects(Rt, i, a)));
    e.parent && Ef(i, e.parent, n, r, o)
}
function $l(i, e) {
    if (e.in) {
        const n = e.config.lists[e.in];
        return xf(n?.length ? n : [], e.config.store, e.config.languages)
    } else {
        const n = e.config.store.getSubjects(Rt, i, pi);
        n.push(...e.config.store.getSubjects(Rt, i, on)),
        Ef(i, e, e.config.store, n);
        const r = new Map
          , o = new Map;
        for (const l of n)
            r.set(l.id, {
                value: l,
                label: Wi(e.config.store.getQuads(l, null, null, null), e.config.languages),
                children: []
            });
        for (const l of n) {
            for (const u of e.config.store.getObjects(l, Wg, null))
                r.has(u.id) && o.set(l.id, u.id);
            for (const u of e.config.store.getObjects(l, Zg, null))
                r.has(u.id) && o.set(u.id, l.id);
            for (const u of e.config.store.getObjects(l, Bc, null))
                r.has(u.id) && o.set(l.id, u.id)
        }
        for (const [l,u] of o.entries())
            r.get(u)?.children?.push(r.get(l));
        const a = [];
        for (const [l,u] of r.entries())
            o.has(l) || a.push(u);
        for (const l of e.config.store.getSubjects(Bc, i, null))
            a.push(...$l(l, e));
        return a
    }
}
function xl(i) {
    let e;
    try {
        e = new URL(i)
    } catch {
        return !1
    }
    return e.protocol === "http:" || e.protocol === "https:"
}
function $c(i, e, n) {
    if (e === void 0)
        return n;
    if (n === void 0)
        return e;
    const r = i.indexOf(e.language);
    if (r < 0)
        return n;
    const o = i.indexOf(n.language);
    return o < 0 || o > r ? e : n
}
function Yg(i, {remove: e=!1, ignoreErrors: n=!1}={}) {
    const r = {}
      , o = n ? (()=>!0) : ((u,f)=>{
        throw new Error(`${u.value} ${f}`)
    }
    )
      , a = i.getQuads(null, hi + "rest", hi + "nil", null)
      , l = e ? [...a] : [];
    return a.forEach(u=>{
        const f = [];
        let h = !1, m, _;
        const d = u.graph;
        let g = u.subject;
        for (; g && !h; ) {
            const b = i.getQuads(null, null, g, null)
              , T = i.getQuads(g, null, null, null).filter(y=>!y.predicate.equals(Rt));
            let N, A = null, R = null, S = null;
            for (let y = 0; y < T.length && !h; y++)
                N = T[y],
                N.graph.equals(d) ? m ? h = o(g, "has non-list arcs out") : N.predicate.value === hi + "first" ? A ? h = o(g, "has multiple rdf:first arcs") : l.push(A = N) : N.predicate.value === hi + "rest" ? R ? h = o(g, "has multiple rdf:rest arcs") : l.push(R = N) : b.length ? h = o(g, "can't be subject and object") : (m = N,
                _ = "subject") : h = o(g, "not confined to single graph");
            for (let y = 0; y < b.length && !h; ++y)
                N = b[y],
                m ? h = o(g, "can't have coreferences") : N.predicate.value === hi + "rest" ? S ? h = o(g, "has incoming rdf:rest arcs") : S = N : (m = N,
                _ = "object");
            A ? f.unshift(A.object) : h = o(g, "has no list head"),
            g = S && S.subject
        }
        h ? e = !1 : m && (r[m[_].value] = f)
    }
    ),
    e && i.removeQuads(l),
    r
}
var ni = {}, ii = {}, ri = {}, Tn = {}, qc;
function em() {
    if (qc)
        return Tn;
    qc = 1,
    Object.defineProperty(Tn, "__esModule", {
        value: !0
    }),
    Tn.removeDotSegmentsOfPath = Tn.removeDotSegments = Tn.resolve = void 0;
    function i(o, a) {
        a = a || "";
        const l = a.indexOf("#");
        if (l > 0 && (a = a.substr(0, l)),
        !o.length) {
            if (a.indexOf(":") < 0)
                throw new Error(`Found invalid baseIRI '${a}' for value '${o}'`);
            return a
        }
        if (o.startsWith("?")) {
            const g = a.indexOf("?");
            return g > 0 && (a = a.substr(0, g)),
            a + o
        }
        if (o.startsWith("#"))
            return a + o;
        if (!a.length) {
            const g = o.indexOf(":");
            if (g < 0)
                throw new Error(`Found invalid relative IRI '${o}' for a missing baseIRI`);
            return n(o, g)
        }
        const u = o.indexOf(":");
        if (u >= 0)
            return n(o, u);
        const f = a.indexOf(":");
        if (f < 0)
            throw new Error(`Found invalid baseIRI '${a}' for value '${o}'`);
        const h = a.substr(0, f + 1);
        if (o.indexOf("//") === 0)
            return h + n(o, u);
        let m;
        if (a.indexOf("//", f) === f + 1) {
            if (m = a.indexOf("/", f + 3),
            m < 0)
                return a.length > f + 3 ? a + "/" + n(o, u) : h + n(o, u)
        } else if (m = a.indexOf("/", f + 1),
        m < 0)
            return h + n(o, u);
        if (o.indexOf("/") === 0)
            return a.substr(0, m) + e(o);
        let _ = a.substr(m);
        const d = _.lastIndexOf("/");
        return d >= 0 && d < _.length - 1 && (_ = _.substr(0, d + 1),
        o[0] === "." && o[1] !== "." && o[1] !== "/" && o[2] && (o = o.substr(1))),
        o = _ + o,
        o = e(o),
        a.substr(0, m) + o
    }
    Tn.resolve = i;
    function e(o) {
        const a = [];
        let l = 0;
        for (; l < o.length; )
            switch (o[l]) {
            case "/":
                if (o[l + 1] === ".")
                    if (o[l + 2] === ".") {
                        if (!r(o[l + 3])) {
                            a.push([]),
                            l++;
                            break
                        }
                        a.pop(),
                        o[l + 3] || a.push([]),
                        l += 3
                    } else {
                        if (!r(o[l + 2])) {
                            a.push([]),
                            l++;
                            break
                        }
                        o[l + 2] || a.push([]),
                        l += 2
                    }
                else
                    a.push([]),
                    l++;
                break;
            case "#":
            case "?":
                a.length || a.push([]),
                a[a.length - 1].push(o.substr(l)),
                l = o.length;
                break;
            default:
                a.length || a.push([]),
                a[a.length - 1].push(o[l]),
                l++;
                break
            }
        return "/" + a.map(u=>u.join("")).join("/")
    }
    Tn.removeDotSegments = e;
    function n(o, a) {
        let l = a + 1;
        a >= 0 ? o[a + 1] === "/" && o[a + 2] === "/" && (l = a + 3) : o[0] === "/" && o[1] === "/" && (l = 2);
        const u = o.indexOf("/", l);
        if (u < 0)
            return o;
        const f = o.substr(0, u)
          , h = o.substr(u);
        return f + e(h)
    }
    Tn.removeDotSegmentsOfPath = n;
    function r(o) {
        return !o || o === "#" || o === "?" || o === "/"
    }
    return Tn
}
var zc;
function tm() {
    return zc || (zc = 1,
    (function(i) {
        var e = ri && ri.__createBinding || (Object.create ? (function(r, o, a, l) {
            l === void 0 && (l = a),
            Object.defineProperty(r, l, {
                enumerable: !0,
                get: function() {
                    return o[a]
                }
            })
        }
        ) : (function(r, o, a, l) {
            l === void 0 && (l = a),
            r[l] = o[a]
        }
        ))
          , n = ri && ri.__exportStar || function(r, o) {
            for (var a in r)
                a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && e(o, r, a)
        }
        ;
        Object.defineProperty(i, "__esModule", {
            value: !0
        }),
        n(em(), i)
    }
    )(ri)),
    ri
}
var si = {}, oa = {}, Uc;
function nm() {
    return Uc || (Uc = 1,
    (function(i) {
        Object.defineProperty(i, "__esModule", {
            value: !0
        }),
        i.CHAR = `	
\r ---`,
        i.S = ` 	\r
`,
        i.NAME_START_CHAR = ":A-Z_a-z-----------",
        i.NAME_CHAR = "-" + i.NAME_START_CHAR + ".0-9--",
        i.CHAR_RE = new RegExp("^[" + i.CHAR + "]$","u"),
        i.S_RE = new RegExp("^[" + i.S + "]+$","u"),
        i.NAME_START_CHAR_RE = new RegExp("^[" + i.NAME_START_CHAR + "]$","u"),
        i.NAME_CHAR_RE = new RegExp("^[" + i.NAME_CHAR + "]$","u"),
        i.NAME_RE = new RegExp("^[" + i.NAME_START_CHAR + "][" + i.NAME_CHAR + "]*$","u"),
        i.NMTOKEN_RE = new RegExp("^[" + i.NAME_CHAR + "]+$","u");
        var e = 9
          , n = 10
          , r = 13
          , o = 32;
        i.S_LIST = [o, n, r, e];
        function a(h) {
            return h >= o && h <= 55295 || h === n || h === r || h === e || h >= 57344 && h <= 65533 || h >= 65536 && h <= 1114111
        }
        i.isChar = a;
        function l(h) {
            return h === o || h === n || h === r || h === e
        }
        i.isS = l;
        function u(h) {
            return h >= 65 && h <= 90 || h >= 97 && h <= 122 || h === 58 || h === 95 || h === 8204 || h === 8205 || h >= 192 && h <= 214 || h >= 216 && h <= 246 || h >= 248 && h <= 767 || h >= 880 && h <= 893 || h >= 895 && h <= 8191 || h >= 8304 && h <= 8591 || h >= 11264 && h <= 12271 || h >= 12289 && h <= 55295 || h >= 63744 && h <= 64975 || h >= 65008 && h <= 65533 || h >= 65536 && h <= 983039
        }
        i.isNameStartChar = u;
        function f(h) {
            return u(h) || h >= 48 && h <= 57 || h === 45 || h === 46 || h === 183 || h >= 768 && h <= 879 || h >= 8255 && h <= 8256
        }
        i.isNameChar = f
    }
    )(oa)),
    oa
}
var aa = {}, Hc;
function im() {
    return Hc || (Hc = 1,
    (function(i) {
        Object.defineProperty(i, "__esModule", {
            value: !0
        }),
        i.CHAR = "---",
        i.RESTRICTED_CHAR = "-\b\v\f---",
        i.S = ` 	\r
`,
        i.NAME_START_CHAR = ":A-Z_a-z-----------",
        i.NAME_CHAR = "-" + i.NAME_START_CHAR + ".0-9--",
        i.CHAR_RE = new RegExp("^[" + i.CHAR + "]$","u"),
        i.RESTRICTED_CHAR_RE = new RegExp("^[" + i.RESTRICTED_CHAR + "]$","u"),
        i.S_RE = new RegExp("^[" + i.S + "]+$","u"),
        i.NAME_START_CHAR_RE = new RegExp("^[" + i.NAME_START_CHAR + "]$","u"),
        i.NAME_CHAR_RE = new RegExp("^[" + i.NAME_CHAR + "]$","u"),
        i.NAME_RE = new RegExp("^[" + i.NAME_START_CHAR + "][" + i.NAME_CHAR + "]*$","u"),
        i.NMTOKEN_RE = new RegExp("^[" + i.NAME_CHAR + "]+$","u");
        var e = 9
          , n = 10
          , r = 13
          , o = 32;
        i.S_LIST = [o, n, r, e];
        function a(_) {
            return _ >= 1 && _ <= 55295 || _ >= 57344 && _ <= 65533 || _ >= 65536 && _ <= 1114111
        }
        i.isChar = a;
        function l(_) {
            return _ >= 1 && _ <= 8 || _ === 11 || _ === 12 || _ >= 14 && _ <= 31 || _ >= 127 && _ <= 132 || _ >= 134 && _ <= 159
        }
        i.isRestrictedChar = l;
        function u(_) {
            return _ === 9 || _ === 10 || _ === 13 || _ > 31 && _ < 127 || _ === 133 || _ > 159 && _ <= 55295 || _ >= 57344 && _ <= 65533 || _ >= 65536 && _ <= 1114111
        }
        i.isCharAndNotRestricted = u;
        function f(_) {
            return _ === o || _ === n || _ === r || _ === e
        }
        i.isS = f;
        function h(_) {
            return _ >= 65 && _ <= 90 || _ >= 97 && _ <= 122 || _ === 58 || _ === 95 || _ === 8204 || _ === 8205 || _ >= 192 && _ <= 214 || _ >= 216 && _ <= 246 || _ >= 248 && _ <= 767 || _ >= 880 && _ <= 893 || _ >= 895 && _ <= 8191 || _ >= 8304 && _ <= 8591 || _ >= 11264 && _ <= 12271 || _ >= 12289 && _ <= 55295 || _ >= 63744 && _ <= 64975 || _ >= 65008 && _ <= 65533 || _ >= 65536 && _ <= 983039
        }
        i.isNameStartChar = h;
        function m(_) {
            return h(_) || _ >= 48 && _ <= 57 || _ === 45 || _ === 46 || _ === 183 || _ >= 768 && _ <= 879 || _ >= 8255 && _ <= 8256
        }
        i.isNameChar = m
    }
    )(aa)),
    aa
}
var la = {}, Vc;
function rm() {
    return Vc || (Vc = 1,
    (function(i) {
        Object.defineProperty(i, "__esModule", {
            value: !0
        }),
        i.NC_NAME_START_CHAR = "A-Z_a-z------------",
        i.NC_NAME_CHAR = "-" + i.NC_NAME_START_CHAR + ".0-9--",
        i.NC_NAME_START_CHAR_RE = new RegExp("^[" + i.NC_NAME_START_CHAR + "]$","u"),
        i.NC_NAME_CHAR_RE = new RegExp("^[" + i.NC_NAME_CHAR + "]$","u"),
        i.NC_NAME_RE = new RegExp("^[" + i.NC_NAME_START_CHAR + "][" + i.NC_NAME_CHAR + "]*$","u");
        function e(r) {
            return r >= 65 && r <= 90 || r === 95 || r >= 97 && r <= 122 || r >= 192 && r <= 214 || r >= 216 && r <= 246 || r >= 248 && r <= 767 || r >= 880 && r <= 893 || r >= 895 && r <= 8191 || r >= 8204 && r <= 8205 || r >= 8304 && r <= 8591 || r >= 11264 && r <= 12271 || r >= 12289 && r <= 55295 || r >= 63744 && r <= 64975 || r >= 65008 && r <= 65533 || r >= 65536 && r <= 983039
        }
        i.isNCNameStartChar = e;
        function n(r) {
            return e(r) || r === 45 || r === 46 || r >= 48 && r <= 57 || r === 183 || r >= 768 && r <= 879 || r >= 8255 && r <= 8256
        }
        i.isNCNameChar = n
    }
    )(la)),
    la
}
var Gc;
function sm() {
    if (Gc)
        return si;
    Gc = 1,
    Object.defineProperty(si, "__esModule", {
        value: !0
    }),
    si.SaxesParser = si.EVENTS = void 0;
    const i = nm()
      , e = im()
      , n = rm();
    var r = i.isS
      , o = i.isChar
      , a = i.isNameStartChar
      , l = i.isNameChar
      , u = i.S_LIST
      , f = i.NAME_RE
      , h = e.isChar
      , m = n.isNCNameStartChar
      , _ = n.isNCNameChar
      , d = n.NC_NAME_RE;
    const g = "http://www.w3.org/XML/1998/namespace"
      , b = "http://www.w3.org/2000/xmlns/"
      , T = {
        __proto__: null,
        xml: g,
        xmlns: b
    }
      , N = {
        __proto__: null,
        amp: "&",
        gt: ">",
        lt: "<",
        quot: '"',
        apos: "'"
    }
      , A = -1
      , R = -2
      , S = 0
      , y = 1
      , x = 2
      , M = 3
      , U = 4
      , O = 5
      , Q = 6
      , D = 7
      , $ = 8
      , X = 9
      , F = 10
      , B = 11
      , ue = 12
      , P = 13
      , oe = 14
      , j = 15
      , ae = 16
      , I = 17
      , Z = 18
      , ie = 19
      , ee = 20
      , me = 21
      , W = 22
      , G = 23
      , Y = 24
      , K = 25
      , le = 26
      , ce = 27
      , Ee = 28
      , Te = 29
      , q = 30
      , te = 31
      , fe = 32
      , xe = 33
      , Se = 34
      , Ie = 35
      , se = 36
      , be = 37
      , Ne = 38
      , ve = 39
      , $e = 40
      , mt = 41
      , Be = 42
      , ft = 43
      , C = 44
      , v = 9
      , w = 10
      , H = 13
      , re = 32
      , _e = 33
      , we = 34
      , Oe = 38
      , Ye = 39
      , Qe = 45
      , We = 47
      , Ze = 59
      , Bt = 60
      , Yt = 61
      , st = 62
      , at = 63
      , Si = 91
      , cn = 93
      , Pn = 133
      , Zn = 8232
      , z = it=>it === we || it === Ye
      , J = [we, Ye]
      , Ae = [...J, Si, st]
      , Re = [...J, Bt, cn]
      , Me = [Yt, at, ...u]
      , _t = [...u, st, Oe, Bt];
    function bt(it, V, de) {
        switch (V) {
        case "xml":
            de !== g && it.fail(`xml prefix must be bound to ${g}.`);
            break;
        case "xmlns":
            de !== b && it.fail(`xmlns prefix must be bound to ${b}.`);
            break
        }
        switch (de) {
        case b:
            it.fail(V === "" ? `the default namespace may not be set to ${de}.` : `may not assign a prefix (even "xmlns") to the URI ${b}.`);
            break;
        case g:
            switch (V) {
            case "xml":
                break;
            case "":
                it.fail(`the default namespace may not be set to ${de}.`);
                break;
            default:
                it.fail("may not assign the xml namespace to another prefix.")
            }
            break
        }
    }
    function Nt(it, V) {
        for (const de of Object.keys(V))
            bt(it, de, V[de])
    }
    const Pe = it=>d.test(it)
      , Xn = it=>f.test(it)
      , Ut = 0
      , Mn = 1
      , bn = 2;
    si.EVENTS = ["xmldecl", "text", "processinginstruction", "doctype", "comment", "opentagstart", "attribute", "opentag", "closetag", "cdata", "error", "end", "ready"];
    const dn = {
        xmldecl: "xmldeclHandler",
        text: "textHandler",
        processinginstruction: "piHandler",
        doctype: "doctypeHandler",
        comment: "commentHandler",
        opentagstart: "openTagStartHandler",
        attribute: "attributeHandler",
        opentag: "openTagHandler",
        closetag: "closeTagHandler",
        cdata: "cdataHandler",
        error: "errorHandler",
        end: "endHandler",
        ready: "readyHandler"
    };
    class Dn {
        get closed() {
            return this._closed
        }
        constructor(V) {
            this.opt = V ?? {},
            this.fragmentOpt = !!this.opt.fragment;
            const de = this.xmlnsOpt = !!this.opt.xmlns;
            if (this.trackPosition = this.opt.position !== !1,
            this.fileName = this.opt.fileName,
            de) {
                this.nameStartCheck = m,
                this.nameCheck = _,
                this.isName = Pe,
                this.processAttribs = this.processAttribsNS,
                this.pushAttrib = this.pushAttribNS,
                this.ns = Object.assign({
                    __proto__: null
                }, T);
                const pe = this.opt.additionalNamespaces;
                pe != null && (Nt(this, pe),
                Object.assign(this.ns, pe))
            } else
                this.nameStartCheck = a,
                this.nameCheck = l,
                this.isName = Xn,
                this.processAttribs = this.processAttribsPlain,
                this.pushAttrib = this.pushAttribPlain;
            this.stateTable = [this.sBegin, this.sBeginWhitespace, this.sDoctype, this.sDoctypeQuote, this.sDTD, this.sDTDQuoted, this.sDTDOpenWaka, this.sDTDOpenWakaBang, this.sDTDComment, this.sDTDCommentEnding, this.sDTDCommentEnded, this.sDTDPI, this.sDTDPIEnding, this.sText, this.sEntity, this.sOpenWaka, this.sOpenWakaBang, this.sComment, this.sCommentEnding, this.sCommentEnded, this.sCData, this.sCDataEnding, this.sCDataEnding2, this.sPIFirstChar, this.sPIRest, this.sPIBody, this.sPIEnding, this.sXMLDeclNameStart, this.sXMLDeclName, this.sXMLDeclEq, this.sXMLDeclValueStart, this.sXMLDeclValue, this.sXMLDeclSeparator, this.sXMLDeclEnding, this.sOpenTag, this.sOpenTagSlash, this.sAttrib, this.sAttribName, this.sAttribNameSawWhite, this.sAttribValue, this.sAttribValueQuoted, this.sAttribValueClosed, this.sAttribValueUnquoted, this.sCloseTag, this.sCloseTagSawWhite],
            this._init()
        }
        _init() {
            var V;
            this.openWakaBang = "",
            this.text = "",
            this.name = "",
            this.piTarget = "",
            this.entity = "",
            this.q = null,
            this.tags = [],
            this.tag = null,
            this.topNS = null,
            this.chunk = "",
            this.chunkPosition = 0,
            this.i = 0,
            this.prevI = 0,
            this.carriedFromPrevious = void 0,
            this.forbiddenState = Ut,
            this.attribList = [];
            const {fragmentOpt: de} = this;
            this.state = de ? P : S,
            this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = de,
            this.xmlDeclPossible = !de,
            this.xmlDeclExpects = ["version"],
            this.entityReturnState = void 0;
            let {defaultXMLVersion: pe} = this.opt;
            if (pe === void 0) {
                if (this.opt.forceXMLVersion === !0)
                    throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
                pe = "1.0"
            }
            this.setXMLVersion(pe),
            this.positionAtNewLine = 0,
            this.doctype = !1,
            this._closed = !1,
            this.xmlDecl = {
                version: void 0,
                encoding: void 0,
                standalone: void 0
            },
            this.line = 1,
            this.column = 0,
            this.ENTITIES = Object.create(N),
            (V = this.readyHandler) === null || V === void 0 || V.call(this)
        }
        get position() {
            return this.chunkPosition + this.i
        }
        get columnIndex() {
            return this.position - this.positionAtNewLine
        }
        on(V, de) {
            this[dn[V]] = de
        }
        off(V) {
            this[dn[V]] = void 0
        }
        makeError(V) {
            var de;
            let pe = (de = this.fileName) !== null && de !== void 0 ? de : "";
            return this.trackPosition && (pe.length > 0 && (pe += ":"),
            pe += `${this.line}:${this.column}`),
            pe.length > 0 && (pe += ": "),
            new Error(pe + V)
        }
        fail(V) {
            const de = this.makeError(V)
              , pe = this.errorHandler;
            if (pe === void 0)
                throw de;
            return pe(de),
            this
        }
        write(V) {
            if (this.closed)
                return this.fail("cannot write after close; assign an onready handler.");
            let de = !1;
            V === null ? (de = !0,
            V = "") : typeof V == "object" && (V = V.toString()),
            this.carriedFromPrevious !== void 0 && (V = `${this.carriedFromPrevious}${V}`,
            this.carriedFromPrevious = void 0);
            let pe = V.length;
            const ke = V.charCodeAt(pe - 1);
            !de && (ke === H || ke >= 55296 && ke <= 56319) && (this.carriedFromPrevious = V[pe - 1],
            pe--,
            V = V.slice(0, pe));
            const {stateTable: He} = this;
            for (this.chunk = V,
            this.i = 0; this.i < pe; )
                He[this.state].call(this);
            return this.chunkPosition += pe,
            de ? this.end() : this
        }
        close() {
            return this.write(null)
        }
        getCode10() {
            const {chunk: V, i: de} = this;
            if (this.prevI = de,
            this.i = de + 1,
            de >= V.length)
                return A;
            const pe = V.charCodeAt(de);
            if (this.column++,
            pe < 55296) {
                if (pe >= re || pe === v)
                    return pe;
                switch (pe) {
                case w:
                    return this.line++,
                    this.column = 0,
                    this.positionAtNewLine = this.position,
                    w;
                case H:
                    return V.charCodeAt(de + 1) === w && (this.i = de + 2),
                    this.line++,
                    this.column = 0,
                    this.positionAtNewLine = this.position,
                    R;
                default:
                    return this.fail("disallowed character."),
                    pe
                }
            }
            if (pe > 56319)
                return pe >= 57344 && pe <= 65533 || this.fail("disallowed character."),
                pe;
            const ke = 65536 + (pe - 55296) * 1024 + (V.charCodeAt(de + 1) - 56320);
            return this.i = de + 2,
            ke > 1114111 && this.fail("disallowed character."),
            ke
        }
        getCode11() {
            const {chunk: V, i: de} = this;
            if (this.prevI = de,
            this.i = de + 1,
            de >= V.length)
                return A;
            const pe = V.charCodeAt(de);
            if (this.column++,
            pe < 55296) {
                if (pe > 31 && pe < 127 || pe > 159 && pe !== Zn || pe === v)
                    return pe;
                switch (pe) {
                case w:
                    return this.line++,
                    this.column = 0,
                    this.positionAtNewLine = this.position,
                    w;
                case H:
                    {
                        const He = V.charCodeAt(de + 1);
                        (He === w || He === Pn) && (this.i = de + 2)
                    }
                case Pn:
                case Zn:
                    return this.line++,
                    this.column = 0,
                    this.positionAtNewLine = this.position,
                    R;
                default:
                    return this.fail("disallowed character."),
                    pe
                }
            }
            if (pe > 56319)
                return pe >= 57344 && pe <= 65533 || this.fail("disallowed character."),
                pe;
            const ke = 65536 + (pe - 55296) * 1024 + (V.charCodeAt(de + 1) - 56320);
            return this.i = de + 2,
            ke > 1114111 && this.fail("disallowed character."),
            ke
        }
        getCodeNorm() {
            const V = this.getCode();
            return V === R ? w : V
        }
        unget() {
            this.i = this.prevI,
            this.column--
        }
        captureTo(V) {
            let {i: de} = this;
            const {chunk: pe} = this;
            for (; ; ) {
                const ke = this.getCode()
                  , He = ke === R
                  , Je = He ? w : ke;
                if (Je === A || V.includes(Je))
                    return this.text += pe.slice(de, this.prevI),
                    Je;
                He && (this.text += `${pe.slice(de, this.prevI)}
`,
                de = this.i)
            }
        }
        captureToChar(V) {
            let {i: de} = this;
            const {chunk: pe} = this;
            for (; ; ) {
                let ke = this.getCode();
                switch (ke) {
                case R:
                    this.text += `${pe.slice(de, this.prevI)}
`,
                    de = this.i,
                    ke = w;
                    break;
                case A:
                    return this.text += pe.slice(de),
                    !1
                }
                if (ke === V)
                    return this.text += pe.slice(de, this.prevI),
                    !0
            }
        }
        captureNameChars() {
            const {chunk: V, i: de} = this;
            for (; ; ) {
                const pe = this.getCode();
                if (pe === A)
                    return this.name += V.slice(de),
                    A;
                if (!l(pe))
                    return this.name += V.slice(de, this.prevI),
                    pe === R ? w : pe
            }
        }
        skipSpaces() {
            for (; ; ) {
                const V = this.getCodeNorm();
                if (V === A || !r(V))
                    return V
            }
        }
        setXMLVersion(V) {
            this.currentXMLVersion = V,
            V === "1.0" ? (this.isChar = o,
            this.getCode = this.getCode10) : (this.isChar = h,
            this.getCode = this.getCode11)
        }
        sBegin() {
            this.chunk.charCodeAt(0) === 65279 && (this.i++,
            this.column++),
            this.state = y
        }
        sBeginWhitespace() {
            const V = this.i
              , de = this.skipSpaces();
            switch (this.prevI !== V && (this.xmlDeclPossible = !1),
            de) {
            case Bt:
                if (this.state = j,
                this.text.length !== 0)
                    throw new Error("no-empty text at start");
                break;
            case A:
                break;
            default:
                this.unget(),
                this.state = P,
                this.xmlDeclPossible = !1
            }
        }
        sDoctype() {
            var V;
            const de = this.captureTo(Ae);
            switch (de) {
            case st:
                {
                    (V = this.doctypeHandler) === null || V === void 0 || V.call(this, this.text),
                    this.text = "",
                    this.state = P,
                    this.doctype = !0;
                    break
                }
            case A:
                break;
            default:
                this.text += String.fromCodePoint(de),
                de === Si ? this.state = U : z(de) && (this.state = M,
                this.q = de)
            }
        }
        sDoctypeQuote() {
            const V = this.q;
            this.captureToChar(V) && (this.text += String.fromCodePoint(V),
            this.q = null,
            this.state = x)
        }
        sDTD() {
            const V = this.captureTo(Re);
            V !== A && (this.text += String.fromCodePoint(V),
            V === cn ? this.state = x : V === Bt ? this.state = Q : z(V) && (this.state = O,
            this.q = V))
        }
        sDTDQuoted() {
            const V = this.q;
            this.captureToChar(V) && (this.text += String.fromCodePoint(V),
            this.state = U,
            this.q = null)
        }
        sDTDOpenWaka() {
            const V = this.getCodeNorm();
            switch (this.text += String.fromCodePoint(V),
            V) {
            case _e:
                this.state = D,
                this.openWakaBang = "";
                break;
            case at:
                this.state = B;
                break;
            default:
                this.state = U
            }
        }
        sDTDOpenWakaBang() {
            const V = String.fromCodePoint(this.getCodeNorm())
              , de = this.openWakaBang += V;
            this.text += V,
            de !== "-" && (this.state = de === "--" ? $ : U,
            this.openWakaBang = "")
        }
        sDTDComment() {
            this.captureToChar(Qe) && (this.text += "-",
            this.state = X)
        }
        sDTDCommentEnding() {
            const V = this.getCodeNorm();
            this.text += String.fromCodePoint(V),
            this.state = V === Qe ? F : $
        }
        sDTDCommentEnded() {
            const V = this.getCodeNorm();
            this.text += String.fromCodePoint(V),
            V === st ? this.state = U : (this.fail("malformed comment."),
            this.state = $)
        }
        sDTDPI() {
            this.captureToChar(at) && (this.text += "?",
            this.state = ue)
        }
        sDTDPIEnding() {
            const V = this.getCodeNorm();
            this.text += String.fromCodePoint(V),
            V === st && (this.state = U)
        }
        sText() {
            this.tags.length !== 0 ? this.handleTextInRoot() : this.handleTextOutsideRoot()
        }
        sEntity() {
            let {i: V} = this;
            const {chunk: de} = this;
            e: for (; ; )
                switch (this.getCode()) {
                case R:
                    this.entity += `${de.slice(V, this.prevI)}
`,
                    V = this.i;
                    break;
                case Ze:
                    {
                        const {entityReturnState: pe} = this
                          , ke = this.entity + de.slice(V, this.prevI);
                        this.state = pe;
                        let He;
                        ke === "" ? (this.fail("empty entity name."),
                        He = "&;") : (He = this.parseEntity(ke),
                        this.entity = ""),
                        (pe !== P || this.textHandler !== void 0) && (this.text += He);
                        break e
                    }
                case A:
                    this.entity += de.slice(V);
                    break e
                }
        }
        sOpenWaka() {
            const V = this.getCode();
            if (a(V))
                this.state = Se,
                this.unget(),
                this.xmlDeclPossible = !1;
            else
                switch (V) {
                case We:
                    this.state = ft,
                    this.xmlDeclPossible = !1;
                    break;
                case _e:
                    this.state = ae,
                    this.openWakaBang = "",
                    this.xmlDeclPossible = !1;
                    break;
                case at:
                    this.state = G;
                    break;
                default:
                    this.fail("disallowed character in tag name"),
                    this.state = P,
                    this.xmlDeclPossible = !1
                }
        }
        sOpenWakaBang() {
            switch (this.openWakaBang += String.fromCodePoint(this.getCodeNorm()),
            this.openWakaBang) {
            case "[CDATA[":
                !this.sawRoot && !this.reportedTextBeforeRoot && (this.fail("text data outside of root node."),
                this.reportedTextBeforeRoot = !0),
                this.closedRoot && !this.reportedTextAfterRoot && (this.fail("text data outside of root node."),
                this.reportedTextAfterRoot = !0),
                this.state = ee,
                this.openWakaBang = "";
                break;
            case "--":
                this.state = I,
                this.openWakaBang = "";
                break;
            case "DOCTYPE":
                this.state = x,
                (this.doctype || this.sawRoot) && this.fail("inappropriately located doctype declaration."),
                this.openWakaBang = "";
                break;
            default:
                this.openWakaBang.length >= 7 && this.fail("incorrect syntax.")
            }
        }
        sComment() {
            this.captureToChar(Qe) && (this.state = Z)
        }
        sCommentEnding() {
            var V;
            const de = this.getCodeNorm();
            de === Qe ? (this.state = ie,
            (V = this.commentHandler) === null || V === void 0 || V.call(this, this.text),
            this.text = "") : (this.text += `-${String.fromCodePoint(de)}`,
            this.state = I)
        }
        sCommentEnded() {
            const V = this.getCodeNorm();
            V !== st ? (this.fail("malformed comment."),
            this.text += `--${String.fromCodePoint(V)}`,
            this.state = I) : this.state = P
        }
        sCData() {
            this.captureToChar(cn) && (this.state = me)
        }
        sCDataEnding() {
            const V = this.getCodeNorm();
            V === cn ? this.state = W : (this.text += `]${String.fromCodePoint(V)}`,
            this.state = ee)
        }
        sCDataEnding2() {
            var V;
            const de = this.getCodeNorm();
            switch (de) {
            case st:
                {
                    (V = this.cdataHandler) === null || V === void 0 || V.call(this, this.text),
                    this.text = "",
                    this.state = P;
                    break
                }
            case cn:
                this.text += "]";
                break;
            default:
                this.text += `]]${String.fromCodePoint(de)}`,
                this.state = ee
            }
        }
        sPIFirstChar() {
            const V = this.getCodeNorm();
            this.nameStartCheck(V) ? (this.piTarget += String.fromCodePoint(V),
            this.state = Y) : V === at || r(V) ? (this.fail("processing instruction without a target."),
            this.state = V === at ? le : K) : (this.fail("disallowed character in processing instruction name."),
            this.piTarget += String.fromCodePoint(V),
            this.state = Y)
        }
        sPIRest() {
            const {chunk: V, i: de} = this;
            for (; ; ) {
                const pe = this.getCodeNorm();
                if (pe === A) {
                    this.piTarget += V.slice(de);
                    return
                }
                if (!this.nameCheck(pe)) {
                    this.piTarget += V.slice(de, this.prevI);
                    const ke = pe === at;
                    ke || r(pe) ? this.piTarget === "xml" ? (this.xmlDeclPossible || this.fail("an XML declaration must be at the start of the document."),
                    this.state = ke ? xe : ce) : this.state = ke ? le : K : (this.fail("disallowed character in processing instruction name."),
                    this.piTarget += String.fromCodePoint(pe));
                    break
                }
            }
        }
        sPIBody() {
            if (this.text.length === 0) {
                const V = this.getCodeNorm();
                V === at ? this.state = le : r(V) || (this.text = String.fromCodePoint(V))
            } else
                this.captureToChar(at) && (this.state = le)
        }
        sPIEnding() {
            var V;
            const de = this.getCodeNorm();
            if (de === st) {
                const {piTarget: pe} = this;
                pe.toLowerCase() === "xml" && this.fail("the XML declaration must appear at the start of the document."),
                (V = this.piHandler) === null || V === void 0 || V.call(this, {
                    target: pe,
                    body: this.text
                }),
                this.piTarget = this.text = "",
                this.state = P
            } else
                de === at ? this.text += "?" : (this.text += `?${String.fromCodePoint(de)}`,
                this.state = K);
            this.xmlDeclPossible = !1
        }
        sXMLDeclNameStart() {
            const V = this.skipSpaces();
            if (V === at) {
                this.state = xe;
                return
            }
            V !== A && (this.state = Ee,
            this.name = String.fromCodePoint(V))
        }
        sXMLDeclName() {
            const V = this.captureTo(Me);
            if (V === at) {
                this.state = xe,
                this.name += this.text,
                this.text = "",
                this.fail("XML declaration is incomplete.");
                return
            }
            if (r(V) || V === Yt) {
                if (this.name += this.text,
                this.text = "",
                !this.xmlDeclExpects.includes(this.name))
                    switch (this.name.length) {
                    case 0:
                        this.fail("did not expect any more name/value pairs.");
                        break;
                    case 1:
                        this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);
                        break;
                    default:
                        this.fail(`expected one of ${this.xmlDeclExpects.join(", ")}`)
                    }
                this.state = V === Yt ? q : Te
            }
        }
        sXMLDeclEq() {
            const V = this.getCodeNorm();
            if (V === at) {
                this.state = xe,
                this.fail("XML declaration is incomplete.");
                return
            }
            r(V) || (V !== Yt && this.fail("value required."),
            this.state = q)
        }
        sXMLDeclValueStart() {
            const V = this.getCodeNorm();
            if (V === at) {
                this.state = xe,
                this.fail("XML declaration is incomplete.");
                return
            }
            r(V) || (z(V) ? this.q = V : (this.fail("value must be quoted."),
            this.q = re),
            this.state = te)
        }
        sXMLDeclValue() {
            const V = this.captureTo([this.q, at]);
            if (V === at) {
                this.state = xe,
                this.text = "",
                this.fail("XML declaration is incomplete.");
                return
            }
            if (V === A)
                return;
            const de = this.text;
            switch (this.text = "",
            this.name) {
            case "version":
                {
                    this.xmlDeclExpects = ["encoding", "standalone"];
                    const pe = de;
                    this.xmlDecl.version = pe,
                    /^1\.[0-9]+$/.test(pe) ? this.opt.forceXMLVersion || this.setXMLVersion(pe) : this.fail("version number must match /^1\\.[0-9]+$/.");
                    break
                }
            case "encoding":
                /^[A-Za-z][A-Za-z0-9._-]*$/.test(de) || this.fail("encoding value must match 	/^[A-Za-z0-9][A-Za-z0-9._-]*$/."),
                this.xmlDeclExpects = ["standalone"],
                this.xmlDecl.encoding = de;
                break;
            case "standalone":
                de !== "yes" && de !== "no" && this.fail('standalone value must match "yes" or "no".'),
                this.xmlDeclExpects = [],
                this.xmlDecl.standalone = de;
                break
            }
            this.name = "",
            this.state = fe
        }
        sXMLDeclSeparator() {
            const V = this.getCodeNorm();
            if (V === at) {
                this.state = xe;
                return
            }
            r(V) || (this.fail("whitespace required."),
            this.unget()),
            this.state = ce
        }
        sXMLDeclEnding() {
            var V;
            this.getCodeNorm() === st ? (this.piTarget !== "xml" ? this.fail("processing instructions are not allowed before root.") : this.name !== "version" && this.xmlDeclExpects.includes("version") && this.fail("XML declaration must contain a version."),
            (V = this.xmldeclHandler) === null || V === void 0 || V.call(this, this.xmlDecl),
            this.name = "",
            this.piTarget = this.text = "",
            this.state = P) : this.fail("The character ? is disallowed anywhere in XML declarations."),
            this.xmlDeclPossible = !1
        }
        sOpenTag() {
            var V;
            const de = this.captureNameChars();
            if (de === A)
                return;
            const pe = this.tag = {
                name: this.name,
                attributes: Object.create(null)
            };
            switch (this.name = "",
            this.xmlnsOpt && (this.topNS = pe.ns = Object.create(null)),
            (V = this.openTagStartHandler) === null || V === void 0 || V.call(this, pe),
            this.sawRoot = !0,
            !this.fragmentOpt && this.closedRoot && this.fail("documents may contain only one root."),
            de) {
            case st:
                this.openTag();
                break;
            case We:
                this.state = Ie;
                break;
            default:
                r(de) || this.fail("disallowed character in tag name."),
                this.state = se
            }
        }
        sOpenTagSlash() {
            this.getCode() === st ? this.openSelfClosingTag() : (this.fail("forward-slash in opening tag not followed by >."),
            this.state = se)
        }
        sAttrib() {
            const V = this.skipSpaces();
            V !== A && (a(V) ? (this.unget(),
            this.state = be) : V === st ? this.openTag() : V === We ? this.state = Ie : this.fail("disallowed character in attribute name."))
        }
        sAttribName() {
            const V = this.captureNameChars();
            V === Yt ? this.state = ve : r(V) ? this.state = Ne : V === st ? (this.fail("attribute without value."),
            this.pushAttrib(this.name, this.name),
            this.name = this.text = "",
            this.openTag()) : V !== A && this.fail("disallowed character in attribute name.")
        }
        sAttribNameSawWhite() {
            const V = this.skipSpaces();
            switch (V) {
            case A:
                return;
            case Yt:
                this.state = ve;
                break;
            default:
                this.fail("attribute without value."),
                this.text = "",
                this.name = "",
                V === st ? this.openTag() : a(V) ? (this.unget(),
                this.state = be) : (this.fail("disallowed character in attribute name."),
                this.state = se)
            }
        }
        sAttribValue() {
            const V = this.getCodeNorm();
            z(V) ? (this.q = V,
            this.state = $e) : r(V) || (this.fail("unquoted attribute value."),
            this.state = Be,
            this.unget())
        }
        sAttribValueQuoted() {
            const {q: V, chunk: de} = this;
            let {i: pe} = this;
            for (; ; )
                switch (this.getCode()) {
                case V:
                    this.pushAttrib(this.name, this.text + de.slice(pe, this.prevI)),
                    this.name = this.text = "",
                    this.q = null,
                    this.state = mt;
                    return;
                case Oe:
                    this.text += de.slice(pe, this.prevI),
                    this.state = oe,
                    this.entityReturnState = $e;
                    return;
                case w:
                case R:
                case v:
                    this.text += `${de.slice(pe, this.prevI)} `,
                    pe = this.i;
                    break;
                case Bt:
                    this.text += de.slice(pe, this.prevI),
                    this.fail("disallowed character.");
                    return;
                case A:
                    this.text += de.slice(pe);
                    return
                }
        }
        sAttribValueClosed() {
            const V = this.getCodeNorm();
            r(V) ? this.state = se : V === st ? this.openTag() : V === We ? this.state = Ie : a(V) ? (this.fail("no whitespace between attributes."),
            this.unget(),
            this.state = be) : this.fail("disallowed character in attribute name.")
        }
        sAttribValueUnquoted() {
            const V = this.captureTo(_t);
            switch (V) {
            case Oe:
                this.state = oe,
                this.entityReturnState = Be;
                break;
            case Bt:
                this.fail("disallowed character.");
                break;
            case A:
                break;
            default:
                this.text.includes("]]>") && this.fail('the string "]]>" is disallowed in char data.'),
                this.pushAttrib(this.name, this.text),
                this.name = this.text = "",
                V === st ? this.openTag() : this.state = se
            }
        }
        sCloseTag() {
            const V = this.captureNameChars();
            V === st ? this.closeTag() : r(V) ? this.state = C : V !== A && this.fail("disallowed character in closing tag.")
        }
        sCloseTagSawWhite() {
            switch (this.skipSpaces()) {
            case st:
                this.closeTag();
                break;
            case A:
                break;
            default:
                this.fail("disallowed character in closing tag.")
            }
        }
        handleTextInRoot() {
            let {i: V, forbiddenState: de} = this;
            const {chunk: pe, textHandler: ke} = this;
            e: for (; ; )
                switch (this.getCode()) {
                case Bt:
                    {
                        if (this.state = j,
                        ke !== void 0) {
                            const {text: He} = this
                              , Je = pe.slice(V, this.prevI);
                            He.length !== 0 ? (ke(He + Je),
                            this.text = "") : Je.length !== 0 && ke(Je)
                        }
                        de = Ut;
                        break e
                    }
                case Oe:
                    this.state = oe,
                    this.entityReturnState = P,
                    ke !== void 0 && (this.text += pe.slice(V, this.prevI)),
                    de = Ut;
                    break e;
                case cn:
                    switch (de) {
                    case Ut:
                        de = Mn;
                        break;
                    case Mn:
                        de = bn;
                        break;
                    case bn:
                        break;
                    default:
                        throw new Error("impossible state")
                    }
                    break;
                case st:
                    de === bn && this.fail('the string "]]>" is disallowed in char data.'),
                    de = Ut;
                    break;
                case R:
                    ke !== void 0 && (this.text += `${pe.slice(V, this.prevI)}
`),
                    V = this.i,
                    de = Ut;
                    break;
                case A:
                    ke !== void 0 && (this.text += pe.slice(V));
                    break e;
                default:
                    de = Ut
                }
            this.forbiddenState = de
        }
        handleTextOutsideRoot() {
            let {i: V} = this;
            const {chunk: de, textHandler: pe} = this;
            let ke = !1;
            e: for (; ; ) {
                const He = this.getCode();
                switch (He) {
                case Bt:
                    {
                        if (this.state = j,
                        pe !== void 0) {
                            const {text: Je} = this
                              , wt = de.slice(V, this.prevI);
                            Je.length !== 0 ? (pe(Je + wt),
                            this.text = "") : wt.length !== 0 && pe(wt)
                        }
                        break e
                    }
                case Oe:
                    this.state = oe,
                    this.entityReturnState = P,
                    pe !== void 0 && (this.text += de.slice(V, this.prevI)),
                    ke = !0;
                    break e;
                case R:
                    pe !== void 0 && (this.text += `${de.slice(V, this.prevI)}
`),
                    V = this.i;
                    break;
                case A:
                    pe !== void 0 && (this.text += de.slice(V));
                    break e;
                default:
                    r(He) || (ke = !0)
                }
            }
            ke && (!this.sawRoot && !this.reportedTextBeforeRoot && (this.fail("text data outside of root node."),
            this.reportedTextBeforeRoot = !0),
            this.closedRoot && !this.reportedTextAfterRoot && (this.fail("text data outside of root node."),
            this.reportedTextAfterRoot = !0))
        }
        pushAttribNS(V, de) {
            var pe;
            const {prefix: ke, local: He} = this.qname(V)
              , Je = {
                name: V,
                prefix: ke,
                local: He,
                value: de
            };
            if (this.attribList.push(Je),
            (pe = this.attributeHandler) === null || pe === void 0 || pe.call(this, Je),
            ke === "xmlns") {
                const wt = de.trim();
                this.currentXMLVersion === "1.0" && wt === "" && this.fail("invalid attempt to undefine prefix in XML 1.0"),
                this.topNS[He] = wt,
                bt(this, He, wt)
            } else if (V === "xmlns") {
                const wt = de.trim();
                this.topNS[""] = wt,
                bt(this, "", wt)
            }
        }
        pushAttribPlain(V, de) {
            var pe;
            const ke = {
                name: V,
                value: de
            };
            this.attribList.push(ke),
            (pe = this.attributeHandler) === null || pe === void 0 || pe.call(this, ke)
        }
        end() {
            var V, de;
            this.sawRoot || this.fail("document must contain a root element.");
            const {tags: pe} = this;
            for (; pe.length > 0; ) {
                const He = pe.pop();
                this.fail(`unclosed tag: ${He.name}`)
            }
            this.state !== S && this.state !== P && this.fail("unexpected end.");
            const {text: ke} = this;
            return ke.length !== 0 && ((V = this.textHandler) === null || V === void 0 || V.call(this, ke),
            this.text = ""),
            this._closed = !0,
            (de = this.endHandler) === null || de === void 0 || de.call(this),
            this._init(),
            this
        }
        resolve(V) {
            var de, pe;
            let ke = this.topNS[V];
            if (ke !== void 0)
                return ke;
            const {tags: He} = this;
            for (let Je = He.length - 1; Je >= 0; Je--)
                if (ke = He[Je].ns[V],
                ke !== void 0)
                    return ke;
            return ke = this.ns[V],
            ke !== void 0 ? ke : (pe = (de = this.opt).resolvePrefix) === null || pe === void 0 ? void 0 : pe.call(de, V)
        }
        qname(V) {
            const de = V.indexOf(":");
            if (de === -1)
                return {
                    prefix: "",
                    local: V
                };
            const pe = V.slice(de + 1)
              , ke = V.slice(0, de);
            return (ke === "" || pe === "" || pe.includes(":")) && this.fail(`malformed name: ${V}.`),
            {
                prefix: ke,
                local: pe
            }
        }
        processAttribsNS() {
            var V;
            const {attribList: de} = this
              , pe = this.tag;
            {
                const {prefix: Je, local: wt} = this.qname(pe.name);
                pe.prefix = Je,
                pe.local = wt;
                const en = pe.uri = (V = this.resolve(Je)) !== null && V !== void 0 ? V : "";
                Je !== "" && (Je === "xmlns" && this.fail('tags may not have "xmlns" as prefix.'),
                en === "" && (this.fail(`unbound namespace prefix: ${JSON.stringify(Je)}.`),
                pe.uri = Je))
            }
            if (de.length === 0)
                return;
            const {attributes: ke} = pe
              , He = new Set;
            for (const Je of de) {
                const {name: wt, prefix: en, local: ro} = Je;
                let On, Qn;
                en === "" ? (On = wt === "xmlns" ? b : "",
                Qn = wt) : (On = this.resolve(en),
                On === void 0 && (this.fail(`unbound namespace prefix: ${JSON.stringify(en)}.`),
                On = en),
                Qn = `{${On}}${ro}`),
                He.has(Qn) && this.fail(`duplicate attribute: ${Qn}.`),
                He.add(Qn),
                Je.uri = On,
                ke[wt] = Je
            }
            this.attribList = []
        }
        processAttribsPlain() {
            const {attribList: V} = this
              , de = this.tag.attributes;
            for (const {name: pe, value: ke} of V)
                de[pe] !== void 0 && this.fail(`duplicate attribute: ${pe}.`),
                de[pe] = ke;
            this.attribList = []
        }
        openTag() {
            var V;
            this.processAttribs();
            const {tags: de} = this
              , pe = this.tag;
            pe.isSelfClosing = !1,
            (V = this.openTagHandler) === null || V === void 0 || V.call(this, pe),
            de.push(pe),
            this.state = P,
            this.name = ""
        }
        openSelfClosingTag() {
            var V, de, pe;
            this.processAttribs();
            const {tags: ke} = this
              , He = this.tag;
            He.isSelfClosing = !0,
            (V = this.openTagHandler) === null || V === void 0 || V.call(this, He),
            (de = this.closeTagHandler) === null || de === void 0 || de.call(this, He),
            (this.tag = (pe = ke[ke.length - 1]) !== null && pe !== void 0 ? pe : null) === null && (this.closedRoot = !0),
            this.state = P,
            this.name = ""
        }
        closeTag() {
            const {tags: V, name: de} = this;
            if (this.state = P,
            this.name = "",
            de === "") {
                this.fail("weird empty close tag."),
                this.text += "</>";
                return
            }
            const pe = this.closeTagHandler;
            let ke = V.length;
            for (; ke-- > 0; ) {
                const He = this.tag = V.pop();
                if (this.topNS = He.ns,
                pe?.(He),
                He.name === de)
                    break;
                this.fail("unexpected close tag.")
            }
            ke === 0 ? this.closedRoot = !0 : ke < 0 && (this.fail(`unmatched closing tag: ${de}.`),
            this.text += `</${de}>`)
        }
        parseEntity(V) {
            if (V[0] !== "#") {
                const pe = this.ENTITIES[V];
                return pe !== void 0 ? pe : (this.fail(this.isName(V) ? "undefined entity." : "disallowed character in entity name."),
                `&${V};`)
            }
            let de = NaN;
            return V[1] === "x" && /^#x[0-9a-f]+$/i.test(V) ? de = parseInt(V.slice(2), 16) : /^#[0-9]+$/.test(V) && (de = parseInt(V.slice(1), 10)),
            this.isChar(de) ? String.fromCodePoint(de) : (this.fail("malformed character entity."),
            `&${V};`)
        }
    }
    return si.SaxesParser = Dn,
    si
}
var gr = {}, Wc;
function om() {
    if (Wc)
        return gr;
    Wc = 1,
    Object.defineProperty(gr, "__esModule", {
        value: !0
    }),
    gr.ParseError = void 0;
    let i = class extends Error {
        constructor(n, r) {
            const o = n.saxParser;
            super(n.trackPosition ? `Line ${o.line} column ${o.column + 1}: ${r}` : r)
        }
    }
    ;
    return gr.ParseError = i,
    gr
}
var oi = {}, mr = {}, Zc;
function Sf() {
    if (Zc)
        return mr;
    Zc = 1,
    Object.defineProperty(mr, "__esModule", {
        value: !0
    }),
    mr.BlankNode = void 0;
    class i {
        constructor(n) {
            this.termType = "BlankNode",
            this.value = n
        }
        equals(n) {
            return !!n && n.termType === "BlankNode" && n.value === this.value
        }
    }
    return mr.BlankNode = i,
    mr
}
var _r = {}, yr = {}, Xc;
function Tf() {
    if (Xc)
        return yr;
    Xc = 1,
    Object.defineProperty(yr, "__esModule", {
        value: !0
    }),
    yr.DefaultGraph = void 0;
    class i {
        constructor() {
            this.termType = "DefaultGraph",
            this.value = ""
        }
        equals(n) {
            return !!n && n.termType === "DefaultGraph"
        }
    }
    return yr.DefaultGraph = i,
    i.INSTANCE = new i,
    yr
}
var vr = {}, br = {}, Qc;
function ql() {
    if (Qc)
        return br;
    Qc = 1,
    Object.defineProperty(br, "__esModule", {
        value: !0
    }),
    br.NamedNode = void 0;
    class i {
        constructor(n) {
            this.termType = "NamedNode",
            this.value = n
        }
        equals(n) {
            return !!n && n.termType === "NamedNode" && n.value === this.value
        }
    }
    return br.NamedNode = i,
    br
}
var Jc;
function Lf() {
    if (Jc)
        return vr;
    Jc = 1,
    Object.defineProperty(vr, "__esModule", {
        value: !0
    }),
    vr.Literal = void 0;
    const i = ql();
    class e {
        constructor(r, o) {
            this.termType = "Literal",
            this.value = r,
            typeof o == "string" ? (this.language = o,
            this.datatype = e.RDF_LANGUAGE_STRING,
            this.direction = "") : o ? "termType"in o ? (this.language = "",
            this.datatype = o,
            this.direction = "") : (this.language = o.language,
            this.datatype = o.direction ? e.RDF_DIRECTIONAL_LANGUAGE_STRING : e.RDF_LANGUAGE_STRING,
            this.direction = o.direction || "") : (this.language = "",
            this.datatype = e.XSD_STRING,
            this.direction = "")
        }
        equals(r) {
            return !!r && r.termType === "Literal" && r.value === this.value && r.language === this.language && (r.direction === this.direction || !r.direction && this.direction === "") && this.datatype.equals(r.datatype)
        }
    }
    return vr.Literal = e,
    e.RDF_LANGUAGE_STRING = new i.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString"),
    e.RDF_DIRECTIONAL_LANGUAGE_STRING = new i.NamedNode("http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString"),
    e.XSD_STRING = new i.NamedNode("http://www.w3.org/2001/XMLSchema#string"),
    vr
}
var wr = {}, Kc;
function If() {
    if (Kc)
        return wr;
    Kc = 1,
    Object.defineProperty(wr, "__esModule", {
        value: !0
    }),
    wr.Quad = void 0;
    class i {
        constructor(n, r, o, a) {
            this.termType = "Quad",
            this.value = "",
            this.subject = n,
            this.predicate = r,
            this.object = o,
            this.graph = a
        }
        equals(n) {
            return !!n && (n.termType === "Quad" || !n.termType) && this.subject.equals(n.subject) && this.predicate.equals(n.predicate) && this.object.equals(n.object) && this.graph.equals(n.graph)
        }
    }
    return wr.Quad = i,
    wr
}
var xr = {}, Yc;
function Nf() {
    if (Yc)
        return xr;
    Yc = 1,
    Object.defineProperty(xr, "__esModule", {
        value: !0
    }),
    xr.Variable = void 0;
    class i {
        constructor(n) {
            this.termType = "Variable",
            this.value = n
        }
        equals(n) {
            return !!n && n.termType === "Variable" && n.value === this.value
        }
    }
    return xr.Variable = i,
    xr
}
var ed;
function am() {
    if (ed)
        return _r;
    ed = 1,
    Object.defineProperty(_r, "__esModule", {
        value: !0
    }),
    _r.DataFactory = void 0;
    const i = Sf()
      , e = Tf()
      , n = Lf()
      , r = ql()
      , o = If()
      , a = Nf();
    let l = 0;
    class u {
        constructor(h) {
            this.blankNodeCounter = 0,
            h = h || {},
            this.blankNodePrefix = h.blankNodePrefix || `df_ ${l++}_`
        }
        namedNode(h) {
            return new r.NamedNode(h)
        }
        blankNode(h) {
            return new i.BlankNode(h || `${this.blankNodePrefix}${this.blankNodeCounter++}`)
        }
        literal(h, m) {
            return new n.Literal(h,m)
        }
        variable(h) {
            return new a.Variable(h)
        }
        defaultGraph() {
            return e.DefaultGraph.INSTANCE
        }
        quad(h, m, _, d) {
            return new o.Quad(h,m,_,d || this.defaultGraph())
        }
        fromTerm(h) {
            switch (h.termType) {
            case "NamedNode":
                return this.namedNode(h.value);
            case "BlankNode":
                return this.blankNode(h.value);
            case "Literal":
                return h.language ? this.literal(h.value, h.language) : h.datatype.equals(n.Literal.XSD_STRING) ? this.literal(h.value) : this.literal(h.value, this.fromTerm(h.datatype));
            case "Variable":
                return this.variable(h.value);
            case "DefaultGraph":
                return this.defaultGraph();
            case "Quad":
                return this.quad(this.fromTerm(h.subject), this.fromTerm(h.predicate), this.fromTerm(h.object), this.fromTerm(h.graph))
            }
        }
        fromQuad(h) {
            return this.fromTerm(h)
        }
        resetBlankNodeCounter() {
            this.blankNodeCounter = 0
        }
    }
    return _r.DataFactory = u,
    _r
}
var td;
function Af() {
    return td || (td = 1,
    (function(i) {
        var e = oi && oi.__createBinding || (Object.create ? (function(r, o, a, l) {
            l === void 0 && (l = a);
            var u = Object.getOwnPropertyDescriptor(o, a);
            (!u || ("get"in u ? !o.__esModule : u.writable || u.configurable)) && (u = {
                enumerable: !0,
                get: function() {
                    return o[a]
                }
            }),
            Object.defineProperty(r, l, u)
        }
        ) : (function(r, o, a, l) {
            l === void 0 && (l = a),
            r[l] = o[a]
        }
        ))
          , n = oi && oi.__exportStar || function(r, o) {
            for (var a in r)
                a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && e(o, r, a)
        }
        ;
        Object.defineProperty(i, "__esModule", {
            value: !0
        }),
        n(Sf(), i),
        n(am(), i),
        n(Tf(), i),
        n(Lf(), i),
        n(ql(), i),
        n(If(), i),
        n(Nf(), i)
    }
    )(oi)),
    oi
}
var ai = {}, ua = {}, nd;
function lm() {
    return nd || (nd = 1,
    (function(i) {
        Object.defineProperty(i, "__esModule", {
            value: !0
        }),
        i.validateIri = i.IriValidationStrategy = void 0;
        function e() {
            const u = "[!$&'()*+,;=]"
              , f = "%[a-fA-F0-9]{2}"
              , h = "([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])"
              , m = `${h}\\.${h}\\.${h}\\.${h}`
              , _ = "[a-fA-F0-9]{1,4}"
              , d = `(${_}:${_}|${m})`
              , g = `((${_}:){6}${d}|::(${_}:){5}${d}|(${_})?::(${_}:){4}${d}|((${_}:){0,1}${_})?::(${_}:){3}${d}|((${_}:){0,2}${_})?::(${_}:){2}${d}|((${_}:){0,3}${_})?::${_}:${d}|((${_}:){0,4}${_})?::${d}|((${_}:){0,5}${_})?::${_}|((${_}:){0,6}${_})?::)`
              , b = `v[a-fA-F0-9]+\\.(${u}|${u}|":)+`
              , T = `\\[(${g}|${b})\\]`
              , N = "[0-9]*"
              , A = "[a-zA-Z][a-zA-Z0-9+\\-.]*"
              , S = "[---]"
              , M = "[a-zA-Z0-9\\-._~-----------------]"
              , U = `(${M}|${f}|${u}|[:@])*`
              , O = `(${U}|[\\/?])*`
              , Q = `(${U}|${S}|[\\/?])*`
              , D = `(${U})+`
              , $ = `(${U})*`
              , X = ""
              , F = `${D}(\\/${$})*`
              , B = `\\/(${D}(\\/${$})*)?`
              , ue = `(\\/${$})*`
              , P = `(${M}|${f}|${u})*`
              , oe = `(${T}|${m}|${P})`
              , I = `(\\/\\/${`(${`(${M}|${f}|${u}|:)*`}@)?${oe}(:${N})?`}${ue}|${B}|${F}|${X})`
              , Z = `^${A}:${I}(\\?${Q})?(#${O})?$`;
            return new RegExp(Z,"u")
        }
        const n = e()
          , r = /^[A-Za-z][\d+-.A-Za-z]*:[^\u0000-\u0020"<>\\^`{|}]*$/u;
        var o;
        (function(l) {
            l.Strict = "strict",
            l.Pragmatic = "pragmatic",
            l.None = "none"
        }
        )(o = i.IriValidationStrategy || (i.IriValidationStrategy = {}));
        function a(l, u=o.Strict) {
            switch (u) {
            case o.Strict:
                return n.test(l) ? void 0 : new Error(`Invalid IRI according to RFC 3987: '${l}'`);
            case o.Pragmatic:
                return r.test(l) ? void 0 : new Error(`Invalid IRI according to RDF Turtle: '${l}'`);
            case o.None:
                return;
            default:
                return new Error(`Not supported validation strategy "${u}"`)
            }
        }
        i.validateIri = a
    }
    )(ua)),
    ua
}
var id;
function um() {
    return id || (id = 1,
    (function(i) {
        var e = ai && ai.__createBinding || (Object.create ? (function(r, o, a, l) {
            l === void 0 && (l = a);
            var u = Object.getOwnPropertyDescriptor(o, a);
            (!u || ("get"in u ? !o.__esModule : u.writable || u.configurable)) && (u = {
                enumerable: !0,
                get: function() {
                    return o[a]
                }
            }),
            Object.defineProperty(r, l, u)
        }
        ) : (function(r, o, a, l) {
            l === void 0 && (l = a),
            r[l] = o[a]
        }
        ))
          , n = ai && ai.__exportStar || function(r, o) {
            for (var a in r)
                a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && e(o, r, a)
        }
        ;
        Object.defineProperty(i, "__esModule", {
            value: !0
        }),
        n(lm(), i)
    }
    )(ai)),
    ai
}
var rd;
function cm() {
    if (rd)
        return ii;
    rd = 1,
    Object.defineProperty(ii, "__esModule", {
        value: !0
    }),
    ii.ParseType = ii.RdfXmlParser = void 0;
    const i = tm()
      , e = sm()
      , n = _f()
      , r = om()
      , o = Af()
      , a = um();
    let l = class tt extends n.Transform {
        constructor(h) {
            super({
                readableObjectMode: !0
            }),
            this.activeTagStack = [],
            this.nodeIds = {},
            h && (Object.assign(this, h),
            this.options = h),
            this.dataFactory || (this.dataFactory = new o.DataFactory),
            this.baseIRI || (this.baseIRI = ""),
            this.defaultGraph || (this.defaultGraph = this.dataFactory.defaultGraph()),
            this.validateUri !== !1 && (this.validateUri = !0),
            this.iriValidationStrategy || (this.iriValidationStrategy = this.validateUri ? a.IriValidationStrategy.Pragmatic : a.IriValidationStrategy.None),
            this.saxParser = new e.SaxesParser({
                xmlns: !0,
                position: this.trackPosition
            }),
            this.attachSaxListeners()
        }
        import(h) {
            const m = new n.PassThrough({
                readableObjectMode: !0
            });
            h.on("error", d=>_.emit("error", d)),
            h.on("data", d=>m.push(d)),
            h.on("end", ()=>m.push(null));
            const _ = m.pipe(new tt(this.options));
            return _
        }
        _transform(h, m, _) {
            try {
                this.saxParser.write(h)
            } catch (d) {
                return _(d)
            }
            _()
        }
        newParseError(h) {
            return new r.ParseError(this,h)
        }
        valueToUri(h, m) {
            return this.uriToNamedNode((0,
            i.resolve)(h, m.baseIRI))
        }
        uriToNamedNode(h) {
            const m = (0,
            a.validateIri)(h, this.iriValidationStrategy);
            if (m instanceof Error)
                throw this.newParseError(m.message);
            return this.dataFactory.namedNode(h)
        }
        validateNcname(h) {
            if (!tt.NCNAME_MATCHER.test(h))
                throw this.newParseError(`Not a valid NCName: ${h}`)
        }
        createLiteral(h, m) {
            return this.dataFactory.literal(h, m.datatype ? m.datatype : m.language ? {
                language: m.language,
                direction: m.rdfVersion ? m.direction : void 0
            } : void 0)
        }
        attachSaxListeners() {
            this.saxParser.on("error", h=>this.emit("error", h)),
            this.saxParser.on("opentag", this.onTag.bind(this)),
            this.saxParser.on("text", this.onText.bind(this)),
            this.saxParser.on("cdata", this.onText.bind(this)),
            this.saxParser.on("closetag", this.onCloseTag.bind(this)),
            this.saxParser.on("doctype", this.onDoctype.bind(this))
        }
        onTag(h) {
            const m = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;
            let _ = u.RESOURCE;
            if (m && (m.hadChildren = !0,
            _ = m.childrenParseType),
            m && m.childrenStringTags) {
                const g = h.name;
                let b = "";
                for (const {key: R, value: S} of m.namespaces || [])
                    b += ` ${R}="${S}"`;
                for (const R in h.attributes)
                    b += ` ${R}="${h.attributes[R].value}"`;
                const N = `<${`${g}${b}`}>`;
                m.childrenStringTags.push(N);
                const A = {
                    childrenStringTags: m.childrenStringTags
                };
                A.childrenStringEmitClosingTag = `</${g}>`,
                this.activeTagStack.push(A);
                return
            }
            const d = {};
            m ? (d.language = m.language,
            d.direction = m.direction,
            d.baseIRI = m.baseIRI,
            d.childrenTripleTerms = m.childrenTripleTerms,
            d.rdfVersion = m.rdfVersion) : d.baseIRI = this.baseIRI,
            this.activeTagStack.push(d),
            _ === u.RESOURCE ? this.onTagResource(h, d, m, !m) : this.onTagProperty(h, d, m);
            for (const g in h.attributes) {
                const b = h.attributes[g];
                b.prefix === "xmlns" && (d.namespaces || (d.namespaces = []),
                d.namespaces.push({
                    key: `${b.prefix}:${b.local}`,
                    value: b.value
                }))
            }
            m && m.namespaces && (d.namespaces = [...d.namespaces || [], ...m.namespaces])
        }
        onTagResource(h, m, _, d) {
            m.childrenParseType = u.PROPERTY;
            let g = !0;
            if (h.uri === tt.RDF) {
                if (!d && tt.FORBIDDEN_NODE_ELEMENTS.indexOf(h.local) >= 0)
                    throw this.newParseError(`Illegal node element name: ${h.local}`);
                switch (h.local) {
                case "RDF":
                    m.childrenParseType = u.RESOURCE;
                case "Description":
                    g = !1
                }
            }
            const b = []
              , T = [];
            let N = null
              , A = !1
              , R = !1
              , S = null;
            for (const y in h.attributes) {
                const x = h.attributes[y];
                if (x.uri === tt.RDF && x.local === "version") {
                    this.setVersion(m, x.value);
                    continue
                } else if (_ && x.uri === tt.RDF)
                    switch (x.local) {
                    case "about":
                        if (N)
                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${x.value} and ${N} where found.`);
                        N = x.value;
                        continue;
                    case "ID":
                        if (N)
                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${x.value} and ${N} where found.`);
                        this.validateNcname(x.value),
                        N = "#" + x.value,
                        A = !0;
                        continue;
                    case "nodeID":
                        if (N)
                            throw this.newParseError(`Only one of rdf:about, rdf:nodeID and rdf:ID can be present, while ${x.value} and ${N} where found.`);
                        this.validateNcname(x.value),
                        N = x.value,
                        R = !0;
                        continue;
                    case "bagID":
                        throw this.newParseError("rdf:bagID is not supported.");
                    case "type":
                        S = x.value;
                        continue;
                    case "aboutEach":
                        throw this.newParseError("rdf:aboutEach is not supported.");
                    case "aboutEachPrefix":
                        throw this.newParseError("rdf:aboutEachPrefix is not supported.");
                    case "li":
                        throw this.newParseError("rdf:li on node elements are not supported.")
                    }
                else if (x.uri === tt.XML) {
                    if (x.local === "lang") {
                        m.language = x.value === "" ? null : x.value.toLowerCase();
                        continue
                    } else if (x.local === "base") {
                        m.baseIRI = (0,
                        i.resolve)(x.value, m.baseIRI);
                        continue
                    }
                } else if (x.uri === tt.ITS && x.local === "dir") {
                    this.setDirection(m, x.value);
                    continue
                }
                x.prefix !== "xml" && x.prefix !== "xmlns" && (x.prefix !== "" || x.local !== "xmlns") && x.uri && (b.push(this.uriToNamedNode(x.uri + x.local)),
                T.push(x.value))
            }
            if (N !== null && (m.subject = R ? this.dataFactory.blankNode(N) : this.valueToUri(N, m),
            A && this.claimNodeId(m.subject)),
            m.subject || (m.subject = this.dataFactory.blankNode()),
            g) {
                const y = this.uriToNamedNode(h.uri + h.local);
                this.emitTriple(m.subject, this.dataFactory.namedNode(tt.RDF + "type"), y, _ ? _.reifiedStatementId : null, m.childrenTripleTerms, m.reifier)
            }
            if (_) {
                if (_.predicate)
                    if (_.childrenCollectionSubject) {
                        const y = this.dataFactory.blankNode()
                          , x = this.dataFactory.namedNode(tt.RDF + "rest")
                          , M = _.childrenCollectionPredicate.equals(x);
                        this.emitTriple(_.childrenCollectionSubject, _.childrenCollectionPredicate, y, M ? null : _.reifiedStatementId, _.childrenTripleTerms, M ? null : _.reifier),
                        this.emitTriple(y, this.dataFactory.namedNode(tt.RDF + "first"), m.subject, null, m.childrenTripleTerms),
                        _.childrenCollectionSubject = y,
                        _.childrenCollectionPredicate = x
                    } else {
                        _.childrenTagsToTripleTerms || (this.emitTriple(_.subject, _.predicate, m.subject, _.reifiedStatementId, _.childrenTripleTerms, _.reifier),
                        _.predicateEmitted = !0);
                        for (let y = 0; y < _.predicateSubPredicates.length; y++)
                            this.emitTriple(m.subject, _.predicateSubPredicates[y], _.predicateSubObjects[y], null, _.childrenTripleTerms, _.reifier);
                        _.predicateSubPredicates = [],
                        _.predicateSubObjects = []
                    }
                for (let y = 0; y < b.length; y++) {
                    const x = this.createLiteral(T[y], m);
                    this.emitTriple(m.subject, b[y], x, _.reifiedStatementId, _.childrenTripleTerms, _.reifier)
                }
                S && this.emitTriple(m.subject, this.dataFactory.namedNode(tt.RDF + "type"), this.uriToNamedNode(S), null, m.childrenTripleTerms, m.reifier)
            }
        }
        onTagProperty(h, m, _) {
            if (m.childrenParseType = u.RESOURCE,
            m.subject = _.subject,
            h.uri === tt.RDF && h.local === "li" ? (_.listItemCounter || (_.listItemCounter = 1),
            m.predicate = this.uriToNamedNode(h.uri + "_" + _.listItemCounter++)) : m.predicate = this.uriToNamedNode(h.uri + h.local),
            h.uri === tt.RDF && tt.FORBIDDEN_PROPERTY_ELEMENTS.indexOf(h.local) >= 0)
                throw this.newParseError(`Illegal property element name: ${h.local}`);
            m.predicateSubPredicates = [],
            m.predicateSubObjects = [];
            let d = !1
              , g = !1
              , b = null
              , T = !0;
            const N = []
              , A = [];
            for (const R in h.attributes) {
                const S = h.attributes[R];
                if (S.uri === tt.RDF && S.local === "version") {
                    this.setVersion(m, S.value);
                    continue
                } else if (S.uri === tt.RDF)
                    switch (S.local) {
                    case "resource":
                        if (b)
                            throw this.newParseError(`Found both rdf:resource (${S.value}) and rdf:nodeID (${b}).`);
                        if (d)
                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:resource (${S.value})`);
                        m.hadChildren = !0,
                        b = S.value,
                        T = !1;
                        continue;
                    case "datatype":
                        if (g)
                            throw this.newParseError(`Found both non-rdf:* property attributes and rdf:datatype (${S.value}).`);
                        if (d)
                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${S.value})`);
                        m.datatype = this.valueToUri(S.value, m);
                        continue;
                    case "nodeID":
                        if (g)
                            throw this.newParseError(`Found both non-rdf:* property attributes and rdf:nodeID (${S.value}).`);
                        if (m.hadChildren)
                            throw this.newParseError(`Found both rdf:resource and rdf:nodeID (${S.value}).`);
                        if (d)
                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID (${S.value})`);
                        this.validateNcname(S.value),
                        m.hadChildren = !0,
                        b = S.value,
                        T = !0;
                        continue;
                    case "bagID":
                        throw this.newParseError("rdf:bagID is not supported.");
                    case "parseType":
                        if (g)
                            throw this.newParseError("rdf:parseType is not allowed when non-rdf:* property attributes are present");
                        if (m.datatype)
                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:datatype (${m.datatype.value})`);
                        if (b)
                            throw this.newParseError(`rdf:parseType is not allowed on property elements with rdf:nodeID or rdf:resource (${b})`);
                        if (S.value === "Resource") {
                            d = !0,
                            m.childrenParseType = u.PROPERTY;
                            const y = this.dataFactory.blankNode();
                            this.emitTriple(m.subject, m.predicate, y, m.reifiedStatementId, m.childrenTripleTerms, m.reifier),
                            m.subject = y,
                            m.predicate = null
                        } else
                            S.value === "Collection" ? (d = !0,
                            m.hadChildren = !0,
                            m.childrenCollectionSubject = m.subject,
                            m.childrenCollectionPredicate = m.predicate,
                            T = !1) : S.value === "Literal" ? (d = !0,
                            m.childrenTagsToString = !0,
                            m.childrenStringTags = []) : S.value === "Triple" && (d = !0,
                            m.childrenTagsToTripleTerms = !0,
                            m.childrenTripleTerms = []);
                        continue;
                    case "ID":
                        this.validateNcname(S.value),
                        m.reifiedStatementId = this.valueToUri("#" + S.value, m),
                        this.claimNodeId(m.reifiedStatementId);
                        continue;
                    case "annotation":
                        m.reifier = this.dataFactory.namedNode(S.value);
                        continue;
                    case "annotationNodeID":
                        m.reifier = this.dataFactory.blankNode(S.value);
                        continue
                    }
                else if (S.uri === tt.XML && S.local === "lang") {
                    m.language = S.value === "" ? null : S.value.toLowerCase();
                    continue
                } else if (S.uri === tt.ITS && S.local === "dir") {
                    this.setDirection(m, S.value);
                    continue
                } else if (S.uri === tt.ITS && S.local === "version")
                    continue;
                if (S.prefix !== "xml" && S.prefix !== "xmlns" && (S.prefix !== "" || S.local !== "xmlns") && S.uri) {
                    if (d || m.datatype)
                        throw this.newParseError(`Found illegal rdf:* properties on property element with attribute: ${S.value}`);
                    m.hadChildren = !0,
                    g = !0,
                    N.push(this.uriToNamedNode(S.uri + S.local)),
                    A.push(this.createLiteral(S.value, m))
                }
            }
            if (b !== null) {
                const R = m.subject;
                m.subject = T ? this.dataFactory.blankNode(b) : this.valueToUri(b, m),
                this.emitTriple(R, m.predicate, m.subject, m.reifiedStatementId, m.childrenTripleTerms, m.reifier);
                for (let S = 0; S < N.length; S++)
                    this.emitTriple(m.subject, N[S], A[S], null, m.childrenTripleTerms, m.reifier);
                m.predicateEmitted = !0
            } else
                T && (m.predicateSubPredicates = N,
                m.predicateSubObjects = A,
                m.predicateEmitted = !1)
        }
        emitTriple(h, m, _, d, g, b) {
            const T = this.dataFactory.quad(h, m, _, this.defaultGraph);
            g ? g.push(T) : this.push(T),
            b && this.push(this.dataFactory.quad(b, this.dataFactory.namedNode(tt.RDF + "reifies"), T)),
            d && (this.push(this.dataFactory.quad(d, this.dataFactory.namedNode(tt.RDF + "type"), this.dataFactory.namedNode(tt.RDF + "Statement"), this.defaultGraph)),
            this.push(this.dataFactory.quad(d, this.dataFactory.namedNode(tt.RDF + "subject"), h, this.defaultGraph)),
            this.push(this.dataFactory.quad(d, this.dataFactory.namedNode(tt.RDF + "predicate"), m, this.defaultGraph)),
            this.push(this.dataFactory.quad(d, this.dataFactory.namedNode(tt.RDF + "object"), _, this.defaultGraph)))
        }
        claimNodeId(h) {
            if (!this.allowDuplicateRdfIds) {
                if (this.nodeIds[h.value])
                    throw this.newParseError(`Found multiple occurrences of rdf:ID='${h.value}'.`);
                this.nodeIds[h.value] = !0
            }
        }
        onText(h) {
            const m = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;
            m && (m.childrenStringTags ? m.childrenStringTags.push(h) : m.predicate && (m.text = h))
        }
        onCloseTag() {
            const h = this.activeTagStack.pop()
              , m = this.activeTagStack.length ? this.activeTagStack[this.activeTagStack.length - 1] : null;
            if (h.childrenStringEmitClosingTag && h.childrenStringTags.push(h.childrenStringEmitClosingTag),
            h.childrenTagsToString && (h.datatype = this.dataFactory.namedNode(tt.RDF + "XMLLiteral"),
            h.text = h.childrenStringTags.join(""),
            h.hadChildren = !1),
            h.childrenTagsToTripleTerms && h.predicate && h.rdfVersion) {
                if (h.childrenTripleTerms.length !== 1)
                    throw this.newParseError(`Expected exactly one triple term in rdf:parseType="Triple" but got ${h.childrenTripleTerms.length}`);
                for (const _ of h.childrenTripleTerms)
                    this.emitTriple(h.subject, h.predicate, _, null, m.childrenTripleTerms, m.reifier);
                h.predicateEmitted = !0
            }
            if (h.childrenCollectionSubject)
                this.emitTriple(h.childrenCollectionSubject, h.childrenCollectionPredicate, this.dataFactory.namedNode(tt.RDF + "nil"), null, h.childrenTripleTerms);
            else if (h.predicate) {
                if (!h.hadChildren && h.childrenParseType !== u.PROPERTY)
                    this.emitTriple(h.subject, h.predicate, this.createLiteral(h.text || "", h), h.reifiedStatementId, h.childrenTripleTerms, h.reifier);
                else if (!h.predicateEmitted) {
                    const _ = this.dataFactory.blankNode();
                    this.emitTriple(h.subject, h.predicate, _, h.reifiedStatementId, h.childrenTripleTerms, h.reifier);
                    for (let d = 0; d < h.predicateSubPredicates.length; d++)
                        this.emitTriple(_, h.predicateSubPredicates[d], h.predicateSubObjects[d], null, h.childrenTripleTerms)
                }
            }
        }
        onDoctype(h) {
            h.replace(/<!ENTITY\s+([^\s]+)\s+["']([^"']+)["']\s*>/g, (m,_,d)=>(this.saxParser.ENTITIES[_] = d,
            ""))
        }
        setDirection(h, m) {
            if (m) {
                if (m !== "ltr" && m !== "rtl")
                    throw this.newParseError(`Base directions must either be 'ltr' or 'rtl', while '${m}' was found.`);
                h.direction = m
            } else
                delete h.direction
        }
        setVersion(h, m) {
            h.rdfVersion = m,
            this.emit("version", m)
        }
    }
    ;
    ii.RdfXmlParser = l,
    l.MIME_TYPE = "application/rdf+xml",
    l.RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    l.XML = "http://www.w3.org/XML/1998/namespace",
    l.ITS = "http://www.w3.org/2005/11/its",
    l.FORBIDDEN_NODE_ELEMENTS = ["RDF", "ID", "about", "bagID", "parseType", "resource", "nodeID", "li", "aboutEach", "aboutEachPrefix"],
    l.FORBIDDEN_PROPERTY_ELEMENTS = ["Description", "RDF", "ID", "about", "bagID", "parseType", "resource", "nodeID", "aboutEach", "aboutEachPrefix"],
    l.NCNAME_MATCHER = /^([A-Za-z\xC0-\xD6\xD8-\xF6\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}_])([A-Za-z\xC0-\xD6\xD8-\xF6\u{F8}-\u{2FF}\u{370}-\u{37D}\u{37F}-\u{1FFF}\u{200C}-\u{200D}\u{2070}-\u{218F}\u{2C00}-\u{2FEF}\u{3001}-\u{D7FF}\u{F900}-\u{FDCF}\u{FDF0}-\u{FFFD}\u{10000}-\u{EFFFF}_\-.0-9#xB7\u{0300}-\u{036F}\u{203F}-\u{2040}])*$/u;
    var u;
    return (function(f) {
        f[f.RESOURCE = 0] = "RESOURCE",
        f[f.PROPERTY = 1] = "PROPERTY"
    }
    )(u || (ii.ParseType = u = {})),
    ii
}
var sd;
function dm() {
    return sd || (sd = 1,
    (function(i) {
        var e = ni && ni.__createBinding || (Object.create ? (function(r, o, a, l) {
            l === void 0 && (l = a);
            var u = Object.getOwnPropertyDescriptor(o, a);
            (!u || ("get"in u ? !o.__esModule : u.writable || u.configurable)) && (u = {
                enumerable: !0,
                get: function() {
                    return o[a]
                }
            }),
            Object.defineProperty(r, l, u)
        }
        ) : (function(r, o, a, l) {
            l === void 0 && (l = a),
            r[l] = o[a]
        }
        ))
          , n = ni && ni.__exportStar || function(r, o) {
            for (var a in r)
                a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && e(o, r, a)
        }
        ;
        Object.defineProperty(i, "__esModule", {
            value: !0
        }),
        n(cm(), i)
    }
    )(ni)),
    ni
}
var hm = dm(), ca = {}, da, od;
function zl() {
    return od || (od = 1,
    da = class Rf {
        constructor(e, n=new Map, r=0) {
            this.prefix = e,
            this._existing = n,
            this.counter = r
        }
        clone() {
            const {prefix: e, _existing: n, counter: r} = this;
            return new Rf(e,new Map(n),r)
        }
        getId(e) {
            const n = e && this._existing.get(e);
            if (n)
                return n;
            const r = this.prefix + this.counter;
            return this.counter++,
            e && this._existing.set(e, r),
            r
        }
        hasId(e) {
            return this._existing.has(e)
        }
        getOldIds() {
            return [...this._existing.keys()]
        }
    }
    ),
    da
}
var ha = {}, ad;
function fm() {
    return ad || (ad = 1,
    (function(i, e) {
        if (i.setImmediate)
            return;
        var n = 1, r = {}, o = !1, a = i.document, l;
        function u(R) {
            typeof R != "function" && (R = new Function("" + R));
            for (var S = new Array(arguments.length - 1), y = 0; y < S.length; y++)
                S[y] = arguments[y + 1];
            var x = {
                callback: R,
                args: S
            };
            return r[n] = x,
            l(n),
            n++
        }
        function f(R) {
            delete r[R]
        }
        function h(R) {
            var S = R.callback
              , y = R.args;
            switch (y.length) {
            case 0:
                S();
                break;
            case 1:
                S(y[0]);
                break;
            case 2:
                S(y[0], y[1]);
                break;
            case 3:
                S(y[0], y[1], y[2]);
                break;
            default:
                S.apply(e, y);
                break
            }
        }
        function m(R) {
            if (o)
                setTimeout(m, 0, R);
            else {
                var S = r[R];
                if (S) {
                    o = !0;
                    try {
                        h(S)
                    } finally {
                        f(R),
                        o = !1
                    }
                }
            }
        }
        function _() {
            l = function(R) {
                process.nextTick(function() {
                    m(R)
                })
            }
        }
        function d() {
            if (i.postMessage && !i.importScripts) {
                var R = !0
                  , S = i.onmessage;
                return i.onmessage = function() {
                    R = !1
                }
                ,
                i.postMessage("", "*"),
                i.onmessage = S,
                R
            }
        }
        function g() {
            var R = "setImmediate$" + Math.random() + "$"
              , S = function(y) {
                y.source === i && typeof y.data == "string" && y.data.indexOf(R) === 0 && m(+y.data.slice(R.length))
            };
            i.addEventListener ? i.addEventListener("message", S, !1) : i.attachEvent("onmessage", S),
            l = function(y) {
                i.postMessage(R + y, "*")
            }
        }
        function b() {
            var R = new MessageChannel;
            R.port1.onmessage = function(S) {
                var y = S.data;
                m(y)
            }
            ,
            l = function(S) {
                R.port2.postMessage(S)
            }
        }
        function T() {
            var R = a.documentElement;
            l = function(S) {
                var y = a.createElement("script");
                y.onreadystatechange = function() {
                    m(S),
                    y.onreadystatechange = null,
                    R.removeChild(y),
                    y = null
                }
                ,
                R.appendChild(y)
            }
        }
        function N() {
            l = function(R) {
                setTimeout(m, 0, R)
            }
        }
        var A = Object.getPrototypeOf && Object.getPrototypeOf(i);
        A = A && A.setTimeout ? A : i,
        {}.toString.call(i.process) === "[object process]" ? _() : d() ? g() : i.MessageChannel ? b() : a && "onreadystatechange"in a.createElement("script") ? T() : N(),
        A.setImmediate = u,
        A.clearImmediate = f
    }
    )(typeof self > "u" ? typeof Fi > "u" ? ha : Fi : self)),
    ha
}
var fa, ld;
function Xs() {
    if (ld)
        return fa;
    ld = 1,
    fm();
    const i = self.crypto || self.msCrypto;
    return fa = class {
        constructor(n) {
            if (!(i && i.subtle))
                throw new Error("crypto.subtle not found.");
            if (n === "sha256")
                this.algorithm = {
                    name: "SHA-256"
                };
            else if (n === "sha1")
                this.algorithm = {
                    name: "SHA-1"
                };
            else
                throw new Error(`Unsupported algorithm "${n}".`);
            this._content = ""
        }
        update(n) {
            this._content += n
        }
        async digest() {
            const n = new TextEncoder().encode(this._content)
              , r = new Uint8Array(await i.subtle.digest(this.algorithm, n));
            let o = "";
            for (let a = 0; a < r.length; ++a)
                o += r[a].toString(16).padStart(2, "0");
            return o
        }
    }
    ,
    fa
}
var pa, ud;
function Cf() {
    return ud || (ud = 1,
    pa = class {
        constructor(e) {
            this.current = e.sort(),
            this.done = !1,
            this.dir = new Map;
            for (let n = 0; n < e.length; ++n)
                this.dir.set(e[n], !0)
        }
        hasNext() {
            return !this.done
        }
        next() {
            const {current: e, dir: n} = this
              , r = e.slice();
            let o = null
              , a = 0;
            const l = e.length;
            for (let u = 0; u < l; ++u) {
                const f = e[u]
                  , h = n.get(f);
                (o === null || f > o) && (h && u > 0 && f > e[u - 1] || !h && u < l - 1 && f > e[u + 1]) && (o = f,
                a = u)
            }
            if (o === null)
                this.done = !0;
            else {
                const u = n.get(o) ? a - 1 : a + 1;
                e[a] = e[u],
                e[u] = o;
                for (const f of e)
                    f > o && n.set(f, !n.get(f))
            }
            return r
        }
    }
    ),
    pa
}
var ga, cd;
function Ul() {
    if (cd)
        return ga;
    cd = 1;
    const e = "http://www.w3.org/1999/02/22-rdf-syntax-ns#" + "langString"
      , n = "http://www.w3.org/2001/XMLSchema#string"
      , r = "NamedNode"
      , o = "BlankNode"
      , a = "Literal"
      , l = "DefaultGraph"
      , u = {};
    (()=>{
        const g = "(?:<([^:]+:[^>]*)>)"
          , T = "A-Za-z-----------" + "_"
          , N = T + "0-9---"
          , R = "(_:(?:[" + T + "0-9])(?:(?:[" + N + ".])*(?:[" + N + "]))?)"
          , S = '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"'
          , y = "(?:\\^\\^" + g + ")"
          , M = "(?:" + S + "(?:" + y + "|" + "(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))" + ")?)"
          , U = "[ \\t]+"
          , O = "[ \\t]*"
          , Q = "(?:" + g + "|" + R + ")" + U
          , D = g + U
          , $ = "(?:" + g + "|" + R + "|" + M + ")" + O
          , X = "(?:\\.|(?:(?:" + g + "|" + R + ")" + O + "\\.))";
        u.eoln = /(?:\r\n)|(?:\n)|(?:\r)/g,
        u.empty = new RegExp("^" + O + "$"),
        u.quad = new RegExp("^" + O + Q + D + $ + X + O + "$")
    }
    )(),
    ga = class Ts {
        static parse(b) {
            const T = []
              , N = {}
              , A = b.split(u.eoln);
            let R = 0;
            for (const S of A) {
                if (R++,
                u.empty.test(S))
                    continue;
                const y = S.match(u.quad);
                if (y === null)
                    throw new Error("N-Quads parse error on line " + R + ".");
                const x = {
                    subject: null,
                    predicate: null,
                    object: null,
                    graph: null
                };
                if (y[1] !== void 0 ? x.subject = {
                    termType: r,
                    value: y[1]
                } : x.subject = {
                    termType: o,
                    value: y[2]
                },
                x.predicate = {
                    termType: r,
                    value: y[3]
                },
                y[4] !== void 0 ? x.object = {
                    termType: r,
                    value: y[4]
                } : y[5] !== void 0 ? x.object = {
                    termType: o,
                    value: y[5]
                } : (x.object = {
                    termType: a,
                    value: void 0,
                    datatype: {
                        termType: r
                    }
                },
                y[7] !== void 0 ? x.object.datatype.value = y[7] : y[8] !== void 0 ? (x.object.datatype.value = e,
                x.object.language = y[8]) : x.object.datatype.value = n,
                x.object.value = d(y[6])),
                y[9] !== void 0 ? x.graph = {
                    termType: r,
                    value: y[9]
                } : y[10] !== void 0 ? x.graph = {
                    termType: o,
                    value: y[10]
                } : x.graph = {
                    termType: l,
                    value: ""
                },
                !(x.graph.value in N))
                    N[x.graph.value] = [x],
                    T.push(x);
                else {
                    let M = !0;
                    const U = N[x.graph.value];
                    for (const O of U)
                        if (f(O, x)) {
                            M = !1;
                            break
                        }
                    M && (U.push(x),
                    T.push(x))
                }
            }
            return T
        }
        static serialize(b) {
            Array.isArray(b) || (b = Ts.legacyDatasetToQuads(b));
            const T = [];
            for (const N of b)
                T.push(Ts.serializeQuad(N));
            return T.sort().join("")
        }
        static serializeQuadComponents(b, T, N, A) {
            let R = "";
            return b.termType === r ? R += `<${b.value}>` : R += `${b.value}`,
            R += ` <${T.value}> `,
            N.termType === r ? R += `<${N.value}>` : N.termType === o ? R += N.value : (R += `"${m(N.value)}"`,
            N.datatype.value === e ? N.language && (R += `@${N.language}`) : N.datatype.value !== n && (R += `^^<${N.datatype.value}>`)),
            A.termType === r ? R += ` <${A.value}>` : A.termType === o && (R += ` ${A.value}`),
            R += ` .
`,
            R
        }
        static serializeQuad(b) {
            return Ts.serializeQuadComponents(b.subject, b.predicate, b.object, b.graph)
        }
        static legacyDatasetToQuads(b) {
            const T = []
              , N = {
                "blank node": o,
                IRI: r,
                literal: a
            };
            for (const A in b)
                b[A].forEach(S=>{
                    const y = {};
                    for (const x in S) {
                        const M = S[x]
                          , U = {
                            termType: N[M.type],
                            value: M.value
                        };
                        U.termType === a && (U.datatype = {
                            termType: r
                        },
                        "datatype"in M && (U.datatype.value = M.datatype),
                        "language"in M ? ("datatype"in M || (U.datatype.value = e),
                        U.language = M.language) : "datatype"in M || (U.datatype.value = n)),
                        y[x] = U
                    }
                    A === "@default" ? y.graph = {
                        termType: l,
                        value: ""
                    } : y.graph = {
                        termType: A.startsWith("_:") ? o : r,
                        value: A
                    },
                    T.push(y)
                }
                );
            return T
        }
    }
    ;
    function f(g, b) {
        return !(g.subject.termType === b.subject.termType && g.object.termType === b.object.termType) || !(g.subject.value === b.subject.value && g.predicate.value === b.predicate.value && g.object.value === b.object.value) ? !1 : g.object.termType !== a ? !0 : g.object.datatype.termType === b.object.datatype.termType && g.object.language === b.object.language && g.object.datatype.value === b.object.datatype.value
    }
    const h = /["\\\n\r]/g;
    function m(g) {
        return g.replace(h, function(b) {
            switch (b) {
            case '"':
                return '\\"';
            case "\\":
                return "\\\\";
            case `
`:
                return "\\n";
            case "\r":
                return "\\r"
            }
        })
    }
    const _ = /(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;
    function d(g) {
        return g.replace(_, function(b, T, N, A) {
            if (T)
                switch (T) {
                case "t":
                    return "	";
                case "b":
                    return "\b";
                case "n":
                    return `
`;
                case "r":
                    return "\r";
                case "f":
                    return "\f";
                case '"':
                    return '"';
                case "'":
                    return "'";
                case "\\":
                    return "\\"
                }
            if (N)
                return String.fromCharCode(parseInt(N, 16));
            if (A)
                throw new Error("Unsupported U escape")
        })
    }
    return ga
}
var ma, dd;
function kf() {
    if (dd)
        return ma;
    dd = 1;
    const i = zl()
      , e = Xs()
      , n = Cf()
      , r = Ul();
    ma = class {
        constructor({createMessageDigest: l=()=>new e("sha256"), canonicalIdMap: u=new Map, maxDeepIterations: f=1 / 0}={}) {
            this.name = "URDNA2015",
            this.blankNodeInfo = new Map,
            this.canonicalIssuer = new i("_:c14n",u),
            this.createMessageDigest = l,
            this.maxDeepIterations = f,
            this.quads = null,
            this.deepIterations = null
        }
        async main(l) {
            this.deepIterations = new Map,
            this.quads = l;
            for (const g of l)
                this._addBlankNodeQuadInfo({
                    quad: g,
                    component: g.subject
                }),
                this._addBlankNodeQuadInfo({
                    quad: g,
                    component: g.object
                }),
                this._addBlankNodeQuadInfo({
                    quad: g,
                    component: g.graph
                });
            const u = new Map
              , f = [...this.blankNodeInfo.keys()];
            let h = 0;
            for (const g of f)
                ++h % 100 === 0 && await this._yield(),
                await this._hashAndTrackBlankNode({
                    id: g,
                    hashToBlankNodes: u
                });
            const m = [...u.keys()].sort()
              , _ = [];
            for (const g of m) {
                const b = u.get(g);
                if (b.length > 1) {
                    _.push(b);
                    continue
                }
                const T = b[0];
                this.canonicalIssuer.getId(T)
            }
            for (const g of _) {
                const b = [];
                for (const T of g) {
                    if (this.canonicalIssuer.hasId(T))
                        continue;
                    const N = new i("_:b");
                    N.getId(T);
                    const A = await this.hashNDegreeQuads(T, N);
                    b.push(A)
                }
                b.sort(o);
                for (const T of b) {
                    const N = T.issuer.getOldIds();
                    for (const A of N)
                        this.canonicalIssuer.getId(A)
                }
            }
            const d = [];
            for (const g of this.quads) {
                const b = r.serializeQuadComponents(this._componentWithCanonicalId(g.subject), g.predicate, this._componentWithCanonicalId(g.object), this._componentWithCanonicalId(g.graph));
                d.push(b)
            }
            return d.sort(),
            d.join("")
        }
        async hashFirstDegreeQuads(l) {
            const u = []
              , f = this.blankNodeInfo.get(l)
              , h = f.quads;
            for (const _ of h) {
                const d = {
                    subject: null,
                    predicate: _.predicate,
                    object: null,
                    graph: null
                };
                d.subject = this.modifyFirstDegreeComponent(l, _.subject, "subject"),
                d.object = this.modifyFirstDegreeComponent(l, _.object, "object"),
                d.graph = this.modifyFirstDegreeComponent(l, _.graph, "graph"),
                u.push(r.serializeQuad(d))
            }
            u.sort();
            const m = this.createMessageDigest();
            for (const _ of u)
                m.update(_);
            return f.hash = await m.digest(),
            f.hash
        }
        async hashRelatedBlankNode(l, u, f, h) {
            let m;
            this.canonicalIssuer.hasId(l) ? m = this.canonicalIssuer.getId(l) : f.hasId(l) ? m = f.getId(l) : m = this.blankNodeInfo.get(l).hash;
            const _ = this.createMessageDigest();
            return _.update(h),
            h !== "g" && _.update(this.getRelatedPredicate(u)),
            _.update(m),
            _.digest()
        }
        async hashNDegreeQuads(l, u) {
            const f = this.deepIterations.get(l) || 0;
            if (f > this.maxDeepIterations)
                throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);
            this.deepIterations.set(l, f + 1);
            const h = this.createMessageDigest()
              , m = await this.createHashToRelated(l, u)
              , _ = [...m.keys()].sort();
            for (const d of _) {
                h.update(d);
                let g = "", b;
                const T = new n(m.get(d));
                let N = 0;
                for (; T.hasNext(); ) {
                    const A = T.next();
                    ++N % 3 === 0 && await this._yield();
                    let R = u.clone()
                      , S = "";
                    const y = [];
                    let x = !1;
                    for (const M of A)
                        if (this.canonicalIssuer.hasId(M) ? S += this.canonicalIssuer.getId(M) : (R.hasId(M) || y.push(M),
                        S += R.getId(M)),
                        g.length !== 0 && S > g) {
                            x = !0;
                            break
                        }
                    if (!x) {
                        for (const M of y) {
                            const U = await this.hashNDegreeQuads(M, R);
                            if (S += R.getId(M),
                            S += `<${U.hash}>`,
                            R = U.issuer,
                            g.length !== 0 && S > g) {
                                x = !0;
                                break
                            }
                        }
                        x || (g.length === 0 || S < g) && (g = S,
                        b = R)
                    }
                }
                h.update(g),
                u = b
            }
            return {
                hash: await h.digest(),
                issuer: u
            }
        }
        modifyFirstDegreeComponent(l, u) {
            return u.termType !== "BlankNode" ? u : {
                termType: "BlankNode",
                value: u.value === l ? "_:a" : "_:z"
            }
        }
        getRelatedPredicate(l) {
            return `<${l.predicate.value}>`
        }
        async createHashToRelated(l, u) {
            const f = new Map
              , h = this.blankNodeInfo.get(l).quads;
            let m = 0;
            for (const _ of h)
                ++m % 100 === 0 && await this._yield(),
                await Promise.all([this._addRelatedBlankNodeHash({
                    quad: _,
                    component: _.subject,
                    position: "s",
                    id: l,
                    issuer: u,
                    hashToRelated: f
                }), this._addRelatedBlankNodeHash({
                    quad: _,
                    component: _.object,
                    position: "o",
                    id: l,
                    issuer: u,
                    hashToRelated: f
                }), this._addRelatedBlankNodeHash({
                    quad: _,
                    component: _.graph,
                    position: "g",
                    id: l,
                    issuer: u,
                    hashToRelated: f
                })]);
            return f
        }
        async _hashAndTrackBlankNode({id: l, hashToBlankNodes: u}) {
            const f = await this.hashFirstDegreeQuads(l)
              , h = u.get(f);
            h ? h.push(l) : u.set(f, [l])
        }
        _addBlankNodeQuadInfo({quad: l, component: u}) {
            if (u.termType !== "BlankNode")
                return;
            const f = u.value
              , h = this.blankNodeInfo.get(f);
            h ? h.quads.add(l) : this.blankNodeInfo.set(f, {
                quads: new Set([l]),
                hash: null
            })
        }
        async _addRelatedBlankNodeHash({quad: l, component: u, position: f, id: h, issuer: m, hashToRelated: _}) {
            if (!(u.termType === "BlankNode" && u.value !== h))
                return;
            const d = u.value
              , g = await this.hashRelatedBlankNode(d, l, m, f)
              , b = _.get(g);
            b ? b.push(d) : _.set(g, [d])
        }
        _componentWithCanonicalId(l) {
            return l.termType === "BlankNode" && !l.value.startsWith(this.canonicalIssuer.prefix) ? {
                termType: "BlankNode",
                value: this.canonicalIssuer.getId(l.value)
            } : l
        }
        async _yield() {
            return new Promise(l=>setImmediate(l))
        }
    }
    ;
    function o(a, l) {
        return a.hash < l.hash ? -1 : a.hash > l.hash ? 1 : 0
    }
    return ma
}
var _a, hd;
function pm() {
    if (hd)
        return _a;
    hd = 1;
    const i = Xs()
      , e = kf();
    return _a = class extends e {
        constructor() {
            super(),
            this.name = "URGNA2012",
            this.createMessageDigest = ()=>new i("sha1")
        }
        modifyFirstDegreeComponent(r, o, a) {
            return o.termType !== "BlankNode" ? o : a === "graph" ? {
                termType: "BlankNode",
                value: "_:g"
            } : {
                termType: "BlankNode",
                value: o.value === r ? "_:a" : "_:z"
            }
        }
        getRelatedPredicate(r) {
            return r.predicate.value
        }
        async createHashToRelated(r, o) {
            const a = new Map
              , l = this.blankNodeInfo.get(r).quads;
            let u = 0;
            for (const f of l) {
                let h, m;
                if (f.subject.termType === "BlankNode" && f.subject.value !== r)
                    m = f.subject.value,
                    h = "p";
                else if (f.object.termType === "BlankNode" && f.object.value !== r)
                    m = f.object.value,
                    h = "r";
                else
                    continue;
                ++u % 100 === 0 && await this._yield();
                const _ = await this.hashRelatedBlankNode(m, f, o, h)
                  , d = a.get(_);
                d ? d.push(m) : a.set(_, [m])
            }
            return a
        }
    }
    ,
    _a
}
var ya, fd;
function Pf() {
    if (fd)
        return ya;
    fd = 1;
    const i = zl()
      , e = Xs()
      , n = Cf()
      , r = Ul();
    ya = class {
        constructor({createMessageDigest: l=()=>new e("sha256"), canonicalIdMap: u=new Map, maxDeepIterations: f=1 / 0}={}) {
            this.name = "URDNA2015",
            this.blankNodeInfo = new Map,
            this.canonicalIssuer = new i("_:c14n",u),
            this.createMessageDigest = l,
            this.maxDeepIterations = f,
            this.quads = null,
            this.deepIterations = null
        }
        main(l) {
            this.deepIterations = new Map,
            this.quads = l;
            for (const d of l)
                this._addBlankNodeQuadInfo({
                    quad: d,
                    component: d.subject
                }),
                this._addBlankNodeQuadInfo({
                    quad: d,
                    component: d.object
                }),
                this._addBlankNodeQuadInfo({
                    quad: d,
                    component: d.graph
                });
            const u = new Map
              , f = [...this.blankNodeInfo.keys()];
            for (const d of f)
                this._hashAndTrackBlankNode({
                    id: d,
                    hashToBlankNodes: u
                });
            const h = [...u.keys()].sort()
              , m = [];
            for (const d of h) {
                const g = u.get(d);
                if (g.length > 1) {
                    m.push(g);
                    continue
                }
                const b = g[0];
                this.canonicalIssuer.getId(b)
            }
            for (const d of m) {
                const g = [];
                for (const b of d) {
                    if (this.canonicalIssuer.hasId(b))
                        continue;
                    const T = new i("_:b");
                    T.getId(b);
                    const N = this.hashNDegreeQuads(b, T);
                    g.push(N)
                }
                g.sort(o);
                for (const b of g) {
                    const T = b.issuer.getOldIds();
                    for (const N of T)
                        this.canonicalIssuer.getId(N)
                }
            }
            const _ = [];
            for (const d of this.quads) {
                const g = r.serializeQuadComponents(this._componentWithCanonicalId({
                    component: d.subject
                }), d.predicate, this._componentWithCanonicalId({
                    component: d.object
                }), this._componentWithCanonicalId({
                    component: d.graph
                }));
                _.push(g)
            }
            return _.sort(),
            _.join("")
        }
        hashFirstDegreeQuads(l) {
            const u = []
              , f = this.blankNodeInfo.get(l)
              , h = f.quads;
            for (const _ of h) {
                const d = {
                    subject: null,
                    predicate: _.predicate,
                    object: null,
                    graph: null
                };
                d.subject = this.modifyFirstDegreeComponent(l, _.subject, "subject"),
                d.object = this.modifyFirstDegreeComponent(l, _.object, "object"),
                d.graph = this.modifyFirstDegreeComponent(l, _.graph, "graph"),
                u.push(r.serializeQuad(d))
            }
            u.sort();
            const m = this.createMessageDigest();
            for (const _ of u)
                m.update(_);
            return f.hash = m.digest(),
            f.hash
        }
        hashRelatedBlankNode(l, u, f, h) {
            let m;
            this.canonicalIssuer.hasId(l) ? m = this.canonicalIssuer.getId(l) : f.hasId(l) ? m = f.getId(l) : m = this.blankNodeInfo.get(l).hash;
            const _ = this.createMessageDigest();
            return _.update(h),
            h !== "g" && _.update(this.getRelatedPredicate(u)),
            _.update(m),
            _.digest()
        }
        hashNDegreeQuads(l, u) {
            const f = this.deepIterations.get(l) || 0;
            if (f > this.maxDeepIterations)
                throw new Error(`Maximum deep iterations (${this.maxDeepIterations}) exceeded.`);
            this.deepIterations.set(l, f + 1);
            const h = this.createMessageDigest()
              , m = this.createHashToRelated(l, u)
              , _ = [...m.keys()].sort();
            for (const d of _) {
                h.update(d);
                let g = "", b;
                const T = new n(m.get(d));
                for (; T.hasNext(); ) {
                    const N = T.next();
                    let A = u.clone()
                      , R = "";
                    const S = [];
                    let y = !1;
                    for (const x of N)
                        if (this.canonicalIssuer.hasId(x) ? R += this.canonicalIssuer.getId(x) : (A.hasId(x) || S.push(x),
                        R += A.getId(x)),
                        g.length !== 0 && R > g) {
                            y = !0;
                            break
                        }
                    if (!y) {
                        for (const x of S) {
                            const M = this.hashNDegreeQuads(x, A);
                            if (R += A.getId(x),
                            R += `<${M.hash}>`,
                            A = M.issuer,
                            g.length !== 0 && R > g) {
                                y = !0;
                                break
                            }
                        }
                        y || (g.length === 0 || R < g) && (g = R,
                        b = A)
                    }
                }
                h.update(g),
                u = b
            }
            return {
                hash: h.digest(),
                issuer: u
            }
        }
        modifyFirstDegreeComponent(l, u) {
            return u.termType !== "BlankNode" ? u : {
                termType: "BlankNode",
                value: u.value === l ? "_:a" : "_:z"
            }
        }
        getRelatedPredicate(l) {
            return `<${l.predicate.value}>`
        }
        createHashToRelated(l, u) {
            const f = new Map
              , h = this.blankNodeInfo.get(l).quads;
            for (const m of h)
                this._addRelatedBlankNodeHash({
                    quad: m,
                    component: m.subject,
                    position: "s",
                    id: l,
                    issuer: u,
                    hashToRelated: f
                }),
                this._addRelatedBlankNodeHash({
                    quad: m,
                    component: m.object,
                    position: "o",
                    id: l,
                    issuer: u,
                    hashToRelated: f
                }),
                this._addRelatedBlankNodeHash({
                    quad: m,
                    component: m.graph,
                    position: "g",
                    id: l,
                    issuer: u,
                    hashToRelated: f
                });
            return f
        }
        _hashAndTrackBlankNode({id: l, hashToBlankNodes: u}) {
            const f = this.hashFirstDegreeQuads(l)
              , h = u.get(f);
            h ? h.push(l) : u.set(f, [l])
        }
        _addBlankNodeQuadInfo({quad: l, component: u}) {
            if (u.termType !== "BlankNode")
                return;
            const f = u.value
              , h = this.blankNodeInfo.get(f);
            h ? h.quads.add(l) : this.blankNodeInfo.set(f, {
                quads: new Set([l]),
                hash: null
            })
        }
        _addRelatedBlankNodeHash({quad: l, component: u, position: f, id: h, issuer: m, hashToRelated: _}) {
            if (!(u.termType === "BlankNode" && u.value !== h))
                return;
            const d = u.value
              , g = this.hashRelatedBlankNode(d, l, m, f)
              , b = _.get(g);
            b ? b.push(d) : _.set(g, [d])
        }
        _componentWithCanonicalId({component: l}) {
            return l.termType === "BlankNode" && !l.value.startsWith(this.canonicalIssuer.prefix) ? {
                termType: "BlankNode",
                value: this.canonicalIssuer.getId(l.value)
            } : l
        }
    }
    ;
    function o(a, l) {
        return a.hash < l.hash ? -1 : a.hash > l.hash ? 1 : 0
    }
    return ya
}
var va, pd;
function gm() {
    if (pd)
        return va;
    pd = 1;
    const i = Xs()
      , e = Pf();
    return va = class extends e {
        constructor() {
            super(),
            this.name = "URGNA2012",
            this.createMessageDigest = ()=>new i("sha1")
        }
        modifyFirstDegreeComponent(r, o, a) {
            return o.termType !== "BlankNode" ? o : a === "graph" ? {
                termType: "BlankNode",
                value: "_:g"
            } : {
                termType: "BlankNode",
                value: o.value === r ? "_:a" : "_:z"
            }
        }
        getRelatedPredicate(r) {
            return r.predicate.value
        }
        createHashToRelated(r, o) {
            const a = new Map
              , l = this.blankNodeInfo.get(r).quads;
            for (const u of l) {
                let f, h;
                if (u.subject.termType === "BlankNode" && u.subject.value !== r)
                    h = u.subject.value,
                    f = "p";
                else if (u.object.termType === "BlankNode" && u.object.value !== r)
                    h = u.object.value,
                    f = "r";
                else
                    continue;
                const m = this.hashRelatedBlankNode(h, u, o, f)
                  , _ = a.get(m);
                _ ? _.push(h) : a.set(m, [h])
            }
            return a
        }
    }
    ,
    va
}
const mm = {}
  , _m = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: mm
}, Symbol.toStringTag, {
    value: "Module"
}))
  , ym = mg(_m);
var gd;
function vm() {
    return gd || (gd = 1,
    (function(i) {
        const e = kf()
          , n = pm()
          , r = Pf()
          , o = gm();
        let a;
        try {
            a = ym
        } catch {}
        function l(u) {
            return Array.isArray(u) ? u : i.NQuads.legacyDatasetToQuads(u)
        }
        i.NQuads = Ul(),
        i.IdentifierIssuer = zl(),
        i._rdfCanonizeNative = function(u) {
            return u && (a = u),
            a
        }
        ,
        i.canonize = async function(u, f) {
            const h = l(u);
            if (f.useNative) {
                if (!a)
                    throw new Error("rdf-canonize-native not available");
                if (f.createMessageDigest)
                    throw new Error('"createMessageDigest" cannot be used with "useNative".');
                return new Promise((m,_)=>a.canonize(h, f, (d,g)=>d ? _(d) : m(g)))
            }
            if (f.algorithm === "URDNA2015")
                return new e(f).main(h);
            if (f.algorithm === "URGNA2012") {
                if (f.createMessageDigest)
                    throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');
                return new n(f).main(h)
            }
            throw "algorithm"in f ? new Error("Invalid RDF Dataset Canonicalization algorithm: " + f.algorithm) : new Error("No RDF Dataset Canonicalization algorithm specified.")
        }
        ,
        i._canonizeSync = function(u, f) {
            const h = l(u);
            if (f.useNative) {
                if (!a)
                    throw new Error("rdf-canonize-native not available");
                if (f.createMessageDigest)
                    throw new Error('"createMessageDigest" cannot be used with "useNative".');
                return a.canonizeSync(h, f)
            }
            if (f.algorithm === "URDNA2015")
                return new r(f).main(h);
            if (f.algorithm === "URGNA2012") {
                if (f.createMessageDigest)
                    throw new Error('"createMessageDigest" cannot be used with "URGNA2012".');
                return new o(f).main(h)
            }
            throw "algorithm"in f ? new Error("Invalid RDF Dataset Canonicalization algorithm: " + f.algorithm) : new Error("No RDF Dataset Canonicalization algorithm specified.")
        }
    }
    )(ca)),
    ca
}
var ba, md;
function Hl() {
    return md || (md = 1,
    ba = vm()),
    ba
}
var wa, _d;
function qt() {
    if (_d)
        return wa;
    _d = 1;
    const i = {};
    return wa = i,
    i.isArray = Array.isArray,
    i.isBoolean = e=>typeof e == "boolean" || Object.prototype.toString.call(e) === "[object Boolean]",
    i.isDouble = e=>i.isNumber(e) && (String(e).indexOf(".") !== -1 || Math.abs(e) >= 1e21),
    i.isEmptyObject = e=>i.isObject(e) && Object.keys(e).length === 0,
    i.isNumber = e=>typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]",
    i.isNumeric = e=>!isNaN(parseFloat(e)) && isFinite(e),
    i.isObject = e=>Object.prototype.toString.call(e) === "[object Object]",
    i.isString = e=>typeof e == "string" || Object.prototype.toString.call(e) === "[object String]",
    i.isUndefined = e=>typeof e > "u",
    wa
}
var xa, yd;
function kn() {
    if (yd)
        return xa;
    yd = 1;
    const i = qt()
      , e = {};
    return xa = e,
    e.isSubject = n=>i.isObject(n) && !("@value"in n || "@set"in n || "@list"in n) ? Object.keys(n).length > 1 || !("@id"in n) : !1,
    e.isSubjectReference = n=>i.isObject(n) && Object.keys(n).length === 1 && "@id"in n,
    e.isValue = n=>i.isObject(n) && "@value"in n,
    e.isList = n=>i.isObject(n) && "@list"in n,
    e.isGraph = n=>i.isObject(n) && "@graph"in n && Object.keys(n).filter(r=>r !== "@id" && r !== "@index").length === 1,
    e.isSimpleGraph = n=>e.isGraph(n) && !("@id"in n),
    e.isBlankNode = n=>{
        if (i.isObject(n)) {
            if ("@id"in n) {
                const r = n["@id"];
                return !i.isString(r) || r.indexOf("_:") === 0
            }
            return Object.keys(n).length === 0 || !("@value"in n || "@set"in n || "@list"in n)
        }
        return !1
    }
    ,
    xa
}
var Ea, vd;
function Qt() {
    return vd || (vd = 1,
    Ea = class extends Error {
        constructor(e="An unspecified JSON-LD error occurred.", n="jsonld.Error", r={}) {
            super(e),
            this.name = n,
            this.message = e,
            this.details = r
        }
    }
    ),
    Ea
}
var Sa, bd;
function Zt() {
    if (bd)
        return Sa;
    bd = 1;
    const i = kn()
      , e = qt()
      , n = Hl().IdentifierIssuer
      , r = Qt()
      , o = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/
      , a = /(?:<[^>]*?>|"[^"]*?"|[^,])+/g
      , l = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/
      , u = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g
      , f = /^@[a-zA-Z]+$/
      , h = {
        headers: {
            accept: "application/ld+json, application/json"
        }
    }
      , m = {};
    Sa = m,
    m.IdentifierIssuer = n,
    m.REGEX_BCP47 = o,
    m.REGEX_KEYWORD = f,
    m.clone = function(d) {
        if (d && typeof d == "object") {
            let g;
            if (e.isArray(d)) {
                g = [];
                for (let b = 0; b < d.length; ++b)
                    g[b] = m.clone(d[b])
            } else if (d instanceof Map) {
                g = new Map;
                for (const [b,T] of d)
                    g.set(b, m.clone(T))
            } else if (d instanceof Set) {
                g = new Set;
                for (const b of d)
                    g.add(m.clone(b))
            } else if (e.isObject(d)) {
                g = {};
                for (const b in d)
                    g[b] = m.clone(d[b])
            } else
                g = d.toString();
            return g
        }
        return d
    }
    ,
    m.asArray = function(d) {
        return Array.isArray(d) ? d : [d]
    }
    ,
    m.buildHeaders = (d={})=>{
        if (Object.keys(d).some(b=>b.toLowerCase() === "accept"))
            throw new RangeError('Accept header may not be specified; only "' + h.headers.accept + '" is supported.');
        return Object.assign({
            Accept: h.headers.accept
        }, d)
    }
    ,
    m.parseLinkHeader = d=>{
        const g = {}
          , b = d.match(a);
        for (let T = 0; T < b.length; ++T) {
            let N = b[T].match(l);
            if (!N)
                continue;
            const A = {
                target: N[1]
            }
              , R = N[2];
            for (; N = u.exec(R); )
                A[N[1]] = N[2] === void 0 ? N[3] : N[2];
            const S = A.rel || "";
            Array.isArray(g[S]) ? g[S].push(A) : g.hasOwnProperty(S) ? g[S] = [g[S], A] : g[S] = A
        }
        return g
    }
    ,
    m.validateTypeValue = (d,g)=>{
        if (!e.isString(d) && !(e.isArray(d) && d.every(b=>e.isString(b)))) {
            if (g && e.isObject(d))
                switch (Object.keys(d).length) {
                case 0:
                    return;
                case 1:
                    if ("@default"in d && m.asArray(d["@default"]).every(b=>e.isString(b)))
                        return
                }
            throw new r('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.',"jsonld.SyntaxError",{
                code: "invalid type value",
                value: d
            })
        }
    }
    ,
    m.hasProperty = (d,g)=>{
        if (d.hasOwnProperty(g)) {
            const b = d[g];
            return !e.isArray(b) || b.length > 0
        }
        return !1
    }
    ,
    m.hasValue = (d,g,b)=>{
        if (m.hasProperty(d, g)) {
            let T = d[g];
            const N = i.isList(T);
            if (e.isArray(T) || N) {
                N && (T = T["@list"]);
                for (let A = 0; A < T.length; ++A)
                    if (m.compareValues(b, T[A]))
                        return !0
            } else if (!e.isArray(b))
                return m.compareValues(b, T)
        }
        return !1
    }
    ,
    m.addValue = (d,g,b,T)=>{
        if (T = T || {},
        "propertyIsArray"in T || (T.propertyIsArray = !1),
        "valueIsArray"in T || (T.valueIsArray = !1),
        "allowDuplicate"in T || (T.allowDuplicate = !0),
        "prependValue"in T || (T.prependValue = !1),
        T.valueIsArray)
            d[g] = b;
        else if (e.isArray(b)) {
            b.length === 0 && T.propertyIsArray && !d.hasOwnProperty(g) && (d[g] = []),
            T.prependValue && (b = b.concat(d[g]),
            d[g] = []);
            for (let N = 0; N < b.length; ++N)
                m.addValue(d, g, b[N], T)
        } else if (d.hasOwnProperty(g)) {
            const N = !T.allowDuplicate && m.hasValue(d, g, b);
            !e.isArray(d[g]) && (!N || T.propertyIsArray) && (d[g] = [d[g]]),
            N || (T.prependValue ? d[g].unshift(b) : d[g].push(b))
        } else
            d[g] = T.propertyIsArray ? [b] : b
    }
    ,
    m.getValues = (d,g)=>[].concat(d[g] || []),
    m.removeProperty = (d,g)=>{
        delete d[g]
    }
    ,
    m.removeValue = (d,g,b,T)=>{
        T = T || {},
        "propertyIsArray"in T || (T.propertyIsArray = !1);
        const N = m.getValues(d, g).filter(A=>!m.compareValues(A, b));
        N.length === 0 ? m.removeProperty(d, g) : N.length === 1 && !T.propertyIsArray ? d[g] = N[0] : d[g] = N
    }
    ,
    m.relabelBlankNodes = (d,g)=>{
        g = g || {};
        const b = g.issuer || new n("_:b");
        return _(b, d)
    }
    ,
    m.compareValues = (d,g)=>d === g || i.isValue(d) && i.isValue(g) && d["@value"] === g["@value"] && d["@type"] === g["@type"] && d["@language"] === g["@language"] && d["@index"] === g["@index"] ? !0 : e.isObject(d) && "@id"in d && e.isObject(g) && "@id"in g ? d["@id"] === g["@id"] : !1,
    m.compareShortestLeast = (d,g)=>d.length < g.length ? -1 : g.length < d.length ? 1 : d === g ? 0 : d < g ? -1 : 1;
    function _(d, g) {
        if (e.isArray(g))
            for (let b = 0; b < g.length; ++b)
                g[b] = _(d, g[b]);
        else if (i.isList(g))
            g["@list"] = _(d, g["@list"]);
        else if (e.isObject(g)) {
            i.isBlankNode(g) && (g["@id"] = d.getId(g["@id"]));
            const b = Object.keys(g).sort();
            for (let T = 0; T < b.length; ++T) {
                const N = b[T];
                N !== "@id" && (g[N] = _(d, g[N]))
            }
        }
        return g
    }
    return Sa
}
var Ta, wd;
function Vl() {
    if (wd)
        return Ta;
    wd = 1;
    const i = "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
      , e = "http://www.w3.org/2001/XMLSchema#";
    return Ta = {
        LINK_HEADER_REL: "http://www.w3.org/ns/json-ld#context",
        LINK_HEADER_CONTEXT: "http://www.w3.org/ns/json-ld#context",
        RDF: i,
        RDF_LIST: i + "List",
        RDF_FIRST: i + "first",
        RDF_REST: i + "rest",
        RDF_NIL: i + "nil",
        RDF_TYPE: i + "type",
        RDF_PLAIN_LITERAL: i + "PlainLiteral",
        RDF_XML_LITERAL: i + "XMLLiteral",
        RDF_JSON_LITERAL: i + "JSON",
        RDF_OBJECT: i + "object",
        RDF_LANGSTRING: i + "langString",
        XSD: e,
        XSD_BOOLEAN: e + "boolean",
        XSD_DOUBLE: e + "double",
        XSD_INTEGER: e + "integer",
        XSD_STRING: e + "string"
    },
    Ta
}
var La, xd;
function Mf() {
    return xd || (xd = 1,
    La = class {
        constructor() {
            this._requests = {}
        }
        wrapLoader(e) {
            const n = this;
            return n._loader = e,
            function() {
                return n.add.apply(n, arguments)
            }
        }
        async add(e) {
            let n = this._requests[e];
            if (n)
                return Promise.resolve(n);
            n = this._requests[e] = this._loader(e);
            try {
                return await n
            } finally {
                delete this._requests[e]
            }
        }
    }
    ),
    La
}
var Ia, Ed;
function Gn() {
    if (Ed)
        return Ia;
    Ed = 1;
    const i = qt()
      , e = {};
    Ia = e,
    e.parsers = {
        simple: {
            keys: ["href", "scheme", "authority", "path", "query", "fragment"],
            regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
        },
        full: {
            keys: ["href", "protocol", "scheme", "authority", "auth", "user", "password", "hostname", "port", "path", "directory", "file", "query", "fragment"],
            regex: /^(([a-zA-Z][a-zA-Z0-9+-.]*):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
    },
    e.parse = (r,o)=>{
        const a = {}
          , l = e.parsers[o || "full"]
          , u = l.regex.exec(r);
        let f = l.keys.length;
        for (; f--; )
            a[l.keys[f]] = u[f] === void 0 ? null : u[f];
        return (a.scheme === "https" && a.port === "443" || a.scheme === "http" && a.port === "80") && (a.href = a.href.replace(":" + a.port, ""),
        a.authority = a.authority.replace(":" + a.port, ""),
        a.port = null),
        a.normalizedPath = e.removeDotSegments(a.path),
        a
    }
    ,
    e.prependBase = (r,o)=>{
        if (r === null || e.isAbsolute(o))
            return o;
        (!r || i.isString(r)) && (r = e.parse(r || ""));
        const a = e.parse(o)
          , l = {
            protocol: r.protocol || ""
        };
        if (a.authority !== null)
            l.authority = a.authority,
            l.path = a.path,
            l.query = a.query;
        else if (l.authority = r.authority,
        a.path === "")
            l.path = r.path,
            a.query !== null ? l.query = a.query : l.query = r.query;
        else {
            if (a.path.indexOf("/") === 0)
                l.path = a.path;
            else {
                let f = r.path;
                f = f.substr(0, f.lastIndexOf("/") + 1),
                (f.length > 0 || r.authority) && f.substr(-1) !== "/" && (f += "/"),
                f += a.path,
                l.path = f
            }
            l.query = a.query
        }
        a.path !== "" && (l.path = e.removeDotSegments(l.path));
        let u = l.protocol;
        return l.authority !== null && (u += "//" + l.authority),
        u += l.path,
        l.query !== null && (u += "?" + l.query),
        a.fragment !== null && (u += "#" + a.fragment),
        u === "" && (u = "./"),
        u
    }
    ,
    e.removeBase = (r,o)=>{
        if (r === null)
            return o;
        (!r || i.isString(r)) && (r = e.parse(r || ""));
        let a = "";
        if (r.href !== "" ? a += (r.protocol || "") + "//" + (r.authority || "") : o.indexOf("//") && (a += "//"),
        o.indexOf(a) !== 0)
            return o;
        const l = e.parse(o.substr(a.length))
          , u = r.normalizedPath.split("/")
          , f = l.normalizedPath.split("/")
          , h = l.fragment || l.query ? 0 : 1;
        for (; u.length > 0 && f.length > h && u[0] === f[0]; )
            u.shift(),
            f.shift();
        let m = "";
        if (u.length > 0) {
            u.pop();
            for (let _ = 0; _ < u.length; ++_)
                m += "../"
        }
        return m += f.join("/"),
        l.query !== null && (m += "?" + l.query),
        l.fragment !== null && (m += "#" + l.fragment),
        m === "" && (m = "./"),
        m
    }
    ,
    e.removeDotSegments = r=>{
        if (r.length === 0)
            return "";
        const o = r.split("/")
          , a = [];
        for (; o.length > 0; ) {
            const l = o.shift()
              , u = o.length === 0;
            if (l === ".") {
                u && a.push("");
                continue
            }
            if (l === "..") {
                a.pop(),
                u && a.push("");
                continue
            }
            a.push(l)
        }
        return r[0] === "/" && a.length > 0 && a[0] !== "" && a.unshift(""),
        a.length === 1 && a[0] === "" ? "/" : a.join("/")
    }
    ;
    const n = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;
    return e.isAbsolute = r=>i.isString(r) && n.test(r),
    e.isRelative = r=>i.isString(r),
    Ia
}
var Na, Sd;
function bm() {
    if (Sd)
        return Na;
    Sd = 1;
    const {parseLinkHeader: i, buildHeaders: e} = Zt()
      , {LINK_HEADER_CONTEXT: n} = Vl()
      , r = Qt()
      , o = Mf()
      , {prependBase: a} = Gn()
      , l = /(^|(\r\n))link:/i;
    Na = ({secure: f, headers: h={}, xhr: m}={
        headers: {}
    })=>{
        return h = e(h),
        new o().wrapLoader(d);
        async function d(g) {
            if (g.indexOf("http:") !== 0 && g.indexOf("https:") !== 0)
                throw new r('URL could not be dereferenced; only "http" and "https" URLs are supported.',"jsonld.InvalidUrl",{
                    code: "loading document failed",
                    url: g
                });
            if (f && g.indexOf("https") !== 0)
                throw new r(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`,"jsonld.InvalidUrl",{
                    code: "loading document failed",
                    url: g
                });
            let b;
            try {
                b = await u(m, g, h)
            } catch (S) {
                throw new r("URL could not be dereferenced, an error occurred.","jsonld.LoadDocumentError",{
                    code: "loading document failed",
                    url: g,
                    cause: S
                })
            }
            if (b.status >= 400)
                throw new r("URL could not be dereferenced: " + b.statusText,"jsonld.LoadDocumentError",{
                    code: "loading document failed",
                    url: g,
                    httpStatusCode: b.status
                });
            let T = {
                contextUrl: null,
                documentUrl: g,
                document: b.response
            }
              , N = null;
            const A = b.getResponseHeader("Content-Type");
            let R;
            if (l.test(b.getAllResponseHeaders()) && (R = b.getResponseHeader("Link")),
            R && A !== "application/ld+json") {
                const S = i(R)
                  , y = S[n];
                if (Array.isArray(y))
                    throw new r("URL could not be dereferenced, it has more than one associated HTTP Link Header.","jsonld.InvalidUrl",{
                        code: "multiple context link headers",
                        url: g
                    });
                y && (T.contextUrl = y.target),
                N = S.alternate,
                N && N.type == "application/ld+json" && !(A || "").match(/^application\/(\w*\+)?json$/) && (T = await d(a(g, N.target)))
            }
            return T
        }
    }
    ;
    function u(f, h, m) {
        f = f || XMLHttpRequest;
        const _ = new f;
        return new Promise((d,g)=>{
            _.onload = ()=>d(_),
            _.onerror = b=>g(b),
            _.open("GET", h, !0);
            for (const b in m)
                _.setRequestHeader(b, m[b]);
            _.send()
        }
        )
    }
    return Na
}
var Aa, Td;
function wm() {
    if (Td)
        return Aa;
    Td = 1;
    const i = bm()
      , e = {};
    return Aa = e,
    e.setupDocumentLoaders = function(n) {
        typeof XMLHttpRequest < "u" && (n.documentLoaders.xhr = i,
        n.useDocumentLoader("xhr"))
    }
    ,
    e.setupGlobals = function(n) {
        typeof globalThis.JsonLdProcessor > "u" && Object.defineProperty(globalThis, "JsonLdProcessor", {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: n.JsonLdProcessor
        })
    }
    ,
    Aa
}
var Ra, Ld;
function xm() {
    return Ld || (Ld = 1,
    Ra = function(i) {
        i.prototype[Symbol.iterator] = function*() {
            for (let e = this.head; e; e = e.next)
                yield e.value
        }
    }
    ),
    Ra
}
var Ca, Id;
function Em() {
    if (Id)
        return Ca;
    Id = 1,
    Ca = i,
    i.Node = o,
    i.create = i;
    function i(a) {
        var l = this;
        if (l instanceof i || (l = new i),
        l.tail = null,
        l.head = null,
        l.length = 0,
        a && typeof a.forEach == "function")
            a.forEach(function(h) {
                l.push(h)
            });
        else if (arguments.length > 0)
            for (var u = 0, f = arguments.length; u < f; u++)
                l.push(arguments[u]);
        return l
    }
    i.prototype.removeNode = function(a) {
        if (a.list !== this)
            throw new Error("removing node which does not belong to this list");
        var l = a.next
          , u = a.prev;
        return l && (l.prev = u),
        u && (u.next = l),
        a === this.head && (this.head = l),
        a === this.tail && (this.tail = u),
        a.list.length--,
        a.next = null,
        a.prev = null,
        a.list = null,
        l
    }
    ,
    i.prototype.unshiftNode = function(a) {
        if (a !== this.head) {
            a.list && a.list.removeNode(a);
            var l = this.head;
            a.list = this,
            a.next = l,
            l && (l.prev = a),
            this.head = a,
            this.tail || (this.tail = a),
            this.length++
        }
    }
    ,
    i.prototype.pushNode = function(a) {
        if (a !== this.tail) {
            a.list && a.list.removeNode(a);
            var l = this.tail;
            a.list = this,
            a.prev = l,
            l && (l.next = a),
            this.tail = a,
            this.head || (this.head = a),
            this.length++
        }
    }
    ,
    i.prototype.push = function() {
        for (var a = 0, l = arguments.length; a < l; a++)
            n(this, arguments[a]);
        return this.length
    }
    ,
    i.prototype.unshift = function() {
        for (var a = 0, l = arguments.length; a < l; a++)
            r(this, arguments[a]);
        return this.length
    }
    ,
    i.prototype.pop = function() {
        if (this.tail) {
            var a = this.tail.value;
            return this.tail = this.tail.prev,
            this.tail ? this.tail.next = null : this.head = null,
            this.length--,
            a
        }
    }
    ,
    i.prototype.shift = function() {
        if (this.head) {
            var a = this.head.value;
            return this.head = this.head.next,
            this.head ? this.head.prev = null : this.tail = null,
            this.length--,
            a
        }
    }
    ,
    i.prototype.forEach = function(a, l) {
        l = l || this;
        for (var u = this.head, f = 0; u !== null; f++)
            a.call(l, u.value, f, this),
            u = u.next
    }
    ,
    i.prototype.forEachReverse = function(a, l) {
        l = l || this;
        for (var u = this.tail, f = this.length - 1; u !== null; f--)
            a.call(l, u.value, f, this),
            u = u.prev
    }
    ,
    i.prototype.get = function(a) {
        for (var l = 0, u = this.head; u !== null && l < a; l++)
            u = u.next;
        if (l === a && u !== null)
            return u.value
    }
    ,
    i.prototype.getReverse = function(a) {
        for (var l = 0, u = this.tail; u !== null && l < a; l++)
            u = u.prev;
        if (l === a && u !== null)
            return u.value
    }
    ,
    i.prototype.map = function(a, l) {
        l = l || this;
        for (var u = new i, f = this.head; f !== null; )
            u.push(a.call(l, f.value, this)),
            f = f.next;
        return u
    }
    ,
    i.prototype.mapReverse = function(a, l) {
        l = l || this;
        for (var u = new i, f = this.tail; f !== null; )
            u.push(a.call(l, f.value, this)),
            f = f.prev;
        return u
    }
    ,
    i.prototype.reduce = function(a, l) {
        var u, f = this.head;
        if (arguments.length > 1)
            u = l;
        else if (this.head)
            f = this.head.next,
            u = this.head.value;
        else
            throw new TypeError("Reduce of empty list with no initial value");
        for (var h = 0; f !== null; h++)
            u = a(u, f.value, h),
            f = f.next;
        return u
    }
    ,
    i.prototype.reduceReverse = function(a, l) {
        var u, f = this.tail;
        if (arguments.length > 1)
            u = l;
        else if (this.tail)
            f = this.tail.prev,
            u = this.tail.value;
        else
            throw new TypeError("Reduce of empty list with no initial value");
        for (var h = this.length - 1; f !== null; h--)
            u = a(u, f.value, h),
            f = f.prev;
        return u
    }
    ,
    i.prototype.toArray = function() {
        for (var a = new Array(this.length), l = 0, u = this.head; u !== null; l++)
            a[l] = u.value,
            u = u.next;
        return a
    }
    ,
    i.prototype.toArrayReverse = function() {
        for (var a = new Array(this.length), l = 0, u = this.tail; u !== null; l++)
            a[l] = u.value,
            u = u.prev;
        return a
    }
    ,
    i.prototype.slice = function(a, l) {
        l = l || this.length,
        l < 0 && (l += this.length),
        a = a || 0,
        a < 0 && (a += this.length);
        var u = new i;
        if (l < a || l < 0)
            return u;
        a < 0 && (a = 0),
        l > this.length && (l = this.length);
        for (var f = 0, h = this.head; h !== null && f < a; f++)
            h = h.next;
        for (; h !== null && f < l; f++,
        h = h.next)
            u.push(h.value);
        return u
    }
    ,
    i.prototype.sliceReverse = function(a, l) {
        l = l || this.length,
        l < 0 && (l += this.length),
        a = a || 0,
        a < 0 && (a += this.length);
        var u = new i;
        if (l < a || l < 0)
            return u;
        a < 0 && (a = 0),
        l > this.length && (l = this.length);
        for (var f = this.length, h = this.tail; h !== null && f > l; f--)
            h = h.prev;
        for (; h !== null && f > a; f--,
        h = h.prev)
            u.push(h.value);
        return u
    }
    ,
    i.prototype.splice = function(a, l, ...u) {
        a > this.length && (a = this.length - 1),
        a < 0 && (a = this.length + a);
        for (var f = 0, h = this.head; h !== null && f < a; f++)
            h = h.next;
        for (var m = [], f = 0; h && f < l; f++)
            m.push(h.value),
            h = this.removeNode(h);
        h === null && (h = this.tail),
        h !== this.head && h !== this.tail && (h = h.prev);
        for (var f = 0; f < u.length; f++)
            h = e(this, h, u[f]);
        return m
    }
    ,
    i.prototype.reverse = function() {
        for (var a = this.head, l = this.tail, u = a; u !== null; u = u.prev) {
            var f = u.prev;
            u.prev = u.next,
            u.next = f
        }
        return this.head = l,
        this.tail = a,
        this
    }
    ;
    function e(a, l, u) {
        var f = l === a.head ? new o(u,null,l,a) : new o(u,l,l.next,a);
        return f.next === null && (a.tail = f),
        f.prev === null && (a.head = f),
        a.length++,
        f
    }
    function n(a, l) {
        a.tail = new o(l,a.tail,null,a),
        a.head || (a.head = a.tail),
        a.length++
    }
    function r(a, l) {
        a.head = new o(l,null,a.head,a),
        a.tail || (a.tail = a.head),
        a.length++
    }
    function o(a, l, u, f) {
        if (!(this instanceof o))
            return new o(a,l,u,f);
        this.list = f,
        this.value = a,
        l ? (l.next = this,
        this.prev = l) : this.prev = null,
        u ? (u.prev = this,
        this.next = u) : this.next = null
    }
    try {
        xm()(i)
    } catch {}
    return Ca
}
var ka, Nd;
function Df() {
    if (Nd)
        return ka;
    Nd = 1;
    const i = Em()
      , e = Symbol("max")
      , n = Symbol("length")
      , r = Symbol("lengthCalculator")
      , o = Symbol("allowStale")
      , a = Symbol("maxAge")
      , l = Symbol("dispose")
      , u = Symbol("noDisposeOnSet")
      , f = Symbol("lruList")
      , h = Symbol("cache")
      , m = Symbol("updateAgeOnGet")
      , _ = ()=>1;
    class d {
        constructor(y) {
            if (typeof y == "number" && (y = {
                max: y
            }),
            y || (y = {}),
            y.max && (typeof y.max != "number" || y.max < 0))
                throw new TypeError("max must be a non-negative number");
            this[e] = y.max || 1 / 0;
            const x = y.length || _;
            if (this[r] = typeof x != "function" ? _ : x,
            this[o] = y.stale || !1,
            y.maxAge && typeof y.maxAge != "number")
                throw new TypeError("maxAge must be a number");
            this[a] = y.maxAge || 0,
            this[l] = y.dispose,
            this[u] = y.noDisposeOnSet || !1,
            this[m] = y.updateAgeOnGet || !1,
            this.reset()
        }
        set max(y) {
            if (typeof y != "number" || y < 0)
                throw new TypeError("max must be a non-negative number");
            this[e] = y || 1 / 0,
            T(this)
        }
        get max() {
            return this[e]
        }
        set allowStale(y) {
            this[o] = !!y
        }
        get allowStale() {
            return this[o]
        }
        set maxAge(y) {
            if (typeof y != "number")
                throw new TypeError("maxAge must be a non-negative number");
            this[a] = y,
            T(this)
        }
        get maxAge() {
            return this[a]
        }
        set lengthCalculator(y) {
            typeof y != "function" && (y = _),
            y !== this[r] && (this[r] = y,
            this[n] = 0,
            this[f].forEach(x=>{
                x.length = this[r](x.value, x.key),
                this[n] += x.length
            }
            )),
            T(this)
        }
        get lengthCalculator() {
            return this[r]
        }
        get length() {
            return this[n]
        }
        get itemCount() {
            return this[f].length
        }
        rforEach(y, x) {
            x = x || this;
            for (let M = this[f].tail; M !== null; ) {
                const U = M.prev;
                R(this, y, M, x),
                M = U
            }
        }
        forEach(y, x) {
            x = x || this;
            for (let M = this[f].head; M !== null; ) {
                const U = M.next;
                R(this, y, M, x),
                M = U
            }
        }
        keys() {
            return this[f].toArray().map(y=>y.key)
        }
        values() {
            return this[f].toArray().map(y=>y.value)
        }
        reset() {
            this[l] && this[f] && this[f].length && this[f].forEach(y=>this[l](y.key, y.value)),
            this[h] = new Map,
            this[f] = new i,
            this[n] = 0
        }
        dump() {
            return this[f].map(y=>b(this, y) ? !1 : {
                k: y.key,
                v: y.value,
                e: y.now + (y.maxAge || 0)
            }).toArray().filter(y=>y)
        }
        dumpLru() {
            return this[f]
        }
        set(y, x, M) {
            if (M = M || this[a],
            M && typeof M != "number")
                throw new TypeError("maxAge must be a number");
            const U = M ? Date.now() : 0
              , O = this[r](x, y);
            if (this[h].has(y)) {
                if (O > this[e])
                    return N(this, this[h].get(y)),
                    !1;
                const $ = this[h].get(y).value;
                return this[l] && (this[u] || this[l](y, $.value)),
                $.now = U,
                $.maxAge = M,
                $.value = x,
                this[n] += O - $.length,
                $.length = O,
                this.get(y),
                T(this),
                !0
            }
            const Q = new A(y,x,O,U,M);
            return Q.length > this[e] ? (this[l] && this[l](y, x),
            !1) : (this[n] += Q.length,
            this[f].unshift(Q),
            this[h].set(y, this[f].head),
            T(this),
            !0)
        }
        has(y) {
            if (!this[h].has(y))
                return !1;
            const x = this[h].get(y).value;
            return !b(this, x)
        }
        get(y) {
            return g(this, y, !0)
        }
        peek(y) {
            return g(this, y, !1)
        }
        pop() {
            const y = this[f].tail;
            return y ? (N(this, y),
            y.value) : null
        }
        del(y) {
            N(this, this[h].get(y))
        }
        load(y) {
            this.reset();
            const x = Date.now();
            for (let M = y.length - 1; M >= 0; M--) {
                const U = y[M]
                  , O = U.e || 0;
                if (O === 0)
                    this.set(U.k, U.v);
                else {
                    const Q = O - x;
                    Q > 0 && this.set(U.k, U.v, Q)
                }
            }
        }
        prune() {
            this[h].forEach((y,x)=>g(this, x, !1))
        }
    }
    const g = (S,y,x)=>{
        const M = S[h].get(y);
        if (M) {
            const U = M.value;
            if (b(S, U)) {
                if (N(S, M),
                !S[o])
                    return
            } else
                x && (S[m] && (M.value.now = Date.now()),
                S[f].unshiftNode(M));
            return U.value
        }
    }
      , b = (S,y)=>{
        if (!y || !y.maxAge && !S[a])
            return !1;
        const x = Date.now() - y.now;
        return y.maxAge ? x > y.maxAge : S[a] && x > S[a]
    }
      , T = S=>{
        if (S[n] > S[e])
            for (let y = S[f].tail; S[n] > S[e] && y !== null; ) {
                const x = y.prev;
                N(S, y),
                y = x
            }
    }
      , N = (S,y)=>{
        if (y) {
            const x = y.value;
            S[l] && S[l](x.key, x.value),
            S[n] -= x.length,
            S[h].delete(x.key),
            S[f].removeNode(y)
        }
    }
    ;
    class A {
        constructor(y, x, M, U, O) {
            this.key = y,
            this.value = x,
            this.length = M,
            this.now = U,
            this.maxAge = O || 0
        }
    }
    const R = (S,y,x,M)=>{
        let U = x.value;
        b(S, U) && (N(S, x),
        S[o] || (U = void 0)),
        U && y.call(M, U.value, U.key, S)
    }
    ;
    return ka = d,
    ka
}
var Pa, Ad;
function Sm() {
    if (Ad)
        return Pa;
    Ad = 1;
    const i = Df()
      , e = 10;
    return Pa = class {
        constructor({document: r}) {
            this.document = r,
            this.cache = new i({
                max: e
            })
        }
        getProcessed(r) {
            return this.cache.get(r)
        }
        setProcessed(r, o) {
            this.cache.set(r, o)
        }
    }
    ,
    Pa
}
var Ma, Rd;
function Tm() {
    if (Rd)
        return Ma;
    Rd = 1;
    const {isArray: i, isObject: e, isString: n} = qt()
      , {asArray: r} = Zt()
      , {prependBase: o} = Gn()
      , a = Qt()
      , l = Sm()
      , u = 10;
    Ma = class {
        constructor({sharedCache: _}) {
            this.perOpCache = new Map,
            this.sharedCache = _
        }
        async resolve({activeCtx: _, context: d, documentLoader: g, base: b, cycles: T=new Set}) {
            d && e(d) && d["@context"] && (d = d["@context"]),
            d = r(d);
            const N = [];
            for (const A of d) {
                if (n(A)) {
                    let y = this._get(A);
                    y || (y = await this._resolveRemoteContext({
                        activeCtx: _,
                        url: A,
                        documentLoader: g,
                        base: b,
                        cycles: T
                    })),
                    i(y) ? N.push(...y) : N.push(y);
                    continue
                }
                if (A === null) {
                    N.push(new l({
                        document: null
                    }));
                    continue
                }
                e(A) || f(d);
                const R = JSON.stringify(A);
                let S = this._get(R);
                S || (S = new l({
                    document: A
                }),
                this._cacheResolvedContext({
                    key: R,
                    resolved: S,
                    tag: "static"
                })),
                N.push(S)
            }
            return N
        }
        _get(_) {
            let d = this.perOpCache.get(_);
            if (!d) {
                const g = this.sharedCache.get(_);
                g && (d = g.get("static"),
                d && this.perOpCache.set(_, d))
            }
            return d
        }
        _cacheResolvedContext({key: _, resolved: d, tag: g}) {
            if (this.perOpCache.set(_, d),
            g !== void 0) {
                let b = this.sharedCache.get(_);
                b || (b = new Map,
                this.sharedCache.set(_, b)),
                b.set(g, d)
            }
            return d
        }
        async _resolveRemoteContext({activeCtx: _, url: d, documentLoader: g, base: b, cycles: T}) {
            d = o(b, d);
            const {context: N, remoteDoc: A} = await this._fetchContext({
                activeCtx: _,
                url: d,
                documentLoader: g,
                cycles: T
            });
            b = A.documentUrl || d,
            h({
                context: N,
                base: b
            });
            const R = await this.resolve({
                activeCtx: _,
                context: N,
                documentLoader: g,
                base: b,
                cycles: T
            });
            return this._cacheResolvedContext({
                key: d,
                resolved: R,
                tag: A.tag
            }),
            R
        }
        async _fetchContext({activeCtx: _, url: d, documentLoader: g, cycles: b}) {
            if (b.size > u)
                throw new a("Maximum number of @context URLs exceeded.","jsonld.ContextUrlError",{
                    code: _.processingMode === "json-ld-1.0" ? "loading remote context failed" : "context overflow",
                    max: u
                });
            if (b.has(d))
                throw new a("Cyclical @context URLs detected.","jsonld.ContextUrlError",{
                    code: _.processingMode === "json-ld-1.0" ? "recursive context inclusion" : "context overflow",
                    url: d
                });
            b.add(d);
            let T, N;
            try {
                N = await g(d),
                T = N.document || null,
                n(T) && (T = JSON.parse(T))
            } catch (A) {
                throw new a(`Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context. URL: "${d}".`,"jsonld.InvalidUrl",{
                    code: "loading remote context failed",
                    url: d,
                    cause: A
                })
            }
            if (!e(T))
                throw new a(`Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object. URL: "${d}".`,"jsonld.InvalidUrl",{
                    code: "invalid remote context",
                    url: d
                });
            return "@context"in T ? T = {
                "@context": T["@context"]
            } : T = {
                "@context": {}
            },
            N.contextUrl && (i(T["@context"]) || (T["@context"] = [T["@context"]]),
            T["@context"].push(N.contextUrl)),
            {
                context: T,
                remoteDoc: N
            }
        }
    }
    ;
    function f(m) {
        throw new a("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{
            code: "invalid local context",
            context: m
        })
    }
    function h({context: m, base: _}) {
        if (!m)
            return;
        const d = m["@context"];
        if (n(d)) {
            m["@context"] = o(_, d);
            return
        }
        if (i(d)) {
            for (let g = 0; g < d.length; ++g) {
                const b = d[g];
                if (n(b)) {
                    d[g] = o(_, b);
                    continue
                }
                e(b) && h({
                    context: {
                        "@context": b
                    },
                    base: _
                })
            }
            return
        }
        if (e(d))
            for (const g in d)
                h({
                    context: d[g],
                    base: _
                })
    }
    return Ma
}
var Da, Cd;
function Lm() {
    return Cd || (Cd = 1,
    Da = Hl().NQuads),
    Da
}
var Oa, kd;
function Gr() {
    if (kd)
        return Oa;
    kd = 1;
    const i = Qt()
      , {isArray: e} = qt()
      , {asArray: n} = Zt()
      , r = {};
    Oa = r,
    r.defaultEventHandler = null,
    r.setupEventHandler = ({options: l={}})=>{
        const u = [].concat(l.safe ? r.safeEventHandler : [], l.eventHandler ? n(l.eventHandler) : [], r.defaultEventHandler ? r.defaultEventHandler : []);
        return u.length === 0 ? null : u
    }
    ,
    r.handleEvent = ({event: l, options: u})=>{
        o({
            event: l,
            handlers: u.eventHandler
        })
    }
    ;
    function o({event: l, handlers: u}) {
        let f = !0;
        for (let h = 0; f && h < u.length; ++h) {
            f = !1;
            const m = u[h];
            if (e(m))
                f = o({
                    event: l,
                    handlers: m
                });
            else if (typeof m == "function")
                m({
                    event: l,
                    next: ()=>{
                        f = !0
                    }
                });
            else if (typeof m == "object")
                l.code in m ? m[l.code]({
                    event: l,
                    next: ()=>{
                        f = !0
                    }
                }) : f = !0;
            else
                throw new i("Invalid event handler.","jsonld.InvalidEventHandler",{
                    event: l
                })
        }
        return f
    }
    const a = new Set(["empty object", "free-floating scalar", "invalid @language value", "invalid property", "null @id value", "null @value value", "object with only @id", "object with only @language", "object with only @list", "object with only @value", "relative @id reference", "relative @type reference", "relative @vocab reference", "reserved @id value", "reserved @reverse value", "reserved term", "blank node predicate", "relative graph reference", "relative object reference", "relative predicate reference", "relative subject reference", "rdfDirection not set"]);
    return r.safeEventHandler = function({event: u, next: f}) {
        if (u.level === "warning" && a.has(u.code))
            throw new i("Safe mode validation error.","jsonld.ValidationError",{
                event: u
            });
        f()
    }
    ,
    r.logEventHandler = function({event: u, next: f}) {
        console.log(`EVENT: ${u.message}`, {
            event: u
        }),
        f()
    }
    ,
    r.logWarningEventHandler = function({event: u, next: f}) {
        u.level === "warning" && console.warn(`WARNING: ${u.message}`, {
            event: u
        }),
        f()
    }
    ,
    r.unhandledEventHandler = function({event: u}) {
        throw new i("No handler for event.","jsonld.UnhandledEvent",{
            event: u
        })
    }
    ,
    r.setDefaultEventHandler = function({eventHandler: l}={}) {
        r.defaultEventHandler = l ? n(l) : null
    }
    ,
    Oa
}
var Fa, Pd;
function _i() {
    if (Pd)
        return Fa;
    Pd = 1;
    const i = Zt()
      , e = Qt()
      , {isArray: n, isObject: r, isString: o, isUndefined: a} = qt()
      , {isAbsolute: l, isRelative: u, prependBase: f} = Gn()
      , {handleEvent: h} = Gr()
      , {REGEX_BCP47: m, REGEX_KEYWORD: _, asArray: d, compareShortestLeast: g} = Zt()
      , b = new Map
      , T = 1e4
      , N = {};
    Fa = N,
    N.process = async({activeCtx: S, localCtx: y, options: x, propagate: M=!0, overrideProtected: U=!1, cycles: O=new Set})=>{
        if (r(y) && "@context"in y && n(y["@context"]) && (y = y["@context"]),
        d(y).length === 0)
            return S;
        const D = []
          , $ = [({event: ue, next: P})=>{
            D.push(ue),
            P()
        }
        ];
        x.eventHandler && $.push(x.eventHandler);
        const X = x;
        x = {
            ...x,
            eventHandler: $
        };
        const F = await x.contextResolver.resolve({
            activeCtx: S,
            context: y,
            documentLoader: x.documentLoader,
            base: x.base
        });
        r(F[0].document) && typeof F[0].document["@propagate"] == "boolean" && (M = F[0].document["@propagate"]);
        let B = S;
        !M && !B.previousContext && (B = B.clone(),
        B.previousContext = S);
        for (const ue of F) {
            let {document: P} = ue;
            if (S = B,
            P === null) {
                if (!U && Object.keys(S.protected).length !== 0)
                    throw new e("Tried to nullify a context with protected terms outside of a term definition.","jsonld.SyntaxError",{
                        code: "invalid context nullification"
                    });
                B = S = N.getInitialContext(x).clone();
                continue
            }
            const oe = ue.getProcessed(S);
            if (oe) {
                if (X.eventHandler)
                    for (const ae of oe.events)
                        h({
                            event: ae,
                            options: X
                        });
                B = S = oe.context;
                continue
            }
            if (r(P) && "@context"in P && (P = P["@context"]),
            !r(P))
                throw new e("Invalid JSON-LD syntax; @context must be an object.","jsonld.SyntaxError",{
                    code: "invalid local context",
                    context: P
                });
            B = B.clone();
            const j = new Map;
            if ("@version"in P) {
                if (P["@version"] !== 1.1)
                    throw new e("Unsupported JSON-LD version: " + P["@version"],"jsonld.UnsupportedVersion",{
                        code: "invalid @version value",
                        context: P
                    });
                if (S.processingMode && S.processingMode === "json-ld-1.0")
                    throw new e("@version: " + P["@version"] + " not compatible with " + S.processingMode,"jsonld.ProcessingModeConflict",{
                        code: "processing mode conflict",
                        context: P
                    });
                B.processingMode = "json-ld-1.1",
                B["@version"] = P["@version"],
                j.set("@version", !0)
            }
            if (B.processingMode = B.processingMode || S.processingMode,
            "@base"in P) {
                let ae = P["@base"];
                if (!(ae === null || l(ae)))
                    if (u(ae))
                        ae = f(B["@base"], ae);
                    else
                        throw new e('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.',"jsonld.SyntaxError",{
                            code: "invalid base IRI",
                            context: P
                        });
                B["@base"] = ae,
                j.set("@base", !0)
            }
            if ("@vocab"in P) {
                const ae = P["@vocab"];
                if (ae === null)
                    delete B["@vocab"];
                else if (o(ae)) {
                    if (!l(ae) && N.processingMode(B, 1))
                        throw new e('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.',"jsonld.SyntaxError",{
                            code: "invalid vocab mapping",
                            context: P
                        });
                    {
                        const I = A(B, ae, {
                            vocab: !0,
                            base: !0
                        }, void 0, void 0, x);
                        l(I) || x.eventHandler && h({
                            event: {
                                type: ["JsonLdEvent"],
                                code: "relative @vocab reference",
                                level: "warning",
                                message: "Relative @vocab reference found.",
                                details: {
                                    vocab: I
                                }
                            },
                            options: x
                        }),
                        B["@vocab"] = I
                    }
                } else
                    throw new e('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.',"jsonld.SyntaxError",{
                        code: "invalid vocab mapping",
                        context: P
                    });
                j.set("@vocab", !0)
            }
            if ("@language"in P) {
                const ae = P["@language"];
                if (ae === null)
                    delete B["@language"];
                else if (o(ae))
                    ae.match(m) || x.eventHandler && h({
                        event: {
                            type: ["JsonLdEvent"],
                            code: "invalid @language value",
                            level: "warning",
                            message: "@language value must be valid BCP47.",
                            details: {
                                language: ae
                            }
                        },
                        options: x
                    }),
                    B["@language"] = ae.toLowerCase();
                else
                    throw new e('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.',"jsonld.SyntaxError",{
                        code: "invalid default language",
                        context: P
                    });
                j.set("@language", !0)
            }
            if ("@direction"in P) {
                const ae = P["@direction"];
                if (S.processingMode === "json-ld-1.0")
                    throw new e("Invalid JSON-LD syntax; @direction not compatible with " + S.processingMode,"jsonld.SyntaxError",{
                        code: "invalid context member",
                        context: P
                    });
                if (ae === null)
                    delete B["@direction"];
                else {
                    if (ae !== "ltr" && ae !== "rtl")
                        throw new e('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{
                            code: "invalid base direction",
                            context: P
                        });
                    B["@direction"] = ae
                }
                j.set("@direction", !0)
            }
            if ("@propagate"in P) {
                const ae = P["@propagate"];
                if (S.processingMode === "json-ld-1.0")
                    throw new e("Invalid JSON-LD syntax; @propagate not compatible with " + S.processingMode,"jsonld.SyntaxError",{
                        code: "invalid context entry",
                        context: P
                    });
                if (typeof ae != "boolean")
                    throw new e("Invalid JSON-LD syntax; @propagate value must be a boolean.","jsonld.SyntaxError",{
                        code: "invalid @propagate value",
                        context: y
                    });
                j.set("@propagate", !0)
            }
            if ("@import"in P) {
                const ae = P["@import"];
                if (S.processingMode === "json-ld-1.0")
                    throw new e("Invalid JSON-LD syntax; @import not compatible with " + S.processingMode,"jsonld.SyntaxError",{
                        code: "invalid context entry",
                        context: P
                    });
                if (!o(ae))
                    throw new e("Invalid JSON-LD syntax; @import must be a string.","jsonld.SyntaxError",{
                        code: "invalid @import value",
                        context: y
                    });
                const I = await x.contextResolver.resolve({
                    activeCtx: S,
                    context: ae,
                    documentLoader: x.documentLoader,
                    base: x.base
                });
                if (I.length !== 1)
                    throw new e("Invalid JSON-LD syntax; @import must reference a single context.","jsonld.SyntaxError",{
                        code: "invalid remote context",
                        context: y
                    });
                const Z = I[0].getProcessed(S);
                if (Z)
                    P = Z;
                else {
                    const ie = I[0].document;
                    if ("@import"in ie)
                        throw new e("Invalid JSON-LD syntax: imported context must not include @import.","jsonld.SyntaxError",{
                            code: "invalid context entry",
                            context: y
                        });
                    for (const ee in ie)
                        P.hasOwnProperty(ee) || (P[ee] = ie[ee]);
                    I[0].setProcessed(S, P)
                }
                j.set("@import", !0)
            }
            j.set("@protected", P["@protected"] || !1);
            for (const ae in P)
                if (N.createTermDefinition({
                    activeCtx: B,
                    localCtx: P,
                    term: ae,
                    defined: j,
                    options: x,
                    overrideProtected: U
                }),
                r(P[ae]) && "@context"in P[ae]) {
                    const I = P[ae]["@context"];
                    let Z = !0;
                    if (o(I)) {
                        const ie = f(x.base, I);
                        O.has(ie) ? Z = !1 : O.add(ie)
                    }
                    if (Z)
                        try {
                            await N.process({
                                activeCtx: B.clone(),
                                localCtx: P[ae]["@context"],
                                overrideProtected: !0,
                                options: x,
                                cycles: O
                            })
                        } catch {
                            throw new e("Invalid JSON-LD syntax; invalid scoped context.","jsonld.SyntaxError",{
                                code: "invalid scoped context",
                                context: P[ae]["@context"],
                                term: ae
                            })
                        }
                }
            ue.setProcessed(S, {
                context: B,
                events: D
            })
        }
        return B
    }
    ,
    N.createTermDefinition = ({activeCtx: S, localCtx: y, term: x, defined: M, options: U, overrideProtected: O=!1})=>{
        if (M.has(x)) {
            if (M.get(x))
                return;
            throw new e("Cyclical context definition detected.","jsonld.CyclicalContext",{
                code: "cyclic IRI mapping",
                context: y,
                term: x
            })
        }
        M.set(x, !1);
        let Q;
        if (y.hasOwnProperty(x) && (Q = y[x]),
        x === "@type" && r(Q) && (Q["@container"] || "@set") === "@set" && N.processingMode(S, 1.1)) {
            const P = ["@container", "@id", "@protected"]
              , oe = Object.keys(Q);
            if (oe.length === 0 || oe.some(j=>!P.includes(j)))
                throw new e("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{
                    code: "keyword redefinition",
                    context: y,
                    term: x
                })
        } else {
            if (N.isKeyword(x))
                throw new e("Invalid JSON-LD syntax; keywords cannot be overridden.","jsonld.SyntaxError",{
                    code: "keyword redefinition",
                    context: y,
                    term: x
                });
            if (x.match(_)) {
                U.eventHandler && h({
                    event: {
                        type: ["JsonLdEvent"],
                        code: "reserved term",
                        level: "warning",
                        message: 'Terms beginning with "@" are reserved for future use and dropped.',
                        details: {
                            term: x
                        }
                    },
                    options: U
                });
                return
            } else if (x === "")
                throw new e("Invalid JSON-LD syntax; a term cannot be an empty string.","jsonld.SyntaxError",{
                    code: "invalid term definition",
                    context: y
                })
        }
        const D = S.mappings.get(x);
        S.mappings.has(x) && S.mappings.delete(x);
        let $ = !1;
        if ((o(Q) || Q === null) && ($ = !0,
        Q = {
            "@id": Q
        }),
        !r(Q))
            throw new e("Invalid JSON-LD syntax; @context term values must be strings or objects.","jsonld.SyntaxError",{
                code: "invalid term definition",
                context: y
            });
        const X = {};
        S.mappings.set(x, X),
        X.reverse = !1;
        const F = ["@container", "@id", "@language", "@reverse", "@type"];
        N.processingMode(S, 1.1) && F.push("@context", "@direction", "@index", "@nest", "@prefix", "@protected");
        for (const P in Q)
            if (!F.includes(P))
                throw new e("Invalid JSON-LD syntax; a term definition must not contain " + P,"jsonld.SyntaxError",{
                    code: "invalid term definition",
                    context: y
                });
        const B = x.indexOf(":");
        if (X._termHasColon = B > 0,
        "@reverse"in Q) {
            if ("@id"in Q)
                throw new e("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.","jsonld.SyntaxError",{
                    code: "invalid reverse property",
                    context: y
                });
            if ("@nest"in Q)
                throw new e("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.","jsonld.SyntaxError",{
                    code: "invalid reverse property",
                    context: y
                });
            const P = Q["@reverse"];
            if (!o(P))
                throw new e("Invalid JSON-LD syntax; a @context @reverse value must be a string.","jsonld.SyntaxError",{
                    code: "invalid IRI mapping",
                    context: y
                });
            if (P.match(_)) {
                U.eventHandler && h({
                    event: {
                        type: ["JsonLdEvent"],
                        code: "reserved @reverse value",
                        level: "warning",
                        message: '@reverse values beginning with "@" are reserved for future use and dropped.',
                        details: {
                            reverse: P
                        }
                    },
                    options: U
                }),
                D ? S.mappings.set(x, D) : S.mappings.delete(x);
                return
            }
            const oe = A(S, P, {
                vocab: !0,
                base: !1
            }, y, M, U);
            if (!l(oe))
                throw new e("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.","jsonld.SyntaxError",{
                    code: "invalid IRI mapping",
                    context: y
                });
            X["@id"] = oe,
            X.reverse = !0
        } else if ("@id"in Q) {
            let P = Q["@id"];
            if (P && !o(P))
                throw new e("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.","jsonld.SyntaxError",{
                    code: "invalid IRI mapping",
                    context: y
                });
            if (P === null)
                X["@id"] = null;
            else if (!N.isKeyword(P) && P.match(_)) {
                U.eventHandler && h({
                    event: {
                        type: ["JsonLdEvent"],
                        code: "reserved @id value",
                        level: "warning",
                        message: '@id values beginning with "@" are reserved for future use and dropped.',
                        details: {
                            id: P
                        }
                    },
                    options: U
                }),
                D ? S.mappings.set(x, D) : S.mappings.delete(x);
                return
            } else if (P !== x) {
                if (P = A(S, P, {
                    vocab: !0,
                    base: !1
                }, y, M, U),
                !l(P) && !N.isKeyword(P))
                    throw new e("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.","jsonld.SyntaxError",{
                        code: "invalid IRI mapping",
                        context: y
                    });
                if (x.match(/(?::[^:])|\//)) {
                    const oe = new Map(M).set(x, !0);
                    if (A(S, x, {
                        vocab: !0,
                        base: !1
                    }, y, oe, U) !== P)
                        throw new e("Invalid JSON-LD syntax; term in form of IRI must expand to definition.","jsonld.SyntaxError",{
                            code: "invalid IRI mapping",
                            context: y
                        })
                }
                X["@id"] = P,
                X._prefix = $ && !X._termHasColon && P.match(/[:\/\?#\[\]@]$/) !== null
            }
        }
        if (!("@id"in X))
            if (X._termHasColon) {
                const P = x.substr(0, B);
                if (y.hasOwnProperty(P) && N.createTermDefinition({
                    activeCtx: S,
                    localCtx: y,
                    term: P,
                    defined: M,
                    options: U
                }),
                S.mappings.has(P)) {
                    const oe = x.substr(B + 1);
                    X["@id"] = S.mappings.get(P)["@id"] + oe
                } else
                    X["@id"] = x
            } else if (x === "@type")
                X["@id"] = x;
            else {
                if (!("@vocab"in S))
                    throw new e("Invalid JSON-LD syntax; @context terms must define an @id.","jsonld.SyntaxError",{
                        code: "invalid IRI mapping",
                        context: y,
                        term: x
                    });
                X["@id"] = S["@vocab"] + x
            }
        if ((Q["@protected"] === !0 || M.get("@protected") === !0 && Q["@protected"] !== !1) && (S.protected[x] = !0,
        X.protected = !0),
        M.set(x, !0),
        "@type"in Q) {
            let P = Q["@type"];
            if (!o(P))
                throw new e("Invalid JSON-LD syntax; an @context @type value must be a string.","jsonld.SyntaxError",{
                    code: "invalid type mapping",
                    context: y
                });
            if (P === "@json" || P === "@none") {
                if (N.processingMode(S, 1))
                    throw new e(`Invalid JSON-LD syntax; an @context @type value must not be "${P}" in JSON-LD 1.0 mode.`,"jsonld.SyntaxError",{
                        code: "invalid type mapping",
                        context: y
                    })
            } else if (P !== "@id" && P !== "@vocab") {
                if (P = A(S, P, {
                    vocab: !0,
                    base: !1
                }, y, M, U),
                !l(P))
                    throw new e("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.","jsonld.SyntaxError",{
                        code: "invalid type mapping",
                        context: y
                    });
                if (P.indexOf("_:") === 0)
                    throw new e("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.","jsonld.SyntaxError",{
                        code: "invalid type mapping",
                        context: y
                    })
            }
            X["@type"] = P
        }
        if ("@container"in Q) {
            const P = o(Q["@container"]) ? [Q["@container"]] : Q["@container"] || []
              , oe = ["@list", "@set", "@index", "@language"];
            let j = !0;
            const ae = P.includes("@set");
            if (N.processingMode(S, 1.1)) {
                if (oe.push("@graph", "@id", "@type"),
                P.includes("@list")) {
                    if (P.length !== 1)
                        throw new e("Invalid JSON-LD syntax; @context @container with @list must have no other values","jsonld.SyntaxError",{
                            code: "invalid container mapping",
                            context: y
                        })
                } else if (P.includes("@graph")) {
                    if (P.some(I=>I !== "@graph" && I !== "@id" && I !== "@index" && I !== "@set"))
                        throw new e("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set","jsonld.SyntaxError",{
                            code: "invalid container mapping",
                            context: y
                        })
                } else
                    j &= P.length <= (ae ? 2 : 1);
                if (P.includes("@type") && (X["@type"] = X["@type"] || "@id",
                !["@id", "@vocab"].includes(X["@type"])))
                    throw new e("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.","jsonld.SyntaxError",{
                        code: "invalid type mapping",
                        context: y
                    })
            } else
                j &= !n(Q["@container"]),
                j &= P.length <= 1;
            if (j &= P.every(I=>oe.includes(I)),
            j &= !(ae && P.includes("@list")),
            !j)
                throw new e("Invalid JSON-LD syntax; @context @container value must be one of the following: " + oe.join(", "),"jsonld.SyntaxError",{
                    code: "invalid container mapping",
                    context: y
                });
            if (X.reverse && !P.every(I=>["@index", "@set"].includes(I)))
                throw new e("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.","jsonld.SyntaxError",{
                    code: "invalid reverse property",
                    context: y
                });
            X["@container"] = P
        }
        if ("@index"in Q) {
            if (!("@container"in Q) || !X["@container"].includes("@index"))
                throw new e(`Invalid JSON-LD syntax; @index without @index in @container: "${Q["@index"]}" on term "${x}".`,"jsonld.SyntaxError",{
                    code: "invalid term definition",
                    context: y
                });
            if (!o(Q["@index"]) || Q["@index"].indexOf("@") === 0)
                throw new e(`Invalid JSON-LD syntax; @index must expand to an IRI: "${Q["@index"]}" on term "${x}".`,"jsonld.SyntaxError",{
                    code: "invalid term definition",
                    context: y
                });
            X["@index"] = Q["@index"]
        }
        if ("@context"in Q && (X["@context"] = Q["@context"]),
        "@language"in Q && !("@type"in Q)) {
            let P = Q["@language"];
            if (P !== null && !o(P))
                throw new e("Invalid JSON-LD syntax; @context @language value must be a string or null.","jsonld.SyntaxError",{
                    code: "invalid language mapping",
                    context: y
                });
            P !== null && (P = P.toLowerCase()),
            X["@language"] = P
        }
        if ("@prefix"in Q) {
            if (x.match(/:|\//))
                throw new e("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term","jsonld.SyntaxError",{
                    code: "invalid term definition",
                    context: y
                });
            if (N.isKeyword(X["@id"]))
                throw new e("Invalid JSON-LD syntax; keywords may not be used as prefixes","jsonld.SyntaxError",{
                    code: "invalid term definition",
                    context: y
                });
            if (typeof Q["@prefix"] == "boolean")
                X._prefix = Q["@prefix"] === !0;
            else
                throw new e("Invalid JSON-LD syntax; @context value for @prefix must be boolean","jsonld.SyntaxError",{
                    code: "invalid @prefix value",
                    context: y
                })
        }
        if ("@direction"in Q) {
            const P = Q["@direction"];
            if (P !== null && P !== "ltr" && P !== "rtl")
                throw new e('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".',"jsonld.SyntaxError",{
                    code: "invalid base direction",
                    context: y
                });
            X["@direction"] = P
        }
        if ("@nest"in Q) {
            const P = Q["@nest"];
            if (!o(P) || P !== "@nest" && P.indexOf("@") === 0)
                throw new e("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.","jsonld.SyntaxError",{
                    code: "invalid @nest value",
                    context: y
                });
            X["@nest"] = P
        }
        const ue = X["@id"];
        if (ue === "@context" || ue === "@preserve")
            throw new e("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.","jsonld.SyntaxError",{
                code: "invalid keyword alias",
                context: y
            });
        if (D && D.protected && !O && (S.protected[x] = !0,
        X.protected = !0,
        !R(D, X)))
            throw new e("Invalid JSON-LD syntax; tried to redefine a protected term.","jsonld.SyntaxError",{
                code: "protected term redefinition",
                context: y,
                term: x
            })
    }
    ,
    N.expandIri = (S,y,x,M)=>A(S, y, x, void 0, void 0, M);
    function A(S, y, x, M, U, O) {
        if (y === null || !o(y) || N.isKeyword(y))
            return y;
        if (y.match(_))
            return null;
        if (M && M.hasOwnProperty(y) && U.get(y) !== !0 && N.createTermDefinition({
            activeCtx: S,
            localCtx: M,
            term: y,
            defined: U,
            options: O
        }),
        x = x || {},
        x.vocab) {
            const D = S.mappings.get(y);
            if (D === null)
                return null;
            if (r(D) && "@id"in D)
                return D["@id"]
        }
        const Q = y.indexOf(":");
        if (Q > 0) {
            const D = y.substr(0, Q)
              , $ = y.substr(Q + 1);
            if (D === "_" || $.indexOf("//") === 0)
                return y;
            M && M.hasOwnProperty(D) && N.createTermDefinition({
                activeCtx: S,
                localCtx: M,
                term: D,
                defined: U,
                options: O
            });
            const X = S.mappings.get(D);
            if (X && X._prefix)
                return X["@id"] + $;
            if (l(y))
                return y
        }
        if (x.vocab && "@vocab"in S)
            y = S["@vocab"] + y;
        else if (x.base) {
            let D, $;
            "@base"in S ? S["@base"] ? ($ = f(O.base, S["@base"]),
            D = f($, y)) : ($ = S["@base"],
            D = y) : ($ = O.base,
            D = f(O.base, y)),
            y = D
        }
        return y
    }
    N.getInitialContext = S=>{
        const y = JSON.stringify({
            processingMode: S.processingMode
        })
          , x = b.get(y);
        if (x)
            return x;
        const M = {
            processingMode: S.processingMode,
            mappings: new Map,
            inverse: null,
            getInverse: U,
            clone: D,
            revertToPreviousContext: $,
            protected: {}
        };
        return b.size === T && b.clear(),
        b.set(y, M),
        M;
        function U() {
            const X = this;
            if (X.inverse)
                return X.inverse;
            const F = X.inverse = {}
              , B = X.fastCurieMap = {}
              , ue = {}
              , P = (X["@language"] || "@none").toLowerCase()
              , oe = X["@direction"]
              , j = X.mappings
              , ae = [...j.keys()].sort(g);
            for (const I of ae) {
                const Z = j.get(I);
                if (Z === null)
                    continue;
                let ie = Z["@container"] || "@none";
                if (ie = [].concat(ie).sort().join(""),
                Z["@id"] === null)
                    continue;
                const ee = d(Z["@id"]);
                for (const me of ee) {
                    let W = F[me];
                    const G = N.isKeyword(me);
                    if (W)
                        !G && !Z._termHasColon && ue[me].push(I);
                    else if (F[me] = W = {},
                    !G && !Z._termHasColon) {
                        ue[me] = [I];
                        const Y = {
                            iri: me,
                            terms: ue[me]
                        };
                        me[0]in B ? B[me[0]].push(Y) : B[me[0]] = [Y]
                    }
                    if (W[ie] || (W[ie] = {
                        "@language": {},
                        "@type": {},
                        "@any": {}
                    }),
                    W = W[ie],
                    Q(I, W["@any"], "@none"),
                    Z.reverse)
                        Q(I, W["@type"], "@reverse");
                    else if (Z["@type"] === "@none")
                        Q(I, W["@any"], "@none"),
                        Q(I, W["@language"], "@none"),
                        Q(I, W["@type"], "@none");
                    else if ("@type"in Z)
                        Q(I, W["@type"], Z["@type"]);
                    else if ("@language"in Z && "@direction"in Z) {
                        const Y = Z["@language"]
                          , K = Z["@direction"];
                        Y && K ? Q(I, W["@language"], `${Y}_ ${K}`.toLowerCase()) : Y ? Q(I, W["@language"], Y.toLowerCase()) : K ? Q(I, W["@language"], `_ ${K}`) : Q(I, W["@language"], "@null")
                    } else
                        "@language"in Z ? Q(I, W["@language"], (Z["@language"] || "@null").toLowerCase()) : "@direction"in Z ? Z["@direction"] ? Q(I, W["@language"], `_ ${Z["@direction"]}`) : Q(I, W["@language"], "@none") : oe ? (Q(I, W["@language"], `_ ${oe}`),
                        Q(I, W["@language"], "@none"),
                        Q(I, W["@type"], "@none")) : (Q(I, W["@language"], P),
                        Q(I, W["@language"], "@none"),
                        Q(I, W["@type"], "@none"))
                }
            }
            for (const I in B)
                O(B, I, 1);
            return F
        }
        function O(X, F, B) {
            const ue = X[F]
              , P = X[F] = {};
            let oe, j;
            for (const ae of ue)
                oe = ae.iri,
                B >= oe.length ? j = "" : j = oe[B],
                j in P ? P[j].push(ae) : P[j] = [ae];
            for (const ae in P)
                ae !== "" && O(P, ae, B + 1)
        }
        function Q(X, F, B) {
            F.hasOwnProperty(B) || (F[B] = X)
        }
        function D() {
            const X = {};
            return X.mappings = i.clone(this.mappings),
            X.clone = this.clone,
            X.inverse = null,
            X.getInverse = this.getInverse,
            X.protected = i.clone(this.protected),
            this.previousContext && (X.previousContext = this.previousContext.clone()),
            X.revertToPreviousContext = this.revertToPreviousContext,
            "@base"in this && (X["@base"] = this["@base"]),
            "@language"in this && (X["@language"] = this["@language"]),
            "@vocab"in this && (X["@vocab"] = this["@vocab"]),
            X
        }
        function $() {
            return this.previousContext ? this.previousContext.clone() : this
        }
    }
    ,
    N.getContextValue = (S,y,x)=>{
        if (y === null)
            return x === "@context" ? void 0 : null;
        if (S.mappings.has(y)) {
            const M = S.mappings.get(y);
            if (a(x))
                return M;
            if (M.hasOwnProperty(x))
                return M[x]
        }
        if (x === "@language" && x in S || x === "@direction" && x in S)
            return S[x];
        if (x !== "@context")
            return null
    }
    ,
    N.processingMode = (S,y)=>y.toString() >= "1.1" ? !S.processingMode || S.processingMode >= "json-ld-" + y.toString() : S.processingMode === "json-ld-1.0",
    N.isKeyword = S=>{
        if (!o(S) || S[0] !== "@")
            return !1;
        switch (S) {
        case "@base":
        case "@container":
        case "@context":
        case "@default":
        case "@direction":
        case "@embed":
        case "@explicit":
        case "@graph":
        case "@id":
        case "@included":
        case "@index":
        case "@json":
        case "@language":
        case "@list":
        case "@nest":
        case "@none":
        case "@omitDefault":
        case "@prefix":
        case "@preserve":
        case "@protected":
        case "@requireAll":
        case "@reverse":
        case "@set":
        case "@type":
        case "@value":
        case "@version":
        case "@vocab":
            return !0
        }
        return !1
    }
    ;
    function R(S, y) {
        if (!(S && typeof S == "object") || !(y && typeof y == "object"))
            return S === y;
        const x = Array.isArray(S);
        if (x !== Array.isArray(y))
            return !1;
        if (x) {
            if (S.length !== y.length)
                return !1;
            for (let O = 0; O < S.length; ++O)
                if (!R(S[O], y[O]))
                    return !1;
            return !0
        }
        const M = Object.keys(S)
          , U = Object.keys(y);
        if (M.length !== U.length)
            return !1;
        for (const O in S) {
            let Q = S[O]
              , D = y[O];
            if (O === "@container" && Array.isArray(Q) && Array.isArray(D) && (Q = Q.slice().sort(),
            D = D.slice().sort()),
            !R(Q, D))
                return !1
        }
        return !0
    }
    return Fa
}
var ja, Md;
function Im() {
    if (Md)
        return ja;
    Md = 1;
    const i = Qt()
      , {isArray: e, isObject: n, isEmptyObject: r, isString: o, isUndefined: a} = qt()
      , {isList: l, isValue: u, isGraph: f, isSubject: h} = kn()
      , {expandIri: m, getContextValue: _, isKeyword: d, process: g, processingMode: b} = _i()
      , {isAbsolute: T} = Gn()
      , {REGEX_BCP47: N, REGEX_KEYWORD: A, addValue: R, asArray: S, getValues: y, validateTypeValue: x} = Zt()
      , {handleEvent: M} = Gr()
      , U = {};
    ja = U,
    U.expand = async({activeCtx: F, activeProperty: B=null, element: ue, options: P={}, insideList: oe=!1, insideIndex: j=!1, typeScopedContext: ae=null})=>{
        if (ue == null)
            return null;
        if (B === "@default" && (P = Object.assign({}, P, {
            isFrame: !1
        })),
        !e(ue) && !n(ue))
            return !oe && (B === null || m(F, B, {
                vocab: !0
            }, P) === "@graph") ? (P.eventHandler && M({
                event: {
                    type: ["JsonLdEvent"],
                    code: "free-floating scalar",
                    level: "warning",
                    message: "Dropping free-floating scalar not in a list.",
                    details: {
                        value: ue
                    }
                },
                options: P
            }),
            null) : D({
                activeCtx: F,
                activeProperty: B,
                value: ue,
                options: P
            });
        if (e(ue)) {
            let Y = [];
            const K = _(F, B, "@container") || [];
            oe = oe || K.includes("@list");
            for (let le = 0; le < ue.length; ++le) {
                let ce = await U.expand({
                    activeCtx: F,
                    activeProperty: B,
                    element: ue[le],
                    options: P,
                    insideIndex: j,
                    typeScopedContext: ae
                });
                oe && e(ce) && (ce = {
                    "@list": ce
                }),
                ce !== null && (e(ce) ? Y = Y.concat(ce) : Y.push(ce))
            }
            return Y
        }
        const I = m(F, B, {
            vocab: !0
        }, P)
          , Z = _(F, B, "@context");
        ae = ae || (F.previousContext ? F : null);
        let ie = Object.keys(ue).sort()
          , ee = !j;
        if (ee && ae && ie.length <= 2 && !ie.includes("@context"))
            for (const Y of ie) {
                const K = m(ae, Y, {
                    vocab: !0
                }, P);
                if (K === "@value") {
                    ee = !1,
                    F = ae;
                    break
                }
                if (K === "@id" && ie.length === 1) {
                    ee = !1;
                    break
                }
            }
        ee && (F = F.revertToPreviousContext()),
        a(Z) || (F = await g({
            activeCtx: F,
            localCtx: Z,
            propagate: !0,
            overrideProtected: !0,
            options: P
        })),
        "@context"in ue && (F = await g({
            activeCtx: F,
            localCtx: ue["@context"],
            options: P
        })),
        ae = F;
        let me = null;
        for (const Y of ie)
            if (m(F, Y, {
                vocab: !0
            }, P) === "@type") {
                me = me || Y;
                const le = ue[Y]
                  , ce = Array.isArray(le) ? le.length > 1 ? le.slice().sort() : le : [le];
                for (const Ee of ce) {
                    const Te = _(ae, Ee, "@context");
                    a(Te) || (F = await g({
                        activeCtx: F,
                        localCtx: Te,
                        options: P,
                        propagate: !1
                    }))
                }
            }
        let W = {};
        await Q({
            activeCtx: F,
            activeProperty: B,
            expandedActiveProperty: I,
            element: ue,
            expandedParent: W,
            options: P,
            insideList: oe,
            typeKey: me,
            typeScopedContext: ae
        }),
        ie = Object.keys(W);
        let G = ie.length;
        if ("@value"in W) {
            if ("@type"in W && ("@language"in W || "@direction"in W))
                throw new i('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".',"jsonld.SyntaxError",{
                    code: "invalid value object",
                    element: W
                });
            let Y = G - 1;
            if ("@type"in W && (Y -= 1),
            "@index"in W && (Y -= 1),
            "@language"in W && (Y -= 1),
            "@direction"in W && (Y -= 1),
            Y !== 0)
                throw new i('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".',"jsonld.SyntaxError",{
                    code: "invalid value object",
                    element: W
                });
            const K = W["@value"] === null ? [] : S(W["@value"])
              , le = y(W, "@type");
            if (!(b(F, 1.1) && le.includes("@json") && le.length === 1))
                if (K.length === 0)
                    P.eventHandler && M({
                        event: {
                            type: ["JsonLdEvent"],
                            code: "null @value value",
                            level: "warning",
                            message: "Dropping null @value value.",
                            details: {
                                value: W
                            }
                        },
                        options: P
                    }),
                    W = null;
                else {
                    if (!K.every(ce=>o(ce) || r(ce)) && "@language"in W)
                        throw new i("Invalid JSON-LD syntax; only strings may be language-tagged.","jsonld.SyntaxError",{
                            code: "invalid language-tagged value",
                            element: W
                        });
                    if (!le.every(ce=>T(ce) && !(o(ce) && ce.indexOf("_:") === 0) || r(ce)))
                        throw new i('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".',"jsonld.SyntaxError",{
                            code: "invalid typed value",
                            element: W
                        })
                }
        } else if ("@type"in W && !e(W["@type"]))
            W["@type"] = [W["@type"]];
        else if ("@set"in W || "@list"in W) {
            if (G > 1 && !(G === 2 && "@index"in W))
                throw new i('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".',"jsonld.SyntaxError",{
                    code: "invalid set or list object",
                    element: W
                });
            "@set"in W && (W = W["@set"],
            ie = Object.keys(W),
            G = ie.length)
        } else
            G === 1 && "@language"in W && (P.eventHandler && M({
                event: {
                    type: ["JsonLdEvent"],
                    code: "object with only @language",
                    level: "warning",
                    message: "Dropping object with only @language.",
                    details: {
                        value: W
                    }
                },
                options: P
            }),
            W = null);
        return n(W) && !P.keepFreeFloatingNodes && !oe && (B === null || I === "@graph" || (_(F, B, "@container") || []).includes("@graph")) && (W = O({
            value: W,
            count: G,
            options: P
        })),
        W
    }
    ;
    function O({value: F, count: B, options: ue}) {
        if (B === 0 || "@value"in F || "@list"in F || B === 1 && "@id"in F) {
            if (ue.eventHandler) {
                let P, oe;
                B === 0 ? (P = "empty object",
                oe = "Dropping empty object.") : "@value"in F ? (P = "object with only @value",
                oe = "Dropping object with only @value.") : "@list"in F ? (P = "object with only @list",
                oe = "Dropping object with only @list.") : B === 1 && "@id"in F && (P = "object with only @id",
                oe = "Dropping object with only @id."),
                M({
                    event: {
                        type: ["JsonLdEvent"],
                        code: P,
                        level: "warning",
                        message: oe,
                        details: {
                            value: F
                        }
                    },
                    options: ue
                })
            }
            return null
        }
        return F
    }
    async function Q({activeCtx: F, activeProperty: B, expandedActiveProperty: ue, element: P, expandedParent: oe, options: j={}, insideList: ae, typeKey: I, typeScopedContext: Z}) {
        const ie = Object.keys(P).sort()
          , ee = [];
        let me;
        const W = P[I] && m(F, e(P[I]) ? P[I][0] : P[I], {
            vocab: !0
        }, {
            ...j,
            typeExpansion: !0
        }) === "@json";
        for (const G of ie) {
            let Y = P[G], K;
            if (G === "@context")
                continue;
            const le = m(F, G, {
                vocab: !0
            }, j);
            if (le === null || !(T(le) || d(le))) {
                j.eventHandler && M({
                    event: {
                        type: ["JsonLdEvent"],
                        code: "invalid property",
                        level: "warning",
                        message: "Dropping property that did not expand into an absolute IRI or keyword.",
                        details: {
                            property: G,
                            expandedProperty: le
                        }
                    },
                    options: j
                });
                continue
            }
            if (d(le)) {
                if (ue === "@reverse")
                    throw new i("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.","jsonld.SyntaxError",{
                        code: "invalid reverse property map",
                        value: Y
                    });
                if (le in oe && le !== "@included" && le !== "@type")
                    throw new i("Invalid JSON-LD syntax; colliding keywords detected.","jsonld.SyntaxError",{
                        code: "colliding keywords",
                        keyword: le
                    })
            }
            if (le === "@id") {
                if (!o(Y)) {
                    if (!j.isFrame)
                        throw new i('Invalid JSON-LD syntax; "@id" value must a string.',"jsonld.SyntaxError",{
                            code: "invalid @id value",
                            value: Y
                        });
                    if (n(Y)) {
                        if (!r(Y))
                            throw new i('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{
                                code: "invalid @id value",
                                value: Y
                            })
                    } else if (e(Y)) {
                        if (!Y.every(q=>o(q)))
                            throw new i('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{
                                code: "invalid @id value",
                                value: Y
                            })
                    } else
                        throw new i('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing',"jsonld.SyntaxError",{
                            code: "invalid @id value",
                            value: Y
                        })
                }
                R(oe, "@id", S(Y).map(q=>{
                    if (o(q)) {
                        const te = m(F, q, {
                            base: !0
                        }, j);
                        return j.eventHandler && (te === null ? M(q === null ? {
                            event: {
                                type: ["JsonLdEvent"],
                                code: "null @id value",
                                level: "warning",
                                message: "Null @id found.",
                                details: {
                                    id: q
                                }
                            },
                            options: j
                        } : {
                            event: {
                                type: ["JsonLdEvent"],
                                code: "reserved @id value",
                                level: "warning",
                                message: "Reserved @id found.",
                                details: {
                                    id: q
                                }
                            },
                            options: j
                        }) : T(te) || M({
                            event: {
                                type: ["JsonLdEvent"],
                                code: "relative @id reference",
                                level: "warning",
                                message: "Relative @id reference found.",
                                details: {
                                    id: q,
                                    expandedId: te
                                }
                            },
                            options: j
                        })),
                        te
                    }
                    return q
                }
                ), {
                    propertyIsArray: j.isFrame
                });
                continue
            }
            if (le === "@type") {
                n(Y) && (Y = Object.fromEntries(Object.entries(Y).map(([q,te])=>[m(Z, q, {
                    vocab: !0
                }), S(te).map(fe=>m(Z, fe, {
                    base: !0,
                    vocab: !0
                }, {
                    ...j,
                    typeExpansion: !0
                }))]))),
                x(Y, j.isFrame),
                R(oe, "@type", S(Y).map(q=>{
                    if (o(q)) {
                        const te = m(Z, q, {
                            base: !0,
                            vocab: !0
                        }, {
                            ...j,
                            typeExpansion: !0
                        });
                        return te !== "@json" && !T(te) && j.eventHandler && M({
                            event: {
                                type: ["JsonLdEvent"],
                                code: "relative @type reference",
                                level: "warning",
                                message: "Relative @type reference found.",
                                details: {
                                    type: q
                                }
                            },
                            options: j
                        }),
                        te
                    }
                    return q
                }
                ), {
                    propertyIsArray: !!j.isFrame
                });
                continue
            }
            if (le === "@included" && b(F, 1.1)) {
                const q = S(await U.expand({
                    activeCtx: F,
                    activeProperty: B,
                    element: Y,
                    options: j
                }));
                if (!q.every(te=>h(te)))
                    throw new i("Invalid JSON-LD syntax; values of @included must expand to node objects.","jsonld.SyntaxError",{
                        code: "invalid @included value",
                        value: Y
                    });
                R(oe, "@included", q, {
                    propertyIsArray: !0
                });
                continue
            }
            if (le === "@graph" && !(n(Y) || e(Y)))
                throw new i('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.',"jsonld.SyntaxError",{
                    code: "invalid @graph value",
                    value: Y
                });
            if (le === "@value") {
                me = Y,
                W && b(F, 1.1) ? oe["@value"] = Y : R(oe, "@value", Y, {
                    propertyIsArray: j.isFrame
                });
                continue
            }
            if (le === "@language") {
                if (Y === null)
                    continue;
                if (!o(Y) && !j.isFrame)
                    throw new i('Invalid JSON-LD syntax; "@language" value must be a string.',"jsonld.SyntaxError",{
                        code: "invalid language-tagged string",
                        value: Y
                    });
                Y = S(Y).map(q=>o(q) ? q.toLowerCase() : q);
                for (const q of Y)
                    o(q) && !q.match(N) && j.eventHandler && M({
                        event: {
                            type: ["JsonLdEvent"],
                            code: "invalid @language value",
                            level: "warning",
                            message: "@language value must be valid BCP47.",
                            details: {
                                language: q
                            }
                        },
                        options: j
                    });
                R(oe, "@language", Y, {
                    propertyIsArray: j.isFrame
                });
                continue
            }
            if (le === "@direction") {
                if (!o(Y) && !j.isFrame)
                    throw new i('Invalid JSON-LD syntax; "@direction" value must be a string.',"jsonld.SyntaxError",{
                        code: "invalid base direction",
                        value: Y
                    });
                Y = S(Y);
                for (const q of Y)
                    if (o(q) && q !== "ltr" && q !== "rtl")
                        throw new i('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".',"jsonld.SyntaxError",{
                            code: "invalid base direction",
                            value: Y
                        });
                R(oe, "@direction", Y, {
                    propertyIsArray: j.isFrame
                });
                continue
            }
            if (le === "@index") {
                if (!o(Y))
                    throw new i('Invalid JSON-LD syntax; "@index" value must be a string.',"jsonld.SyntaxError",{
                        code: "invalid @index value",
                        value: Y
                    });
                R(oe, "@index", Y);
                continue
            }
            if (le === "@reverse") {
                if (!n(Y))
                    throw new i('Invalid JSON-LD syntax; "@reverse" value must be an object.',"jsonld.SyntaxError",{
                        code: "invalid @reverse value",
                        value: Y
                    });
                if (K = await U.expand({
                    activeCtx: F,
                    activeProperty: "@reverse",
                    element: Y,
                    options: j
                }),
                "@reverse"in K)
                    for (const te in K["@reverse"])
                        R(oe, te, K["@reverse"][te], {
                            propertyIsArray: !0
                        });
                let q = oe["@reverse"] || null;
                for (const te in K) {
                    if (te === "@reverse")
                        continue;
                    q === null && (q = oe["@reverse"] = {}),
                    R(q, te, [], {
                        propertyIsArray: !0
                    });
                    const fe = K[te];
                    for (let xe = 0; xe < fe.length; ++xe) {
                        const Se = fe[xe];
                        if (u(Se) || l(Se))
                            throw new i('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{
                                code: "invalid reverse property value",
                                value: K
                            });
                        R(q, te, Se, {
                            propertyIsArray: !0
                        })
                    }
                }
                continue
            }
            if (le === "@nest") {
                ee.push(G);
                continue
            }
            let ce = F;
            const Ee = _(F, G, "@context");
            a(Ee) || (ce = await g({
                activeCtx: F,
                localCtx: Ee,
                propagate: !0,
                overrideProtected: !0,
                options: j
            }));
            const Te = _(F, G, "@container") || [];
            if (Te.includes("@language") && n(Y)) {
                const q = _(ce, G, "@direction");
                K = $(ce, Y, q, j)
            } else if (Te.includes("@index") && n(Y)) {
                const q = Te.includes("@graph")
                  , te = _(ce, G, "@index") || "@index"
                  , fe = te !== "@index" && m(F, te, {
                    vocab: !0
                }, j);
                K = await X({
                    activeCtx: ce,
                    options: j,
                    activeProperty: G,
                    value: Y,
                    asGraph: q,
                    indexKey: te,
                    propertyIndex: fe
                })
            } else if (Te.includes("@id") && n(Y)) {
                const q = Te.includes("@graph");
                K = await X({
                    activeCtx: ce,
                    options: j,
                    activeProperty: G,
                    value: Y,
                    asGraph: q,
                    indexKey: "@id"
                })
            } else if (Te.includes("@type") && n(Y))
                K = await X({
                    activeCtx: ce.revertToPreviousContext(),
                    options: j,
                    activeProperty: G,
                    value: Y,
                    asGraph: !1,
                    indexKey: "@type"
                });
            else {
                const q = le === "@list";
                if (q || le === "@set") {
                    let te = B;
                    q && ue === "@graph" && (te = null),
                    K = await U.expand({
                        activeCtx: ce,
                        activeProperty: te,
                        element: Y,
                        options: j,
                        insideList: q
                    })
                } else
                    _(F, G, "@type") === "@json" ? K = {
                        "@type": "@json",
                        "@value": Y
                    } : K = await U.expand({
                        activeCtx: ce,
                        activeProperty: G,
                        element: Y,
                        options: j,
                        insideList: !1
                    })
            }
            if (!(K === null && le !== "@value")) {
                if (le !== "@list" && !l(K) && Te.includes("@list") && (K = {
                    "@list": S(K)
                }),
                Te.includes("@graph") && !Te.some(q=>q === "@id" || q === "@index")) {
                    if (K = S(K),
                    j.isFrame || (K = K.filter(q=>{
                        const te = Object.keys(q).length;
                        return O({
                            value: q,
                            count: te,
                            options: j
                        }) !== null
                    }
                    )),
                    K.length === 0)
                        continue;
                    K = K.map(q=>({
                        "@graph": S(q)
                    }))
                }
                if (ce.mappings.has(G) && ce.mappings.get(G).reverse) {
                    const q = oe["@reverse"] = oe["@reverse"] || {};
                    K = S(K);
                    for (let te = 0; te < K.length; ++te) {
                        const fe = K[te];
                        if (u(fe) || l(fe))
                            throw new i('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.',"jsonld.SyntaxError",{
                                code: "invalid reverse property value",
                                value: K
                            });
                        R(q, le, fe, {
                            propertyIsArray: !0
                        })
                    }
                    continue
                }
                R(oe, le, K, {
                    propertyIsArray: !0
                })
            }
        }
        if ("@value"in oe && !(oe["@type"] === "@json" && b(F, 1.1))) {
            if ((n(me) || e(me)) && !j.isFrame)
                throw new i('Invalid JSON-LD syntax; "@value" value must not be an object or an array.',"jsonld.SyntaxError",{
                    code: "invalid value object value",
                    value: me
                })
        }
        for (const G of ee) {
            const Y = e(P[G]) ? P[G] : [P[G]];
            for (const K of Y) {
                if (!n(K) || Object.keys(K).some(le=>m(F, le, {
                    vocab: !0
                }, j) === "@value"))
                    throw new i("Invalid JSON-LD syntax; nested value must be a node object.","jsonld.SyntaxError",{
                        code: "invalid @nest value",
                        value: K
                    });
                await Q({
                    activeCtx: F,
                    activeProperty: B,
                    expandedActiveProperty: ue,
                    element: K,
                    expandedParent: oe,
                    options: j,
                    insideList: ae,
                    typeScopedContext: Z,
                    typeKey: I
                })
            }
        }
    }
    function D({activeCtx: F, activeProperty: B, value: ue, options: P}) {
        if (ue == null)
            return null;
        const oe = m(F, B, {
            vocab: !0
        }, P);
        if (oe === "@id")
            return m(F, ue, {
                base: !0
            }, P);
        if (oe === "@type")
            return m(F, ue, {
                vocab: !0,
                base: !0
            }, {
                ...P,
                typeExpansion: !0
            });
        const j = _(F, B, "@type");
        if ((j === "@id" || oe === "@graph") && o(ue)) {
            const I = m(F, ue, {
                base: !0
            }, P);
            return I === null && ue.match(A) && P.eventHandler && M({
                event: {
                    type: ["JsonLdEvent"],
                    code: "reserved @id value",
                    level: "warning",
                    message: "Reserved @id found.",
                    details: {
                        id: B
                    }
                },
                options: P
            }),
            {
                "@id": I
            }
        }
        if (j === "@vocab" && o(ue))
            return {
                "@id": m(F, ue, {
                    vocab: !0,
                    base: !0
                }, P)
            };
        if (d(oe))
            return ue;
        const ae = {};
        if (j && !["@id", "@vocab", "@none"].includes(j))
            ae["@type"] = j;
        else if (o(ue)) {
            const I = _(F, B, "@language");
            I !== null && (ae["@language"] = I);
            const Z = _(F, B, "@direction");
            Z !== null && (ae["@direction"] = Z)
        }
        return ["boolean", "number", "string"].includes(typeof ue) || (ue = ue.toString()),
        ae["@value"] = ue,
        ae
    }
    function $(F, B, ue, P) {
        const oe = []
          , j = Object.keys(B).sort();
        for (const ae of j) {
            const I = m(F, ae, {
                vocab: !0
            }, P);
            let Z = B[ae];
            e(Z) || (Z = [Z]);
            for (const ie of Z) {
                if (ie === null)
                    continue;
                if (!o(ie))
                    throw new i("Invalid JSON-LD syntax; language map values must be strings.","jsonld.SyntaxError",{
                        code: "invalid language map value",
                        languageMap: B
                    });
                const ee = {
                    "@value": ie
                };
                I !== "@none" && (ae.match(N) || P.eventHandler && M({
                    event: {
                        type: ["JsonLdEvent"],
                        code: "invalid @language value",
                        level: "warning",
                        message: "@language value must be valid BCP47.",
                        details: {
                            language: ae
                        }
                    },
                    options: P
                }),
                ee["@language"] = ae.toLowerCase()),
                ue && (ee["@direction"] = ue),
                oe.push(ee)
            }
        }
        return oe
    }
    async function X({activeCtx: F, options: B, activeProperty: ue, value: P, asGraph: oe, indexKey: j, propertyIndex: ae}) {
        const I = []
          , Z = Object.keys(P).sort()
          , ie = j === "@type";
        for (let ee of Z) {
            if (ie) {
                const G = _(F, ee, "@context");
                a(G) || (F = await g({
                    activeCtx: F,
                    localCtx: G,
                    propagate: !1,
                    options: B
                }))
            }
            let me = P[ee];
            e(me) || (me = [me]),
            me = await U.expand({
                activeCtx: F,
                activeProperty: ue,
                element: me,
                options: B,
                insideList: !1,
                insideIndex: !0
            });
            let W;
            ae ? ee === "@none" ? W = "@none" : W = D({
                activeCtx: F,
                activeProperty: j,
                value: ee,
                options: B
            }) : W = m(F, ee, {
                vocab: !0
            }, B),
            j === "@id" ? ee = m(F, ee, {
                base: !0
            }, B) : ie && (ee = W);
            for (let G of me) {
                if (oe && !f(G) && (G = {
                    "@graph": [G]
                }),
                j === "@type")
                    W === "@none" || (G["@type"] ? G["@type"] = [ee].concat(G["@type"]) : G["@type"] = [ee]);
                else {
                    if (u(G) && !["@language", "@type", "@index"].includes(j))
                        throw new i(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${j}".`,"jsonld.SyntaxError",{
                            code: "invalid value object",
                            value: G
                        });
                    ae ? W !== "@none" && R(G, ae, W, {
                        propertyIsArray: !0,
                        prependValue: !0
                    }) : W !== "@none" && !(j in G) && (G[j] = ee)
                }
                I.push(G)
            }
        }
        return I
    }
    return ja
}
var Ba, Dd;
function Qs() {
    if (Dd)
        return Ba;
    Dd = 1;
    const {isKeyword: i} = _i()
      , e = kn()
      , n = qt()
      , r = Zt()
      , o = Qt()
      , a = {};
    return Ba = a,
    a.createMergedNodeMap = (l,u)=>{
        u = u || {};
        const f = u.issuer || new r.IdentifierIssuer("_:b")
          , h = {
            "@default": {}
        };
        return a.createNodeMap(l, h, "@default", f),
        a.mergeNodeMaps(h)
    }
    ,
    a.createNodeMap = (l,u,f,h,m,_)=>{
        if (n.isArray(l)) {
            for (const T of l)
                a.createNodeMap(T, u, f, h, void 0, _);
            return
        }
        if (!n.isObject(l)) {
            _ && _.push(l);
            return
        }
        if (e.isValue(l)) {
            if ("@type"in l) {
                let T = l["@type"];
                T.indexOf("_:") === 0 && (l["@type"] = T = h.getId(T))
            }
            _ && _.push(l);
            return
        } else if (_ && e.isList(l)) {
            const T = [];
            a.createNodeMap(l["@list"], u, f, h, m, T),
            _.push({
                "@list": T
            });
            return
        }
        if ("@type"in l) {
            const T = l["@type"];
            for (const N of T)
                N.indexOf("_:") === 0 && h.getId(N)
        }
        n.isUndefined(m) && (m = e.isBlankNode(l) ? h.getId(l["@id"]) : l["@id"]),
        _ && _.push({
            "@id": m
        });
        const d = u[f]
          , g = d[m] = d[m] || {};
        g["@id"] = m;
        const b = Object.keys(l).sort();
        for (let T of b) {
            if (T === "@id")
                continue;
            if (T === "@reverse") {
                const A = {
                    "@id": m
                }
                  , R = l["@reverse"];
                for (const S in R) {
                    const y = R[S];
                    for (const x of y) {
                        let M = x["@id"];
                        e.isBlankNode(x) && (M = h.getId(M)),
                        a.createNodeMap(x, u, f, h, M),
                        r.addValue(d[M], S, A, {
                            propertyIsArray: !0,
                            allowDuplicate: !1
                        })
                    }
                }
                continue
            }
            if (T === "@graph") {
                m in u || (u[m] = {}),
                a.createNodeMap(l[T], u, m, h);
                continue
            }
            if (T === "@included") {
                a.createNodeMap(l[T], u, f, h);
                continue
            }
            if (T !== "@type" && i(T)) {
                if (T === "@index" && T in g && (l[T] !== g[T] || l[T]["@id"] !== g[T]["@id"]))
                    throw new o("Invalid JSON-LD syntax; conflicting @index property detected.","jsonld.SyntaxError",{
                        code: "conflicting indexes",
                        subject: g
                    });
                g[T] = l[T];
                continue
            }
            const N = l[T];
            if (T.indexOf("_:") === 0 && (T = h.getId(T)),
            N.length === 0) {
                r.addValue(g, T, [], {
                    propertyIsArray: !0
                });
                continue
            }
            for (let A of N)
                if (T === "@type" && (A = A.indexOf("_:") === 0 ? h.getId(A) : A),
                e.isSubject(A) || e.isSubjectReference(A)) {
                    if ("@id"in A && !A["@id"])
                        continue;
                    const R = e.isBlankNode(A) ? h.getId(A["@id"]) : A["@id"];
                    r.addValue(g, T, {
                        "@id": R
                    }, {
                        propertyIsArray: !0,
                        allowDuplicate: !1
                    }),
                    a.createNodeMap(A, u, f, h, R)
                } else if (e.isValue(A))
                    r.addValue(g, T, A, {
                        propertyIsArray: !0,
                        allowDuplicate: !1
                    });
                else if (e.isList(A)) {
                    const R = [];
                    a.createNodeMap(A["@list"], u, f, h, m, R),
                    A = {
                        "@list": R
                    },
                    r.addValue(g, T, A, {
                        propertyIsArray: !0,
                        allowDuplicate: !1
                    })
                } else
                    a.createNodeMap(A, u, f, h, m),
                    r.addValue(g, T, A, {
                        propertyIsArray: !0,
                        allowDuplicate: !1
                    })
        }
    }
    ,
    a.mergeNodeMapGraphs = l=>{
        const u = {};
        for (const f of Object.keys(l).sort())
            for (const h of Object.keys(l[f]).sort()) {
                const m = l[f][h];
                h in u || (u[h] = {
                    "@id": h
                });
                const _ = u[h];
                for (const d of Object.keys(m).sort())
                    if (i(d) && d !== "@type")
                        _[d] = r.clone(m[d]);
                    else
                        for (const g of m[d])
                            r.addValue(_, d, r.clone(g), {
                                propertyIsArray: !0,
                                allowDuplicate: !1
                            })
            }
        return u
    }
    ,
    a.mergeNodeMaps = l=>{
        const u = l["@default"]
          , f = Object.keys(l).sort();
        for (const h of f) {
            if (h === "@default")
                continue;
            const m = l[h];
            let _ = u[h];
            _ ? "@graph"in _ || (_["@graph"] = []) : u[h] = _ = {
                "@id": h,
                "@graph": []
            };
            const d = _["@graph"];
            for (const g of Object.keys(m).sort()) {
                const b = m[g];
                e.isSubjectReference(b) || d.push(b)
            }
        }
        return u
    }
    ,
    Ba
}
var $a, Od;
function Nm() {
    if (Od)
        return $a;
    Od = 1;
    const {isSubjectReference: i} = kn()
      , {createMergedNodeMap: e} = Qs()
      , n = {};
    return $a = n,
    n.flatten = r=>{
        const o = e(r)
          , a = []
          , l = Object.keys(o).sort();
        for (let u = 0; u < l.length; ++u) {
            const f = o[l[u]];
            i(f) || a.push(f)
        }
        return a
    }
    ,
    $a
}
var qa, Fd;
function Am() {
    if (Fd)
        return qa;
    Fd = 1;
    const i = Qt()
      , e = kn()
      , n = qt()
      , {REGEX_BCP47: r, addValue: o} = Zt()
      , {handleEvent: a} = Gr()
      , {RDF_LIST: l, RDF_FIRST: u, RDF_REST: f, RDF_NIL: h, RDF_TYPE: m, RDF_JSON_LITERAL: _, XSD_BOOLEAN: d, XSD_DOUBLE: g, XSD_INTEGER: b, XSD_STRING: T} = Vl()
      , N = {};
    qa = N,
    N.fromRDF = async(R,S)=>{
        const {useRdfType: y=!1, useNativeTypes: x=!1, rdfDirection: M=null} = S
          , U = {}
          , O = {
            "@default": U
        }
          , Q = {};
        if (M) {
            if (M === "compound-literal")
                throw new i("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{
                    value: M
                });
            if (M !== "i18n-datatype")
                throw new i("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{
                    value: M
                })
        }
        for (const X of R) {
            const F = X.graph.termType === "DefaultGraph" ? "@default" : X.graph.value;
            F in O || (O[F] = {}),
            F !== "@default" && !(F in U) && (U[F] = {
                "@id": F
            });
            const B = O[F]
              , ue = X.subject.value
              , P = X.predicate.value
              , oe = X.object;
            ue in B || (B[ue] = {
                "@id": ue
            });
            const j = B[ue]
              , ae = oe.termType.endsWith("Node");
            if (ae && !(oe.value in B) && (B[oe.value] = {
                "@id": oe.value
            }),
            P === m && !y && ae) {
                o(j, "@type", oe.value, {
                    propertyIsArray: !0
                });
                continue
            }
            const I = A(oe, x, M, S);
            if (o(j, P, I, {
                propertyIsArray: !0
            }),
            ae)
                if (oe.value === h) {
                    const Z = B[oe.value];
                    "usages"in Z || (Z.usages = []),
                    Z.usages.push({
                        node: j,
                        property: P,
                        value: I
                    })
                } else
                    oe.value in Q ? Q[oe.value] = !1 : Q[oe.value] = {
                        node: j,
                        property: P,
                        value: I
                    }
        }
        for (const X in O) {
            const F = O[X];
            if (!(h in F))
                continue;
            const B = F[h];
            if (B.usages) {
                for (let ue of B.usages) {
                    let P = ue.node
                      , oe = ue.property
                      , j = ue.value;
                    const ae = []
                      , I = [];
                    let Z = Object.keys(P).length;
                    for (; oe === f && n.isObject(Q[P["@id"]]) && n.isArray(P[u]) && P[u].length === 1 && n.isArray(P[f]) && P[f].length === 1 && (Z === 3 || Z === 4 && n.isArray(P["@type"]) && P["@type"].length === 1 && P["@type"][0] === l) && (ae.push(P[u][0]),
                    I.push(P["@id"]),
                    ue = Q[P["@id"]],
                    P = ue.node,
                    oe = ue.property,
                    j = ue.value,
                    Z = Object.keys(P).length,
                    !!e.isBlankNode(P)); )
                        ;
                    delete j["@id"],
                    j["@list"] = ae.reverse();
                    for (const ie of I)
                        delete F[ie]
                }
                delete B.usages
            }
        }
        const D = []
          , $ = Object.keys(U).sort();
        for (const X of $) {
            const F = U[X];
            if (X in O) {
                const B = F["@graph"] = []
                  , ue = O[X]
                  , P = Object.keys(ue).sort();
                for (const oe of P) {
                    const j = ue[oe];
                    e.isSubjectReference(j) || B.push(j)
                }
            }
            e.isSubjectReference(F) || D.push(F)
        }
        return D
    }
    ;
    function A(R, S, y, x) {
        if (R.termType.endsWith("Node"))
            return {
                "@id": R.value
            };
        const M = {
            "@value": R.value
        };
        if (R.language)
            R.language.match(r) || x.eventHandler && a({
                event: {
                    type: ["JsonLdEvent"],
                    code: "invalid @language value",
                    level: "warning",
                    message: "@language value must be valid BCP47.",
                    details: {
                        language: R.language
                    }
                },
                options: x
            }),
            M["@language"] = R.language;
        else {
            let U = R.datatype.value;
            if (U || (U = T),
            U === _) {
                U = "@json";
                try {
                    M["@value"] = JSON.parse(M["@value"])
                } catch (O) {
                    throw new i("JSON literal could not be parsed.","jsonld.InvalidJsonLiteral",{
                        code: "invalid JSON literal",
                        value: M["@value"],
                        cause: O
                    })
                }
            }
            if (S) {
                if (U === d)
                    M["@value"] === "true" ? M["@value"] = !0 : M["@value"] === "false" && (M["@value"] = !1);
                else if (n.isNumeric(M["@value"]))
                    if (U === b) {
                        const O = parseInt(M["@value"], 10);
                        O.toFixed(0) === M["@value"] && (M["@value"] = O)
                    } else
                        U === g && (M["@value"] = parseFloat(M["@value"]));
                [d, b, g, T].includes(U) || (M["@type"] = U)
            } else if (y === "i18n-datatype" && U.startsWith("https://www.w3.org/ns/i18n#")) {
                const [,O,Q] = U.split(/[#_]/);
                O.length > 0 && (M["@language"] = O,
                O.match(r) || x.eventHandler && a({
                    event: {
                        type: ["JsonLdEvent"],
                        code: "invalid @language value",
                        level: "warning",
                        message: "@language value must be valid BCP47.",
                        details: {
                            language: O
                        }
                    },
                    options: x
                })),
                M["@direction"] = Q
            } else
                U !== T && (M["@type"] = U)
        }
        return M
    }
    return qa
}
var za, jd;
function Rm() {
    return jd || (jd = 1,
    za = function i(e) {
        return e === null || typeof e != "object" || e.toJSON != null ? JSON.stringify(e) : Array.isArray(e) ? "[" + e.reduce((n,r,o)=>{
            const a = o === 0 ? "" : ","
              , l = r === void 0 || typeof r == "symbol" ? null : r;
            return n + a + i(l)
        }
        , "") + "]" : "{" + Object.keys(e).sort().reduce((n,r,o)=>{
            if (e[r] === void 0 || typeof e[r] == "symbol")
                return n;
            const a = n.length === 0 ? "" : ",";
            return n + a + i(r) + ":" + i(e[r])
        }
        , "") + "}"
    }
    ),
    za
}
var Ua, Bd;
function Cm() {
    if (Bd)
        return Ua;
    Bd = 1;
    const {createNodeMap: i} = Qs()
      , {isKeyword: e} = _i()
      , n = kn()
      , r = Rm()
      , o = Qt()
      , a = qt()
      , l = Zt()
      , {handleEvent: u} = Gr()
      , {RDF_FIRST: f, RDF_REST: h, RDF_NIL: m, RDF_TYPE: _, RDF_JSON_LITERAL: d, RDF_LANGSTRING: g, XSD_BOOLEAN: b, XSD_DOUBLE: T, XSD_INTEGER: N, XSD_STRING: A} = Vl()
      , {isAbsolute: R} = Gn()
      , S = {};
    Ua = S,
    S.toRDF = (U,O)=>{
        const Q = new l.IdentifierIssuer("_:b")
          , D = {
            "@default": {}
        };
        i(U, D, "@default", Q);
        const $ = []
          , X = Object.keys(D).sort();
        for (const F of X) {
            let B;
            if (F === "@default")
                B = {
                    termType: "DefaultGraph",
                    value: ""
                };
            else if (R(F))
                F.startsWith("_:") ? B = {
                    termType: "BlankNode"
                } : B = {
                    termType: "NamedNode"
                },
                B.value = F;
            else {
                O.eventHandler && u({
                    event: {
                        type: ["JsonLdEvent"],
                        code: "relative graph reference",
                        level: "warning",
                        message: "Relative graph reference found.",
                        details: {
                            graph: F
                        }
                    },
                    options: O
                });
                continue
            }
            y($, D[F], B, Q, O)
        }
        return $
    }
    ;
    function y(U, O, Q, D, $) {
        const X = Object.keys(O).sort();
        for (const F of X) {
            const B = O[F]
              , ue = Object.keys(B).sort();
            for (let P of ue) {
                const oe = B[P];
                if (P === "@type")
                    P = _;
                else if (e(P))
                    continue;
                for (const j of oe) {
                    const ae = {
                        termType: F.startsWith("_:") ? "BlankNode" : "NamedNode",
                        value: F
                    };
                    if (!R(F)) {
                        $.eventHandler && u({
                            event: {
                                type: ["JsonLdEvent"],
                                code: "relative subject reference",
                                level: "warning",
                                message: "Relative subject reference found.",
                                details: {
                                    subject: F
                                }
                            },
                            options: $
                        });
                        continue
                    }
                    const I = {
                        termType: P.startsWith("_:") ? "BlankNode" : "NamedNode",
                        value: P
                    };
                    if (!R(P)) {
                        $.eventHandler && u({
                            event: {
                                type: ["JsonLdEvent"],
                                code: "relative predicate reference",
                                level: "warning",
                                message: "Relative predicate reference found.",
                                details: {
                                    predicate: P
                                }
                            },
                            options: $
                        });
                        continue
                    }
                    if (I.termType === "BlankNode" && !$.produceGeneralizedRdf) {
                        $.eventHandler && u({
                            event: {
                                type: ["JsonLdEvent"],
                                code: "blank node predicate",
                                level: "warning",
                                message: "Dropping blank node predicate.",
                                details: {
                                    property: D.getOldIds().find(ie=>D.getId(ie) === P)
                                }
                            },
                            options: $
                        });
                        continue
                    }
                    const Z = M(j, D, U, Q, $.rdfDirection, $);
                    Z && U.push({
                        subject: ae,
                        predicate: I,
                        object: Z,
                        graph: Q
                    })
                }
            }
        }
    }
    function x(U, O, Q, D, $, X) {
        const F = {
            termType: "NamedNode",
            value: f
        }
          , B = {
            termType: "NamedNode",
            value: h
        }
          , ue = {
            termType: "NamedNode",
            value: m
        }
          , P = U.pop()
          , oe = P ? {
            termType: "BlankNode",
            value: O.getId()
        } : ue;
        let j = oe;
        for (const ae of U) {
            const I = M(ae, O, Q, D, $, X)
              , Z = {
                termType: "BlankNode",
                value: O.getId()
            };
            Q.push({
                subject: j,
                predicate: F,
                object: I,
                graph: D
            }),
            Q.push({
                subject: j,
                predicate: B,
                object: Z,
                graph: D
            }),
            j = Z
        }
        if (P) {
            const ae = M(P, O, Q, D, $, X);
            Q.push({
                subject: j,
                predicate: F,
                object: ae,
                graph: D
            }),
            Q.push({
                subject: j,
                predicate: B,
                object: ue,
                graph: D
            })
        }
        return oe
    }
    function M(U, O, Q, D, $, X) {
        const F = {};
        if (n.isValue(U)) {
            F.termType = "Literal",
            F.value = void 0,
            F.datatype = {
                termType: "NamedNode"
            };
            let B = U["@value"];
            const ue = U["@type"] || null;
            if (ue === "@json")
                F.value = r(B),
                F.datatype.value = d;
            else if (a.isBoolean(B))
                F.value = B.toString(),
                F.datatype.value = ue || b;
            else if (a.isDouble(B) || ue === T)
                a.isDouble(B) || (B = parseFloat(B)),
                F.value = B.toExponential(15).replace(/(\d)0*e\+?/, "$1E"),
                F.datatype.value = ue || T;
            else if (a.isNumber(B))
                F.value = B.toFixed(0),
                F.datatype.value = ue || N;
            else if ("@direction"in U && $ === "i18n-datatype") {
                const P = (U["@language"] || "").toLowerCase()
                  , oe = U["@direction"]
                  , j = `https://www.w3.org/ns/i18n#${P}_ ${oe}`;
                F.datatype.value = j,
                F.value = B
            } else {
                if ("@direction"in U && $ === "compound-literal")
                    throw new o("Unsupported rdfDirection value.","jsonld.InvalidRdfDirection",{
                        value: $
                    });
                if ("@direction"in U && $)
                    throw new o("Unknown rdfDirection value.","jsonld.InvalidRdfDirection",{
                        value: $
                    });
                "@language"in U ? ("@direction"in U && !$ && X.eventHandler && u({
                    event: {
                        type: ["JsonLdEvent"],
                        code: "rdfDirection not set",
                        level: "warning",
                        message: "rdfDirection not set for @direction.",
                        details: {
                            object: F.value
                        }
                    },
                    options: X
                }),
                F.value = B,
                F.datatype.value = ue || g,
                F.language = U["@language"]) : ("@direction"in U && !$ && X.eventHandler && u({
                    event: {
                        type: ["JsonLdEvent"],
                        code: "rdfDirection not set",
                        level: "warning",
                        message: "rdfDirection not set for @direction.",
                        details: {
                            object: F.value
                        }
                    },
                    options: X
                }),
                F.value = B,
                F.datatype.value = ue || A)
            }
        } else if (n.isList(U)) {
            const B = x(U["@list"], O, Q, D, $, X);
            F.termType = B.termType,
            F.value = B.value
        } else {
            const B = a.isObject(U) ? U["@id"] : U;
            F.termType = B.startsWith("_:") ? "BlankNode" : "NamedNode",
            F.value = B
        }
        return F.termType === "NamedNode" && !R(F.value) ? (X.eventHandler && u({
            event: {
                type: ["JsonLdEvent"],
                code: "relative object reference",
                level: "warning",
                message: "Relative object reference found.",
                details: {
                    object: F.value
                }
            },
            options: X
        }),
        null) : F
    }
    return Ua
}
var Ha, $d;
function km() {
    if ($d)
        return Ha;
    $d = 1;
    const {isKeyword: i} = _i()
      , e = kn()
      , n = qt()
      , r = Zt()
      , o = Gn()
      , a = Qt()
      , {createNodeMap: l, mergeNodeMapGraphs: u} = Qs()
      , f = {};
    Ha = f,
    f.frameMergedOrDefault = (y,x,M)=>{
        const U = {
            options: M,
            embedded: !1,
            graph: "@default",
            graphMap: {
                "@default": {}
            },
            subjectStack: [],
            link: {},
            bnodeMap: {}
        }
          , O = new r.IdentifierIssuer("_:b");
        l(y, U.graphMap, "@default", O),
        M.merged && (U.graphMap["@merged"] = u(U.graphMap),
        U.graph = "@merged"),
        U.subjects = U.graphMap[U.graph];
        const Q = [];
        f.frame(U, Object.keys(U.subjects).sort(), x, Q),
        M.pruneBlankNodeIdentifiers && (M.bnodesToClear = Object.keys(U.bnodeMap).filter(D=>U.bnodeMap[D].length === 1));
        return M.link = {},
        N(Q, M)
    }
    ,
    f.frame = (y,x,M,U,O=null)=>{
        d(M),
        M = M[0];
        const Q = y.options
          , D = {
            embed: _(M, Q, "embed"),
            explicit: _(M, Q, "explicit"),
            requireAll: _(M, Q, "requireAll")
        };
        y.link.hasOwnProperty(y.graph) || (y.link[y.graph] = {});
        const $ = y.link[y.graph]
          , X = g(y, x, M, D)
          , F = Object.keys(X).sort();
        for (const B of F) {
            const ue = X[B];
            if (O === null ? y.uniqueEmbeds = {
                [y.graph]: {}
            } : y.uniqueEmbeds[y.graph] = y.uniqueEmbeds[y.graph] || {},
            D.embed === "@link" && B in $) {
                A(U, O, $[B]);
                continue
            }
            const P = {
                "@id": B
            };
            if (B.indexOf("_:") === 0 && r.addValue(y.bnodeMap, B, P, {
                propertyIsArray: !0
            }),
            $[B] = P,
            (D.embed === "@first" || D.embed === "@last") && y.is11)
                throw new a("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{
                    code: "invalid @embed value",
                    frame: M
                });
            if (!(!y.embedded && y.uniqueEmbeds[y.graph].hasOwnProperty(B))) {
                if (y.embedded && (D.embed === "@never" || m(ue, y.graph, y.subjectStack))) {
                    A(U, O, P);
                    continue
                }
                if (y.embedded && (D.embed == "@first" || D.embed == "@once") && y.uniqueEmbeds[y.graph].hasOwnProperty(B)) {
                    A(U, O, P);
                    continue
                }
                if (D.embed === "@last" && B in y.uniqueEmbeds[y.graph] && T(y, B),
                y.uniqueEmbeds[y.graph][B] = {
                    parent: U,
                    property: O
                },
                y.subjectStack.push({
                    subject: ue,
                    graph: y.graph
                }),
                B in y.graphMap) {
                    let oe = !1
                      , j = null;
                    "@graph"in M ? (j = M["@graph"][0],
                    oe = !(B === "@merged" || B === "@default"),
                    n.isObject(j) || (j = {})) : (oe = y.graph !== "@merged",
                    j = {}),
                    oe && f.frame({
                        ...y,
                        graph: B,
                        embedded: !1
                    }, Object.keys(y.graphMap[B]).sort(), [j], P, "@graph")
                }
                "@included"in M && f.frame({
                    ...y,
                    embedded: !1
                }, x, M["@included"], P, "@included");
                for (const oe of Object.keys(ue).sort()) {
                    if (i(oe)) {
                        if (P[oe] = r.clone(ue[oe]),
                        oe === "@type")
                            for (const j of ue["@type"])
                                j.indexOf("_:") === 0 && r.addValue(y.bnodeMap, j, P, {
                                    propertyIsArray: !0
                                });
                        continue
                    }
                    if (!(D.explicit && !(oe in M)))
                        for (const j of ue[oe]) {
                            const ae = oe in M ? M[oe] : h(D);
                            if (e.isList(j)) {
                                const I = M[oe] && M[oe][0] && M[oe][0]["@list"] ? M[oe][0]["@list"] : h(D)
                                  , Z = {
                                    "@list": []
                                };
                                A(P, oe, Z);
                                const ie = j["@list"];
                                for (const ee of ie)
                                    e.isSubjectReference(ee) ? f.frame({
                                        ...y,
                                        embedded: !0
                                    }, [ee["@id"]], I, Z, "@list") : A(Z, "@list", r.clone(ee))
                            } else
                                e.isSubjectReference(j) ? f.frame({
                                    ...y,
                                    embedded: !0
                                }, [j["@id"]], ae, P, oe) : S(ae[0], j) && A(P, oe, r.clone(j))
                        }
                }
                for (const oe of Object.keys(M).sort()) {
                    if (oe === "@type") {
                        if (!n.isObject(M[oe][0]) || !("@default"in M[oe][0]))
                            continue
                    } else if (i(oe))
                        continue;
                    const j = M[oe][0] || {};
                    if (!_(j, Q, "omitDefault") && !(oe in P)) {
                        let I = "@null";
                        "@default"in j && (I = r.clone(j["@default"])),
                        n.isArray(I) || (I = [I]),
                        P[oe] = [{
                            "@preserve": I
                        }]
                    }
                }
                for (const oe of Object.keys(M["@reverse"] || {}).sort()) {
                    const j = M["@reverse"][oe];
                    for (const ae of Object.keys(y.subjects))
                        r.getValues(y.subjects[ae], oe).some(Z=>Z["@id"] === B) && (P["@reverse"] = P["@reverse"] || {},
                        r.addValue(P["@reverse"], oe, [], {
                            propertyIsArray: !0
                        }),
                        f.frame({
                            ...y,
                            embedded: !0
                        }, [ae], j, P["@reverse"][oe], O))
                }
                A(U, O, P),
                y.subjectStack.pop()
            }
        }
    }
    ,
    f.cleanupNull = (y,x)=>{
        if (n.isArray(y))
            return y.map(U=>f.cleanupNull(U, x)).filter(U=>U);
        if (y === "@null")
            return null;
        if (n.isObject(y)) {
            if ("@id"in y) {
                const M = y["@id"];
                if (x.link.hasOwnProperty(M)) {
                    const U = x.link[M].indexOf(y);
                    if (U !== -1)
                        return x.link[M][U];
                    x.link[M].push(y)
                } else
                    x.link[M] = [y]
            }
            for (const M in y)
                y[M] = f.cleanupNull(y[M], x)
        }
        return y
    }
    ;
    function h(y) {
        const x = {};
        for (const M in y)
            y[M] !== void 0 && (x["@" + M] = [y[M]]);
        return [x]
    }
    function m(y, x, M) {
        for (let U = M.length - 1; U >= 0; --U) {
            const O = M[U];
            if (O.graph === x && O.subject["@id"] === y["@id"])
                return !0
        }
        return !1
    }
    function _(y, x, M) {
        const U = "@" + M;
        let O = U in y ? y[U][0] : x[M];
        if (M === "embed") {
            if (O === !0)
                O = "@once";
            else if (O === !1)
                O = "@never";
            else if (O !== "@always" && O !== "@never" && O !== "@link" && O !== "@first" && O !== "@last" && O !== "@once")
                throw new a("Invalid JSON-LD syntax; invalid value of @embed.","jsonld.SyntaxError",{
                    code: "invalid @embed value",
                    frame: y
                })
        }
        return O
    }
    function d(y) {
        if (!n.isArray(y) || y.length !== 1 || !n.isObject(y[0]))
            throw new a("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.","jsonld.SyntaxError",{
                frame: y
            });
        if ("@id"in y[0]) {
            for (const x of r.asArray(y[0]["@id"]))
                if (!(n.isObject(x) || o.isAbsolute(x)) || n.isString(x) && x.indexOf("_:") === 0)
                    throw new a("Invalid JSON-LD syntax; invalid @id in frame.","jsonld.SyntaxError",{
                        code: "invalid frame",
                        frame: y
                    })
        }
        if ("@type"in y[0]) {
            for (const x of r.asArray(y[0]["@type"]))
                if (!(n.isObject(x) || o.isAbsolute(x) || x === "@json") || n.isString(x) && x.indexOf("_:") === 0)
                    throw new a("Invalid JSON-LD syntax; invalid @type in frame.","jsonld.SyntaxError",{
                        code: "invalid frame",
                        frame: y
                    })
        }
    }
    function g(y, x, M, U) {
        const O = {};
        for (const Q of x) {
            const D = y.graphMap[y.graph][Q];
            b(y, D, M, U) && (O[Q] = D)
        }
        return O
    }
    function b(y, x, M, U) {
        let O = !0
          , Q = !1;
        for (const D in M) {
            let $ = !1;
            const X = r.getValues(x, D)
              , F = r.getValues(M, D).length === 0;
            if (D === "@id") {
                if (n.isEmptyObject(M["@id"][0] || {}) ? $ = !0 : M["@id"].length >= 0 && ($ = M["@id"].includes(X[0])),
                !U.requireAll)
                    return $
            } else if (D === "@type") {
                if (O = !1,
                F) {
                    if (X.length > 0)
                        return !1;
                    $ = !0
                } else if (M["@type"].length === 1 && n.isEmptyObject(M["@type"][0]))
                    $ = X.length > 0;
                else
                    for (const B of M["@type"])
                        n.isObject(B) && "@default"in B ? $ = !0 : $ = $ || X.some(ue=>ue === B);
                if (!U.requireAll)
                    return $
            } else {
                if (i(D))
                    continue;
                {
                    const B = r.getValues(M, D)[0];
                    let ue = !1;
                    if (B && (d([B]),
                    ue = "@default"in B),
                    O = !1,
                    X.length === 0 && ue)
                        continue;
                    if (X.length > 0 && F)
                        return !1;
                    if (B === void 0) {
                        if (X.length > 0)
                            return !1;
                        $ = !0
                    } else if (e.isList(B)) {
                        const P = B["@list"][0];
                        if (e.isList(X[0])) {
                            const oe = X[0]["@list"];
                            e.isValue(P) ? $ = oe.some(j=>S(P, j)) : (e.isSubject(P) || e.isSubjectReference(P)) && ($ = oe.some(j=>R(y, P, j, U)))
                        }
                    } else
                        e.isValue(B) ? $ = X.some(P=>S(B, P)) : e.isSubjectReference(B) ? $ = X.some(P=>R(y, B, P, U)) : n.isObject(B) ? $ = X.length > 0 : $ = !1
                }
            }
            if (!$ && U.requireAll)
                return !1;
            Q = Q || $
        }
        return O || Q
    }
    function T(y, x) {
        const M = y.uniqueEmbeds[y.graph]
          , U = M[x]
          , O = U.parent
          , Q = U.property
          , D = {
            "@id": x
        };
        if (n.isArray(O)) {
            for (let X = 0; X < O.length; ++X)
                if (r.compareValues(O[X], D)) {
                    O[X] = D;
                    break
                }
        } else {
            const X = n.isArray(O[Q]);
            r.removeValue(O, Q, D, {
                propertyIsArray: X
            }),
            r.addValue(O, Q, D, {
                propertyIsArray: X
            })
        }
        const $ = X=>{
            const F = Object.keys(M);
            for (const B of F)
                B in M && n.isObject(M[B].parent) && M[B].parent["@id"] === X && (delete M[B],
                $(B))
        }
        ;
        $(x)
    }
    function N(y, x) {
        if (n.isArray(y))
            return y.map(M=>N(M, x));
        if (n.isObject(y)) {
            if ("@preserve"in y)
                return y["@preserve"][0];
            if (e.isValue(y))
                return y;
            if (e.isList(y))
                return y["@list"] = N(y["@list"], x),
                y;
            if ("@id"in y) {
                const M = y["@id"];
                if (x.link.hasOwnProperty(M)) {
                    const U = x.link[M].indexOf(y);
                    if (U !== -1)
                        return x.link[M][U];
                    x.link[M].push(y)
                } else
                    x.link[M] = [y]
            }
            for (const M in y) {
                if (M === "@id" && x.bnodesToClear.includes(y[M])) {
                    delete y["@id"];
                    continue
                }
                y[M] = N(y[M], x)
            }
        }
        return y
    }
    function A(y, x, M) {
        n.isObject(y) ? r.addValue(y, x, M, {
            propertyIsArray: !0
        }) : y.push(M)
    }
    function R(y, x, M, U) {
        if (!("@id"in M))
            return !1;
        const O = y.subjects[M["@id"]];
        return O && b(y, O, x, U)
    }
    function S(y, x) {
        const M = x["@value"]
          , U = x["@type"]
          , O = x["@language"]
          , Q = y["@value"] ? n.isArray(y["@value"]) ? y["@value"] : [y["@value"]] : []
          , D = y["@type"] ? n.isArray(y["@type"]) ? y["@type"] : [y["@type"]] : []
          , $ = y["@language"] ? n.isArray(y["@language"]) ? y["@language"] : [y["@language"]] : [];
        return Q.length === 0 && D.length === 0 && $.length === 0 ? !0 : !(!(Q.includes(M) || n.isEmptyObject(Q[0])) || !(!U && D.length === 0 || D.includes(U) || U && n.isEmptyObject(D[0])) || !(!O && $.length === 0 || $.includes(O) || O && n.isEmptyObject($[0])))
    }
    return Ha
}
var Va, qd;
function Pm() {
    if (qd)
        return Va;
    qd = 1;
    const i = Qt()
      , {isArray: e, isObject: n, isString: r, isUndefined: o} = qt()
      , {isList: a, isValue: l, isGraph: u, isSimpleGraph: f, isSubjectReference: h} = kn()
      , {expandIri: m, getContextValue: _, isKeyword: d, process: g, processingMode: b} = _i()
      , {removeBase: T, prependBase: N} = Gn()
      , {REGEX_KEYWORD: A, addValue: R, asArray: S, compareShortestLeast: y} = Zt()
      , x = {};
    Va = x,
    x.compact = async({activeCtx: O, activeProperty: Q=null, element: D, options: $={}})=>{
        if (e(D)) {
            let F = [];
            for (let B = 0; B < D.length; ++B) {
                const ue = await x.compact({
                    activeCtx: O,
                    activeProperty: Q,
                    element: D[B],
                    options: $
                });
                ue !== null && F.push(ue)
            }
            return $.compactArrays && F.length === 1 && (_(O, Q, "@container") || []).length === 0 && (F = F[0]),
            F
        }
        const X = _(O, Q, "@context");
        if (o(X) || (O = await g({
            activeCtx: O,
            localCtx: X,
            propagate: !0,
            overrideProtected: !0,
            options: $
        })),
        n(D)) {
            if ($.link && "@id"in D && $.link.hasOwnProperty(D["@id"])) {
                const I = $.link[D["@id"]];
                for (let Z = 0; Z < I.length; ++Z)
                    if (I[Z].expanded === D)
                        return I[Z].compacted
            }
            if (l(D) || h(D)) {
                const I = x.compactValue({
                    activeCtx: O,
                    activeProperty: Q,
                    value: D,
                    options: $
                });
                return $.link && h(D) && ($.link.hasOwnProperty(D["@id"]) || ($.link[D["@id"]] = []),
                $.link[D["@id"]].push({
                    expanded: D,
                    compacted: I
                })),
                I
            }
            if (a(D) && (_(O, Q, "@container") || []).includes("@list"))
                return x.compact({
                    activeCtx: O,
                    activeProperty: Q,
                    element: D["@list"],
                    options: $
                });
            const F = Q === "@reverse"
              , B = {}
              , ue = O;
            !l(D) && !h(D) && (O = O.revertToPreviousContext());
            const P = _(ue, Q, "@context");
            o(P) || (O = await g({
                activeCtx: O,
                localCtx: P,
                propagate: !0,
                overrideProtected: !0,
                options: $
            })),
            $.link && "@id"in D && ($.link.hasOwnProperty(D["@id"]) || ($.link[D["@id"]] = []),
            $.link[D["@id"]].push({
                expanded: D,
                compacted: B
            }));
            let oe = D["@type"] || [];
            oe.length > 1 && (oe = Array.from(oe).sort());
            const j = O;
            for (const I of oe) {
                const Z = x.compactIri({
                    activeCtx: j,
                    iri: I,
                    relativeTo: {
                        vocab: !0
                    }
                })
                  , ie = _(ue, Z, "@context");
                o(ie) || (O = await g({
                    activeCtx: O,
                    localCtx: ie,
                    options: $,
                    propagate: !1
                }))
            }
            const ae = Object.keys(D).sort();
            for (const I of ae) {
                const Z = D[I];
                if (I === "@id") {
                    let ie = S(Z).map(me=>x.compactIri({
                        activeCtx: O,
                        iri: me,
                        relativeTo: {
                            vocab: !1
                        },
                        base: $.base
                    }));
                    ie.length === 1 && (ie = ie[0]);
                    const ee = x.compactIri({
                        activeCtx: O,
                        iri: "@id",
                        relativeTo: {
                            vocab: !0
                        }
                    });
                    B[ee] = ie;
                    continue
                }
                if (I === "@type") {
                    let ie = S(Z).map(Y=>x.compactIri({
                        activeCtx: ue,
                        iri: Y,
                        relativeTo: {
                            vocab: !0
                        }
                    }));
                    ie.length === 1 && (ie = ie[0]);
                    const ee = x.compactIri({
                        activeCtx: O,
                        iri: "@type",
                        relativeTo: {
                            vocab: !0
                        }
                    })
                      , G = (_(O, ee, "@container") || []).includes("@set") && b(O, 1.1) || e(ie) && Z.length === 0;
                    R(B, ee, ie, {
                        propertyIsArray: G
                    });
                    continue
                }
                if (I === "@reverse") {
                    const ie = await x.compact({
                        activeCtx: O,
                        activeProperty: "@reverse",
                        element: Z,
                        options: $
                    });
                    for (const ee in ie)
                        if (O.mappings.has(ee) && O.mappings.get(ee).reverse) {
                            const me = ie[ee]
                              , G = (_(O, ee, "@container") || []).includes("@set") || !$.compactArrays;
                            R(B, ee, me, {
                                propertyIsArray: G
                            }),
                            delete ie[ee]
                        }
                    if (Object.keys(ie).length > 0) {
                        const ee = x.compactIri({
                            activeCtx: O,
                            iri: I,
                            relativeTo: {
                                vocab: !0
                            }
                        });
                        R(B, ee, ie)
                    }
                    continue
                }
                if (I === "@preserve") {
                    const ie = await x.compact({
                        activeCtx: O,
                        activeProperty: Q,
                        element: Z,
                        options: $
                    });
                    e(ie) && ie.length === 0 || R(B, I, ie);
                    continue
                }
                if (I === "@index") {
                    if ((_(O, Q, "@container") || []).includes("@index"))
                        continue;
                    const ee = x.compactIri({
                        activeCtx: O,
                        iri: I,
                        relativeTo: {
                            vocab: !0
                        }
                    });
                    R(B, ee, Z);
                    continue
                }
                if (I !== "@graph" && I !== "@list" && I !== "@included" && d(I)) {
                    const ie = x.compactIri({
                        activeCtx: O,
                        iri: I,
                        relativeTo: {
                            vocab: !0
                        }
                    });
                    R(B, ie, Z);
                    continue
                }
                if (!e(Z))
                    throw new i("JSON-LD expansion error; expanded value must be an array.","jsonld.SyntaxError");
                if (Z.length === 0) {
                    const ie = x.compactIri({
                        activeCtx: O,
                        iri: I,
                        value: Z,
                        relativeTo: {
                            vocab: !0
                        },
                        reverse: F
                    })
                      , ee = O.mappings.has(ie) ? O.mappings.get(ie)["@nest"] : null;
                    let me = B;
                    ee && (U(O, ee, $),
                    n(B[ee]) || (B[ee] = {}),
                    me = B[ee]),
                    R(me, ie, Z, {
                        propertyIsArray: !0
                    })
                }
                for (const ie of Z) {
                    const ee = x.compactIri({
                        activeCtx: O,
                        iri: I,
                        value: ie,
                        relativeTo: {
                            vocab: !0
                        },
                        reverse: F
                    })
                      , me = O.mappings.has(ee) ? O.mappings.get(ee)["@nest"] : null;
                    let W = B;
                    me && (U(O, me, $),
                    n(B[me]) || (B[me] = {}),
                    W = B[me]);
                    const G = _(O, ee, "@container") || []
                      , Y = u(ie)
                      , K = a(ie);
                    let le;
                    K ? le = ie["@list"] : Y && (le = ie["@graph"]);
                    let ce = await x.compact({
                        activeCtx: O,
                        activeProperty: ee,
                        element: K || Y ? le : ie,
                        options: $
                    });
                    if (K)
                        if (e(ce) || (ce = [ce]),
                        !G.includes("@list"))
                            ce = {
                                [x.compactIri({
                                    activeCtx: O,
                                    iri: "@list",
                                    relativeTo: {
                                        vocab: !0
                                    }
                                })]: ce
                            },
                            "@index"in ie && (ce[x.compactIri({
                                activeCtx: O,
                                iri: "@index",
                                relativeTo: {
                                    vocab: !0
                                }
                            })] = ie["@index"]);
                        else {
                            R(W, ee, ce, {
                                valueIsArray: !0,
                                allowDuplicate: !0
                            });
                            continue
                        }
                    if (Y)
                        if (G.includes("@graph") && (G.includes("@id") || G.includes("@index") && f(ie))) {
                            let Ee;
                            W.hasOwnProperty(ee) ? Ee = W[ee] : W[ee] = Ee = {};
                            const Te = (G.includes("@id") ? ie["@id"] : ie["@index"]) || x.compactIri({
                                activeCtx: O,
                                iri: "@none",
                                relativeTo: {
                                    vocab: !0
                                }
                            });
                            R(Ee, Te, ce, {
                                propertyIsArray: !$.compactArrays || G.includes("@set")
                            })
                        } else
                            G.includes("@graph") && f(ie) ? (e(ce) && ce.length > 1 && (ce = {
                                "@included": ce
                            }),
                            R(W, ee, ce, {
                                propertyIsArray: !$.compactArrays || G.includes("@set")
                            })) : (e(ce) && ce.length === 1 && $.compactArrays && (ce = ce[0]),
                            ce = {
                                [x.compactIri({
                                    activeCtx: O,
                                    iri: "@graph",
                                    relativeTo: {
                                        vocab: !0
                                    }
                                })]: ce
                            },
                            "@id"in ie && (ce[x.compactIri({
                                activeCtx: O,
                                iri: "@id",
                                relativeTo: {
                                    vocab: !0
                                }
                            })] = ie["@id"]),
                            "@index"in ie && (ce[x.compactIri({
                                activeCtx: O,
                                iri: "@index",
                                relativeTo: {
                                    vocab: !0
                                }
                            })] = ie["@index"]),
                            R(W, ee, ce, {
                                propertyIsArray: !$.compactArrays || G.includes("@set")
                            }));
                    else if (G.includes("@language") || G.includes("@index") || G.includes("@id") || G.includes("@type")) {
                        let Ee;
                        W.hasOwnProperty(ee) ? Ee = W[ee] : W[ee] = Ee = {};
                        let Te;
                        if (G.includes("@language"))
                            l(ce) && (ce = ce["@value"]),
                            Te = ie["@language"];
                        else if (G.includes("@index")) {
                            const q = _(O, ee, "@index") || "@index"
                              , te = x.compactIri({
                                activeCtx: O,
                                iri: q,
                                relativeTo: {
                                    vocab: !0
                                }
                            });
                            if (q === "@index")
                                Te = ie["@index"],
                                delete ce[te];
                            else {
                                let fe;
                                if ([Te,...fe] = S(ce[q] || []),
                                !r(Te))
                                    Te = null;
                                else
                                    switch (fe.length) {
                                    case 0:
                                        delete ce[q];
                                        break;
                                    case 1:
                                        ce[q] = fe[0];
                                        break;
                                    default:
                                        ce[q] = fe;
                                        break
                                    }
                            }
                        } else if (G.includes("@id")) {
                            const q = x.compactIri({
                                activeCtx: O,
                                iri: "@id",
                                relativeTo: {
                                    vocab: !0
                                }
                            });
                            Te = ce[q],
                            delete ce[q]
                        } else if (G.includes("@type")) {
                            const q = x.compactIri({
                                activeCtx: O,
                                iri: "@type",
                                relativeTo: {
                                    vocab: !0
                                }
                            });
                            let te;
                            switch ([Te,...te] = S(ce[q] || []),
                            te.length) {
                            case 0:
                                delete ce[q];
                                break;
                            case 1:
                                ce[q] = te[0];
                                break;
                            default:
                                ce[q] = te;
                                break
                            }
                            Object.keys(ce).length === 1 && "@id"in ie && (ce = await x.compact({
                                activeCtx: O,
                                activeProperty: ee,
                                element: {
                                    "@id": ie["@id"]
                                },
                                options: $
                            }))
                        }
                        Te || (Te = x.compactIri({
                            activeCtx: O,
                            iri: "@none",
                            relativeTo: {
                                vocab: !0
                            }
                        })),
                        R(Ee, Te, ce, {
                            propertyIsArray: G.includes("@set")
                        })
                    } else {
                        const Ee = !$.compactArrays || G.includes("@set") || G.includes("@list") || e(ce) && ce.length === 0 || I === "@list" || I === "@graph";
                        R(W, ee, ce, {
                            propertyIsArray: Ee
                        })
                    }
                }
            }
            return B
        }
        return D
    }
    ,
    x.compactIri = ({activeCtx: O, iri: Q, value: D=null, relativeTo: $={
        vocab: !1
    }, reverse: X=!1, base: F=null})=>{
        if (Q === null)
            return Q;
        O.isPropertyTermScoped && O.previousContext && (O = O.previousContext);
        const B = O.getInverse();
        if (d(Q) && Q in B && "@none"in B[Q] && "@type"in B[Q]["@none"] && "@none"in B[Q]["@none"]["@type"])
            return B[Q]["@none"]["@type"]["@none"];
        if ($.vocab && Q in B) {
            const ae = O["@language"] || "@none"
              , I = [];
            n(D) && "@index"in D && !("@graph"in D) && I.push("@index", "@index@set"),
            n(D) && "@preserve"in D && (D = D["@preserve"][0]),
            u(D) ? ("@index"in D && I.push("@graph@index", "@graph@index@set", "@index", "@index@set"),
            "@id"in D && I.push("@graph@id", "@graph@id@set"),
            I.push("@graph", "@graph@set", "@set"),
            "@index"in D || I.push("@graph@index", "@graph@index@set", "@index", "@index@set"),
            "@id"in D || I.push("@graph@id", "@graph@id@set")) : n(D) && !l(D) && I.push("@id", "@id@set", "@type", "@set@type");
            let Z = "@language"
              , ie = "@null";
            if (X)
                Z = "@type",
                ie = "@reverse",
                I.push("@set");
            else if (a(D)) {
                "@index"in D || I.push("@list");
                const me = D["@list"];
                if (me.length === 0)
                    Z = "@any",
                    ie = "@none";
                else {
                    let W = me.length === 0 ? ae : null
                      , G = null;
                    for (let Y = 0; Y < me.length; ++Y) {
                        const K = me[Y];
                        let le = "@none"
                          , ce = "@none";
                        if (l(K))
                            if ("@direction"in K) {
                                const Ee = (K["@language"] || "").toLowerCase()
                                  , Te = K["@direction"];
                                le = `${Ee}_ ${Te}`
                            } else
                                "@language"in K ? le = K["@language"].toLowerCase() : "@type"in K ? ce = K["@type"] : le = "@null";
                        else
                            ce = "@id";
                        if (W === null ? W = le : le !== W && l(K) && (W = "@none"),
                        G === null ? G = ce : ce !== G && (G = "@none"),
                        W === "@none" && G === "@none")
                            break
                    }
                    W = W || "@none",
                    G = G || "@none",
                    G !== "@none" ? (Z = "@type",
                    ie = G) : ie = W
                }
            } else {
                if (l(D))
                    if ("@language"in D && !("@index"in D)) {
                        I.push("@language", "@language@set"),
                        ie = D["@language"];
                        const me = D["@direction"];
                        me && (ie = `${ie}_ ${me}`)
                    } else
                        "@direction"in D && !("@index"in D) ? ie = `_ ${D["@direction"]}` : "@type"in D && (Z = "@type",
                        ie = D["@type"]);
                else
                    Z = "@type",
                    ie = "@id";
                I.push("@set")
            }
            I.push("@none"),
            n(D) && !("@index"in D) && I.push("@index", "@index@set"),
            l(D) && Object.keys(D).length === 1 && I.push("@language", "@language@set");
            const ee = M(O, Q, D, I, Z, ie);
            if (ee !== null)
                return ee
        }
        if ($.vocab && "@vocab"in O) {
            const ae = O["@vocab"];
            if (Q.indexOf(ae) === 0 && Q !== ae) {
                const I = Q.substr(ae.length);
                if (!O.mappings.has(I))
                    return I
            }
        }
        let ue = null;
        const P = [];
        let oe = O.fastCurieMap;
        const j = Q.length - 1;
        for (let ae = 0; ae < j && Q[ae]in oe; ++ae)
            oe = oe[Q[ae]],
            ""in oe && P.push(oe[""][0]);
        for (let ae = P.length - 1; ae >= 0; --ae) {
            const I = P[ae]
              , Z = I.terms;
            for (const ie of Z) {
                const ee = ie + ":" + Q.substr(I.iri.length);
                O.mappings.get(ie)._prefix && (!O.mappings.has(ee) || D === null && O.mappings.get(ee)["@id"] === Q) && (ue === null || y(ee, ue) < 0) && (ue = ee)
            }
        }
        if (ue !== null)
            return ue;
        for (const [ae,I] of O.mappings)
            if (I && I._prefix && Q.startsWith(ae + ":"))
                throw new i(`Absolute IRI "${Q}" confused with prefix "${ae}".`,"jsonld.SyntaxError",{
                    code: "IRI confused with prefix",
                    context: O
                });
        if (!$.vocab)
            if ("@base"in O)
                if (O["@base"]) {
                    const ae = T(N(F, O["@base"]), Q);
                    return A.test(ae) ? `./${ae}` : ae
                } else
                    return Q;
            else
                return T(F, Q);
        return Q
    }
    ,
    x.compactValue = ({activeCtx: O, activeProperty: Q, value: D, options: $})=>{
        if (l(D)) {
            const ue = _(O, Q, "@type")
              , P = _(O, Q, "@language")
              , oe = _(O, Q, "@direction")
              , j = _(O, Q, "@container") || []
              , ae = "@index"in D && !j.includes("@index");
            if (!ae && ue !== "@none" && (D["@type"] === ue || "@language"in D && D["@language"] === P && "@direction"in D && D["@direction"] === oe || "@language"in D && D["@language"] === P || "@direction"in D && D["@direction"] === oe))
                return D["@value"];
            const I = Object.keys(D).length
              , Z = I === 1 || I === 2 && "@index"in D && !ae
              , ie = "@language"in O
              , ee = r(D["@value"])
              , me = O.mappings.has(Q) && O.mappings.get(Q)["@language"] === null;
            if (Z && ue !== "@none" && (!ie || !ee || me))
                return D["@value"];
            const W = {};
            return ae && (W[x.compactIri({
                activeCtx: O,
                iri: "@index",
                relativeTo: {
                    vocab: !0
                }
            })] = D["@index"]),
            "@type"in D ? W[x.compactIri({
                activeCtx: O,
                iri: "@type",
                relativeTo: {
                    vocab: !0
                }
            })] = x.compactIri({
                activeCtx: O,
                iri: D["@type"],
                relativeTo: {
                    vocab: !0
                }
            }) : "@language"in D && (W[x.compactIri({
                activeCtx: O,
                iri: "@language",
                relativeTo: {
                    vocab: !0
                }
            })] = D["@language"]),
            "@direction"in D && (W[x.compactIri({
                activeCtx: O,
                iri: "@direction",
                relativeTo: {
                    vocab: !0
                }
            })] = D["@direction"]),
            W[x.compactIri({
                activeCtx: O,
                iri: "@value",
                relativeTo: {
                    vocab: !0
                }
            })] = D["@value"],
            W
        }
        const X = m(O, Q, {
            vocab: !0
        }, $)
          , F = _(O, Q, "@type")
          , B = x.compactIri({
            activeCtx: O,
            iri: D["@id"],
            relativeTo: {
                vocab: F === "@vocab"
            },
            base: $.base
        });
        return F === "@id" || F === "@vocab" || X === "@graph" ? B : {
            [x.compactIri({
                activeCtx: O,
                iri: "@id",
                relativeTo: {
                    vocab: !0
                }
            })]: B
        }
    }
    ;
    function M(O, Q, D, $, X, F) {
        F === null && (F = "@null");
        const B = [];
        if ((F === "@id" || F === "@reverse") && n(D) && "@id"in D) {
            F === "@reverse" && B.push("@reverse");
            const P = x.compactIri({
                activeCtx: O,
                iri: D["@id"],
                relativeTo: {
                    vocab: !0
                }
            });
            O.mappings.has(P) && O.mappings.get(P) && O.mappings.get(P)["@id"] === D["@id"] ? B.push.apply(B, ["@vocab", "@id"]) : B.push.apply(B, ["@id", "@vocab"])
        } else {
            B.push(F);
            const P = B.find(oe=>oe.includes("_"));
            P && B.push(P.replace(/^[^_]+_/, "_"))
        }
        B.push("@none");
        const ue = O.inverse[Q];
        for (const P of $) {
            if (!(P in ue))
                continue;
            const oe = ue[P][X];
            for (const j of B)
                if (j in oe)
                    return oe[j]
        }
        return null
    }
    function U(O, Q, D) {
        if (m(O, Q, {
            vocab: !0
        }, D) !== "@nest")
            throw new i("JSON-LD compact error; nested property must have an @nest value resolving to @nest.","jsonld.SyntaxError",{
                code: "invalid @nest value"
            })
    }
    return Va
}
var Ga, zd;
function Mm() {
    return zd || (zd = 1,
    Ga = i=>{
        class e {
            toString() {
                return "[object JsonLdProcessor]"
            }
        }
        return Object.defineProperty(e, "prototype", {
            writable: !1,
            enumerable: !1
        }),
        Object.defineProperty(e.prototype, "constructor", {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: e
        }),
        e.compact = function(n, r) {
            return arguments.length < 2 ? Promise.reject(new TypeError("Could not compact, too few arguments.")) : i.compact(n, r)
        }
        ,
        e.expand = function(n) {
            return arguments.length < 1 ? Promise.reject(new TypeError("Could not expand, too few arguments.")) : i.expand(n)
        }
        ,
        e.flatten = function(n) {
            return arguments.length < 1 ? Promise.reject(new TypeError("Could not flatten, too few arguments.")) : i.flatten(n)
        }
        ,
        e
    }
    ),
    Ga
}
var Wa, Ud;
function Dm() {
    if (Ud)
        return Wa;
    Ud = 1;
    const i = Hl()
      , e = wm()
      , n = Zt()
      , r = Tm()
      , o = n.IdentifierIssuer
      , a = Qt()
      , l = Df()
      , u = Lm()
      , {expand: f} = Im()
      , {flatten: h} = Nm()
      , {fromRDF: m} = Am()
      , {toRDF: _} = Cm()
      , {frameMergedOrDefault: d, cleanupNull: g} = km()
      , {isArray: b, isObject: T, isString: N} = qt()
      , {isSubjectReference: A} = kn()
      , {expandIri: R, getInitialContext: S, process: y, processingMode: x} = _i()
      , {compact: M, compactIri: U} = Pm()
      , {createNodeMap: O, createMergedNodeMap: Q, mergeNodeMaps: D} = Qs()
      , {logEventHandler: $, logWarningEventHandler: X, safeEventHandler: F, setDefaultEventHandler: B, setupEventHandler: ue, strictEventHandler: P, unhandledEventHandler: oe} = Gr()
      , j = function(I) {
        const Z = {}
          , ee = new l({
            max: 100
        });
        I.compact = async function(W, G, Y) {
            if (arguments.length < 2)
                throw new TypeError("Could not compact, too few arguments.");
            if (G === null)
                throw new a("The compaction context must not be null.","jsonld.CompactError",{
                    code: "invalid local context"
                });
            if (W === null)
                return null;
            Y = me(Y, {
                base: N(W) ? W : "",
                compactArrays: !0,
                compactToRelative: !0,
                graph: !1,
                skipExpansion: !1,
                link: !1,
                issuer: new o("_:b"),
                contextResolver: new r({
                    sharedCache: ee
                })
            }),
            Y.link && (Y.skipExpansion = !0),
            Y.compactToRelative || delete Y.base;
            let K;
            Y.skipExpansion ? K = W : K = await I.expand(W, Y);
            const le = await I.processContext(S(Y), G, Y);
            let ce = await M({
                activeCtx: le,
                element: K,
                options: Y
            });
            Y.compactArrays && !Y.graph && b(ce) ? ce.length === 1 ? ce = ce[0] : ce.length === 0 && (ce = {}) : Y.graph && T(ce) && (ce = [ce]),
            T(G) && "@context"in G && (G = G["@context"]),
            G = n.clone(G),
            b(G) || (G = [G]);
            const Ee = G;
            G = [];
            for (let q = 0; q < Ee.length; ++q)
                (!T(Ee[q]) || Object.keys(Ee[q]).length > 0) && G.push(Ee[q]);
            const Te = G.length > 0;
            if (G.length === 1 && (G = G[0]),
            b(ce)) {
                const q = U({
                    activeCtx: le,
                    iri: "@graph",
                    relativeTo: {
                        vocab: !0
                    }
                })
                  , te = ce;
                ce = {},
                Te && (ce["@context"] = G),
                ce[q] = te
            } else if (T(ce) && Te) {
                const q = ce;
                ce = {
                    "@context": G
                };
                for (const te in q)
                    ce[te] = q[te]
            }
            return ce
        }
        ,
        I.expand = async function(W, G) {
            if (arguments.length < 1)
                throw new TypeError("Could not expand, too few arguments.");
            G = me(G, {
                keepFreeFloatingNodes: !1,
                contextResolver: new r({
                    sharedCache: ee
                })
            });
            const Y = {}
              , K = [];
            if ("expandContext"in G) {
                const Te = n.clone(G.expandContext);
                T(Te) && "@context"in Te ? Y.expandContext = Te : Y.expandContext = {
                    "@context": Te
                },
                K.push(Y.expandContext)
            }
            let le;
            if (!N(W))
                Y.input = n.clone(W);
            else {
                const Te = await I.get(W, G);
                le = Te.documentUrl,
                Y.input = Te.document,
                Te.contextUrl && (Y.remoteContext = {
                    "@context": Te.contextUrl
                },
                K.push(Y.remoteContext))
            }
            "base"in G || (G.base = le || "");
            let ce = S(G);
            for (const Te of K)
                ce = await y({
                    activeCtx: ce,
                    localCtx: Te,
                    options: G
                });
            let Ee = await f({
                activeCtx: ce,
                element: Y.input,
                options: G
            });
            return T(Ee) && "@graph"in Ee && Object.keys(Ee).length === 1 ? Ee = Ee["@graph"] : Ee === null && (Ee = []),
            b(Ee) || (Ee = [Ee]),
            Ee
        }
        ,
        I.flatten = async function(W, G, Y) {
            if (arguments.length < 1)
                return new TypeError("Could not flatten, too few arguments.");
            typeof G == "function" ? G = null : G = G || null,
            Y = me(Y, {
                base: N(W) ? W : "",
                contextResolver: new r({
                    sharedCache: ee
                })
            });
            const K = await I.expand(W, Y)
              , le = h(K);
            return G === null ? le : (Y.graph = !0,
            Y.skipExpansion = !0,
            await I.compact(le, G, Y))
        }
        ,
        I.frame = async function(W, G, Y) {
            if (arguments.length < 2)
                throw new TypeError("Could not frame, too few arguments.");
            if (Y = me(Y, {
                base: N(W) ? W : "",
                embed: "@once",
                explicit: !1,
                requireAll: !1,
                omitDefault: !1,
                bnodesToClear: [],
                contextResolver: new r({
                    sharedCache: ee
                })
            }),
            N(G)) {
                const xe = await I.get(G, Y);
                if (G = xe.document,
                xe.contextUrl) {
                    let Se = G["@context"];
                    Se ? b(Se) ? Se.push(xe.contextUrl) : Se = [Se, xe.contextUrl] : Se = xe.contextUrl,
                    G["@context"] = Se
                }
            }
            const K = G ? G["@context"] || {} : {}
              , le = await I.processContext(S(Y), K, Y);
            Y.hasOwnProperty("omitGraph") || (Y.omitGraph = x(le, 1.1)),
            Y.hasOwnProperty("pruneBlankNodeIdentifiers") || (Y.pruneBlankNodeIdentifiers = x(le, 1.1));
            const ce = await I.expand(W, Y)
              , Ee = {
                ...Y
            };
            Ee.isFrame = !0,
            Ee.keepFreeFloatingNodes = !0;
            const Te = await I.expand(G, Ee)
              , q = Object.keys(G).map(xe=>R(le, xe, {
                vocab: !0
            }));
            Ee.merged = !q.includes("@graph"),
            Ee.is11 = x(le, 1.1);
            const te = d(ce, Te, Ee);
            Ee.graph = !Y.omitGraph,
            Ee.skipExpansion = !0,
            Ee.link = {},
            Ee.framing = !0;
            let fe = await I.compact(te, K, Ee);
            return Ee.link = {},
            fe = g(fe, Ee),
            fe
        }
        ,
        I.link = async function(W, G, Y) {
            const K = {};
            return G && (K["@context"] = G),
            K["@embed"] = "@link",
            I.frame(W, K, Y)
        }
        ,
        I.normalize = I.canonize = async function(W, G) {
            if (arguments.length < 1)
                throw new TypeError("Could not canonize, too few arguments.");
            if (G = me(G, {
                base: N(W) ? W : null,
                algorithm: "URDNA2015",
                skipExpansion: !1,
                safe: !0,
                contextResolver: new r({
                    sharedCache: ee
                })
            }),
            "inputFormat"in G) {
                if (G.inputFormat !== "application/n-quads" && G.inputFormat !== "application/nquads")
                    throw new a("Unknown canonicalization input format.","jsonld.CanonizeError");
                const le = u.parse(W);
                return i.canonize(le, G)
            }
            const Y = {
                ...G
            };
            delete Y.format,
            Y.produceGeneralizedRdf = !1;
            const K = await I.toRDF(W, Y);
            return i.canonize(K, G)
        }
        ,
        I.fromRDF = async function(W, G) {
            if (arguments.length < 1)
                throw new TypeError("Could not convert from RDF, too few arguments.");
            G = me(G, {
                format: N(W) ? "application/n-quads" : void 0
            });
            const {format: Y} = G;
            let {rdfParser: K} = G;
            if (Y) {
                if (K = K || Z[Y],
                !K)
                    throw new a("Unknown input format.","jsonld.UnknownFormat",{
                        format: Y
                    })
            } else
                K = ()=>W;
            const le = await K(W);
            return m(le, G)
        }
        ,
        I.toRDF = async function(W, G) {
            if (arguments.length < 1)
                throw new TypeError("Could not convert to RDF, too few arguments.");
            G = me(G, {
                base: N(W) ? W : "",
                skipExpansion: !1,
                contextResolver: new r({
                    sharedCache: ee
                })
            });
            let Y;
            G.skipExpansion ? Y = W : Y = await I.expand(W, G);
            const K = _(Y, G);
            if (G.format) {
                if (G.format === "application/n-quads" || G.format === "application/nquads")
                    return u.serialize(K);
                throw new a("Unknown output format.","jsonld.UnknownFormat",{
                    format: G.format
                })
            }
            return K
        }
        ,
        I.createNodeMap = async function(W, G) {
            if (arguments.length < 1)
                throw new TypeError("Could not create node map, too few arguments.");
            G = me(G, {
                base: N(W) ? W : "",
                contextResolver: new r({
                    sharedCache: ee
                })
            });
            const Y = await I.expand(W, G);
            return Q(Y, G)
        }
        ,
        I.merge = async function(W, G, Y) {
            if (arguments.length < 1)
                throw new TypeError("Could not merge, too few arguments.");
            if (!b(W))
                throw new TypeError('Could not merge, "docs" must be an array.');
            typeof G == "function" ? G = null : G = G || null,
            Y = me(Y, {
                contextResolver: new r({
                    sharedCache: ee
                })
            });
            const K = await Promise.all(W.map(xe=>{
                const Se = {
                    ...Y
                };
                return I.expand(xe, Se)
            }
            ));
            let le = !0;
            "mergeNodes"in Y && (le = Y.mergeNodes);
            const ce = Y.issuer || new o("_:b")
              , Ee = {
                "@default": {}
            };
            for (let xe = 0; xe < K.length; ++xe) {
                const Se = n.relabelBlankNodes(K[xe], {
                    issuer: new o("_:b" + xe + "-")
                })
                  , Ie = le || xe === 0 ? Ee : {
                    "@default": {}
                };
                if (O(Se, Ie, "@default", ce),
                Ie !== Ee)
                    for (const se in Ie) {
                        const be = Ie[se];
                        if (!(se in Ee)) {
                            Ee[se] = be;
                            continue
                        }
                        const Ne = Ee[se];
                        for (const ve in be)
                            ve in Ne || (Ne[ve] = be[ve])
                    }
            }
            const Te = D(Ee)
              , q = []
              , te = Object.keys(Te).sort();
            for (let xe = 0; xe < te.length; ++xe) {
                const Se = Te[te[xe]];
                A(Se) || q.push(Se)
            }
            return G === null ? q : (Y.graph = !0,
            Y.skipExpansion = !0,
            await I.compact(q, G, Y))
        }
        ,
        Object.defineProperty(I, "documentLoader", {
            get: ()=>I._documentLoader,
            set: W=>I._documentLoader = W
        }),
        I.documentLoader = async W=>{
            throw new a("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.","jsonld.LoadDocumentError",{
                code: "loading document failed",
                url: W
            })
        }
        ,
        I.get = async function(W, G) {
            let Y;
            typeof G.documentLoader == "function" ? Y = G.documentLoader : Y = I.documentLoader;
            const K = await Y(W);
            try {
                if (!K.document)
                    throw new a("No remote document found at the given URL.","jsonld.NullRemoteDocument");
                N(K.document) && (K.document = JSON.parse(K.document))
            } catch (le) {
                throw new a("Could not retrieve a JSON-LD document from the URL.","jsonld.LoadDocumentError",{
                    code: "loading document failed",
                    cause: le,
                    remoteDoc: K
                })
            }
            return K
        }
        ,
        I.processContext = async function(W, G, Y) {
            return Y = me(Y, {
                base: "",
                contextResolver: new r({
                    sharedCache: ee
                })
            }),
            G === null ? S(Y) : (G = n.clone(G),
            T(G) && "@context"in G || (G = {
                "@context": G
            }),
            y({
                activeCtx: W,
                localCtx: G,
                options: Y
            }))
        }
        ,
        I.getContextValue = _i().getContextValue,
        I.documentLoaders = {},
        I.useDocumentLoader = function(W) {
            if (!(W in I.documentLoaders))
                throw new a('Unknown document loader type: "' + W + '"',"jsonld.UnknownDocumentLoader",{
                    type: W
                });
            I.documentLoader = I.documentLoaders[W].apply(I, Array.prototype.slice.call(arguments, 1))
        }
        ,
        I.registerRDFParser = function(W, G) {
            Z[W] = G
        }
        ,
        I.unregisterRDFParser = function(W) {
            delete Z[W]
        }
        ,
        I.registerRDFParser("application/n-quads", u.parse),
        I.registerRDFParser("application/nquads", u.parse),
        I.url = Gn(),
        I.logEventHandler = $,
        I.logWarningEventHandler = X,
        I.safeEventHandler = F,
        I.setDefaultEventHandler = B,
        I.strictEventHandler = P,
        I.unhandledEventHandler = oe,
        I.util = n,
        Object.assign(I, n),
        I.promises = I,
        I.RequestQueue = Mf(),
        I.JsonLdProcessor = Mm()(I),
        e.setupGlobals(I),
        e.setupDocumentLoaders(I);
        function me(W, {documentLoader: G=I.documentLoader, ...Y}) {
            if (W && "compactionMap"in W)
                throw new a('"compactionMap" not supported.',"jsonld.OptionsError");
            if (W && "expansionMap"in W)
                throw new a('"expansionMap" not supported.',"jsonld.OptionsError");
            return Object.assign({}, {
                documentLoader: G
            }, Y, W, {
                eventHandler: ue({
                    options: W
                })
            })
        }
        return I
    }
      , ae = function() {
        return j(function() {
            return ae()
        })
    };
    return j(ae),
    Wa = ae,
    Wa
}
var Om = Dm();
const Fm = ef(Om)
  , bs = {}
  , Za = {}
  , Bi = {};
async function jm(i) {
    const e = {
        store: new It,
        importedUrls: [],
        importedClasses: [],
        atts: i
    }
      , n = [];
    if (i.shapes ? n.push(fi(Os(i.shapes, pi), e)) : i.shapesUrl && n.push(fi(Ls(i.shapesUrl, e, pi), e)),
    i.values ? n.push(fi(Os(i.values, on), e)) : i.valuesUrl && n.push(fi(Ls(i.valuesUrl, e, on), e)),
    await Promise.all(n),
    e.store.countQuads(null, null, null, pi) === 0 && i.valuesSubject) {
        const r = [...e.store.getObjects(i.valuesSubject, Ds, on)]
          , o = [];
        for (const a of r) {
            const l = Of(a.value);
            l && e.importedUrls.indexOf(l) < 0 && (e.importedUrls.push(l),
            o.push(fi(Ls(l, e, pi), e)))
        }
        try {
            await Promise.allSettled(o)
        } catch (a) {
            console.warn(a)
        }
    }
    return e.store
}
async function fi(i, e) {
    const n = await i
      , r = [];
    for (const o of n) {
        if (e.store.add(new Us(o.subject,o.predicate,o.object,o.graph)),
        jl.equals(o.predicate) && e.atts.loadOwlImports) {
            const a = Of(o.object.value);
            a && e.importedUrls.indexOf(a) < 0 && (e.importedUrls.push(a),
            r.push(fi(Ls(a, e), e)))
        }
        if (e.atts.classInstanceProvider && (Bl.equals(o.predicate) || Zs.equals(o.predicate))) {
            const a = o.object.value;
            if (e.importedClasses.indexOf(a) < 0) {
                let l;
                a in Za ? l = Za[a] : (l = e.atts.classInstanceProvider(a),
                Za[a] = l),
                e.importedClasses.push(a),
                r.push(fi(Os(await l, pi), e))
            }
        }
    }
    await Promise.allSettled(r)
}
async function Ls(i, e, n) {
    return i in bs || (bs[i] = new Promise(async(r,o)=>{
        try {
            let a = i;
            e.atts.proxy && (a = e.atts.proxy + encodeURIComponent(i));
            const l = await fetch(a, {
                headers: {
                    Accept: "text/turtle, application/trig, application/n-triples, application/n-quads, text/n3, application/ld+json"
                }
            }).then(u=>u.text());
            r(await Os(l, n || ze.namedNode(i)))
        } catch (a) {
            o(a)
        }
    }
    )),
    bs[i]
}
async function Os(i, e) {
    if (Hd(i) === "json")
        try {
            i = await Fm.toRDF(JSON.parse(i), {
                format: "application/n-quads"
            })
        } catch (r) {
            console.error(r)
        }
    const n = [];
    return await new Promise((r,o)=>{
        const a = Hd(i) === "xml" ? new hm.RdfXmlParser : new zg;
        a.on("data", l=>{
            n.push(new Us(l.subject,l.predicate,l.object,e))
        }
        ).on("error", l=>{
            o(l)
        }
        ).on("prefix", (l,u)=>{
            l && (Bi[l] = u)
        }
        ).on("end", ()=>{
            r(null)
        }
        ),
        a.write(i),
        a.end()
    }
    ),
    n
}
function Of(i) {
    if (xl(i))
        return i;
    const e = i.split(":");
    if (e.length === 2) {
        const n = Bi[e[0]];
        if (n && (i = i.replace(`${e[0]}:`, n),
        xl(i)))
            return i
    }
    return null
}
function Hd(i) {
    return /^\s*\{/.test(i) ? "json" : /^\s*<\?xml/.test(i) ? "xml" : "ttl"
}
const Bm = {
    [`${Fe}name`]: (i,e)=>{
        const n = e;
        i.name = $c(i.config.languages, i.name, n)
    }
    ,
    [`${Fe}description`]: (i,e)=>{
        const n = e;
        i.description = $c(i.config.languages, i.description, n)
    }
    ,
    [`${Fe}path`]: (i,e)=>{
        i.path = e.value
    }
    ,
    [`${Fe}group`]: (i,e)=>{
        i.group = e.id
    }
    ,
    [`${Fe}datatype`]: (i,e)=>{
        i.datatype = e
    }
    ,
    [`${Fe}nodeKind`]: (i,e)=>{
        i.nodeKind = e
    }
    ,
    [`${Fe}minCount`]: (i,e)=>{
        i.minCount = parseInt(e.value)
    }
    ,
    [`${Fe}maxCount`]: (i,e)=>{
        i.maxCount = parseInt(e.value)
    }
    ,
    [`${Fe}minLength`]: (i,e)=>{
        i.minLength = parseInt(e.value)
    }
    ,
    [`${Fe}maxLength`]: (i,e)=>{
        i.maxLength = parseInt(e.value)
    }
    ,
    [`${Fe}minInclusive`]: (i,e)=>{
        i.minInclusive = parseInt(e.value)
    }
    ,
    [`${Fe}maxInclusive`]: (i,e)=>{
        i.maxInclusive = parseInt(e.value)
    }
    ,
    [`${Fe}minExclusive`]: (i,e)=>{
        i.minExclusive = parseInt(e.value)
    }
    ,
    [`${Fe}maxExclusive`]: (i,e)=>{
        i.maxExclusive = parseInt(e.value)
    }
    ,
    [`${Fe}pattern`]: (i,e)=>{
        i.pattern = e.value
    }
    ,
    [`${Fe}order`]: (i,e)=>{
        i.order = parseInt(e.value)
    }
    ,
    [`${jc}singleLine`]: (i,e)=>{
        i.singleLine = e.value === "true"
    }
    ,
    [`${jc}readonly`]: (i,e)=>{
        i.readonly = e.value === "true"
    }
    ,
    [`${Hg}styleClass`]: (i,e)=>{
        i.cssClass = e.value
    }
    ,
    [`${Fe}in`]: (i,e)=>{
        i.in = e.value
    }
    ,
    [`${Fe}languageIn`]: (i,e)=>{
        i.languageIn = i.config.lists[e.value],
        i.datatype = bf
    }
    ,
    [`${Fe}defaultValue`]: (i,e)=>{
        i.defaultValue = e
    }
    ,
    [`${Fe}hasValue`]: (i,e)=>{
        i.hasValue = e
    }
    ,
    [`${Fe}node`]: (i,e)=>{
        i.node = e,
        i.nodeShapes.add(i.config.getNodeTemplate(e, i))
    }
    ,
    [`${Fe}and`]: (i,e)=>{
        i.and = e.value;
        const n = i.config.lists[i.and];
        if (n?.length)
            for (const r of n)
                i.nodeShapes.add(i.config.getNodeTemplate(r, i))
    }
    ,
    [`${Fe}qualifiedValueShape`]: (i,e)=>{
        const n = i.config.getNodeTemplate(e, i);
        i.qualifiedValueShape = n,
        i.nodeShapes.add(n)
    }
    ,
    [`${Fe}qualifiedMinCount`]: (i,e)=>{
        i.qualifiedMinCount = parseInt(e.value)
    }
    ,
    [`${Fe}qualifiedMaxCount`]: (i,e)=>{
        i.qualifiedMaxCount = parseInt(e.value)
    }
    ,
    [jl.id]: (i,e)=>{
        i.owlImports.add(e)
    }
    ,
    [Bl.id]: (i,e)=>{
        i.class = e;
        const n = i.config.store.getSubjects(Zs, e, null);
        n.length > 0 && (i.node = n[0])
    }
    ,
    [`${Fe}or`]: (i,e)=>{
        const n = i.config.lists[e.value];
        n?.length ? i.or = n : console.error("list for sh:or not found:", e.value, "existing lists:", i.config.lists)
    }
    ,
    [`${Fe}xone`]: (i,e)=>{
        const n = i.config.lists[e.value];
        n?.length ? i.xone = n : console.error("list for sh:xone not found:", e.value, "existing lists:", i.config.lists)
    }
};
class Vd {
    constructor(e, n) {
        this.label = "",
        this.nodeShapes = new Set,
        this.owlImports = new Set,
        this.id = e,
        this.parent = n,
        this.config = n.config,
        this.config.registerPropertyTemplate(this),
        Gl(this, this.config.store.getQuads(e, null, null, null)),
        this.aggregatedMinCount = Math.max(this.minCount || 0, this.qualifiedMinCount || 0),
        this.aggregatedMaxCount = Math.min(this.maxCount || 0, this.qualifiedMaxCount || 0)
    }
}
function Ff(i) {
    const e = Object.assign({}, i);
    return e.nodeShapes = new Set(i.nodeShapes),
    e.owlImports = new Set(i.owlImports),
    i.languageIn && (e.languageIn = [...i.languageIn]),
    i.or && (e.or = [...i.or]),
    i.xone && (e.xone = [...i.xone]),
    e
}
function Gl(i, e) {
    for (const n of e)
        Bm[n.predicate.id]?.call(i, i, n.object);
    return i.label = i.name?.value || Wi(e, i.config.languages),
    i.label || (i.label = i.path ? wl(i.path, Bi) : "unknown"),
    i
}
function jf(i, e) {
    const n = e
      , r = i;
    for (const o in e)
        o !== "parent" && o !== "config" && o !== "id" && n[o] !== void 0 && n[o] !== "" && (Array.isArray(n[o]) ? r[o].push(...n[o]) : n[o]instanceof Set && n[o].size ? r[o] = new Set([...r[o], ...n[o]]) : r[o] = n[o])
}
function Bf(i, e, n) {
    const r = document.createElement("div");
    r.classList.add("shacl-or-constraint");
    const o = [];
    if (e instanceof Ei) {
        const a = [];
        let l = !1;
        i.length && (l = n.store.countQuads(i[0], bl, null, null) > 0);
        for (let h = 0; h < i.length; h++)
            if (l) {
                const m = n.store.getObjects(i[h], bl, null)
                  , _ = [];
                let d = "";
                for (const g of m) {
                    const b = n.getPropertyTemplate(g, e.template)
                      , T = new Bs(b,e);
                    _.push(T),
                    d += (d.length > 1 ? " / " : "") + T.template.label
                }
                a.push(_),
                o.push({
                    label: d,
                    value: h.toString()
                })
            } else {
                const m = i[h]
                  , _ = n.getPropertyTemplate(m, e.template)
                  , d = new Bs(_,e);
                a.push([d]),
                o.push({
                    label: d.template.label,
                    value: h.toString()
                })
            }
        const u = n.theme.createListEditor("Please choose", null, !1, o)
          , f = u.querySelector(".editor");
        f.onchange = ()=>{
            if (f.value) {
                const h = a[parseInt(f.value)];
                let m;
                h.length && (m = h[0],
                r.replaceWith(h[0]));
                for (let _ = 1; _ < h.length; _++)
                    m.after(h[_]),
                    m = h[_]
            }
        }
        ,
        r.appendChild(u)
    } else {
        const a = [];
        for (let f = 0; f < i.length; f++) {
            const h = n.store.getQuads(i[f], null, null, null);
            h.length && (a.push(h),
            o.push({
                label: Wi(h, n.languages) || wl(h[0].predicate.value, Bi) + " = " + wl(h[0].object.value, Bi),
                value: f.toString()
            }))
        }
        const l = n.theme.createListEditor(e.template.label + "?", null, !1, o, e.template)
          , u = l.querySelector(".editor");
        u.onchange = ()=>{
            if (u.value) {
                const f = Gl(Ff(e.template), a[parseInt(u.value)]);
                r.replaceWith(Cs(f, void 0, !0))
            }
        }
        ,
        r.appendChild(l)
    }
    return r
}
function $m(i, e, n) {
    if (e instanceof Wt) {
        const r = e.datatype;
        for (const o of i) {
            const a = n.store.getQuads(o, null, null, null);
            for (const l of a)
                if (l.predicate.value === `${Fe}datatype` && l.object.equals(r))
                    return a
        }
    } else {
        const r = n.store.getObjects(e, Rt, null);
        for (const o of i) {
            const a = n.store.getQuads(o, null, null, null);
            for (const l of a)
                if (r.length > 0) {
                    if (l.predicate.value === `${Fe}node`) {
                        for (const u of r)
                            if (n.store.getQuads(l.object, Zs, u, null).length > 0)
                                return a
                    }
                    if (l.predicate.equals(Bl)) {
                        for (const u of r)
                            if (l.object.equals(u))
                                return a
                    }
                } else if (l.predicate.equals(Xg) && l.object.equals(wf))
                    return a
        }
    }
    return console.error("couldn't resolve sh:or/sh:xone on property for value", e),
    []
}
function qm(i, e, n) {
    for (const r of i) {
        let o = !1;
        const a = n.store.getObjects(r, bl, null);
        for (const l of a) {
            const u = n.store.getObjects(l, `${Fe}path`, null);
            for (const f of u)
                if (o = n.store.countQuads(e, f, null, null) > 0,
                o)
                    break
        }
        if (o)
            return a
    }
    return console.error("couldn't resolve sh:or/sh:xone on node for value", e),
    []
}
const zm = `form { display:block; --label-width: 8em; --caret-size: 10px; }
form.mode-edit { padding-left: 1em;  }
form, form * { box-sizing: border-box; }
shacl-node, .collapsible::part(content) { display: flex; flex-direction: column; width: 100%; position: relative; }
shacl-node .remove-button { margin-top: 1px; }
shacl-node .add-button { color: #555; background-color: transparent; margin: 4px 24px 0 0; border: 0; }
shacl-node .add-button:hover { color:#222; }
shacl-node .add-button:focus { box-shadow: none; }
shacl-node h1 { font-size: 16px; border-bottom: 1px solid #AAA; margin-top: 4px; color: #555; }
shacl-property:not(:has(>.collapsible)), shacl-property>.collapsible::part(content) { display: flex; flex-direction: column; align-items: end; position: relative; }
shacl-property:not(.may-add) > .add-button, shacl-property:not(.may-add) > .collapsible > .add-button { display: none; }
shacl-property:not(.may-remove) > .property-instance > .remove-button:not(.persistent) { visibility: hidden; }
shacl-property:not(.may-remove) > .collapsible > .property-instance > .remove-button:not(.persistent) { visibility: hidden; }
shacl-property:not(.may-remove) > .shacl-or-constraint > .remove-button:not(.persistent) { visibility: hidden; }
.mode-view .shacl-group:not(:has(shacl-property)) { display: none; }
.property-instance, .shacl-or-constraint { display: flex; align-items: flex-start; padding: 4px 0; width: 100%; position: relative; }
.shacl-or-constraint > div { display: flex; align-items: flex-start; }
.shacl-or-constraint > div:first-child { flex-grow: 1 }
.shacl-or-constraint label { display: inline-block; word-break: break-word; width: var(--label-width); line-height: 1em; padding-top: 0.15em; padding-right: 1em; flex-shrink: 0; position: relative; }
.property-instance label[title] { cursor: help; text-decoration: underline dashed #AAA; }
.property-instance.linked label:after, label.linked:after { content: '\\1F517'; font-size: 0.6em; padding-left: 6px; }
.mode-edit .property-instance label.required::before { color: red; content: '\\2736'; font-size: 0.6rem; position: absolute; left: -1.4em; top: 0.15rem; }
.property-instance.valid::before { content: ''; position: absolute; left: calc(var(--label-width) - 1em); top:0.5em; width: 0.9em; height: 0.9em; background: url('data:image/svg+xml;utf8,<svg viewBox="0 0 1024 1024" fill="green" version="1.1" xmlns="http://www.w3.org/2000/svg"><path d="M866.133333 258.133333L362.666667 761.6l-204.8-204.8L98.133333 618.666667 362.666667 881.066667l563.2-563.2z"/></svg>'); }
.editor:not([type='checkbox']) { flex-grow: 1; }
textarea.editor { resize: vertical; }
.lang-chooser { border: 0; background-color: #e9e9ed; padding: 2px 4px; align-self: flex-start; }
.validation-error { position: absolute; left: calc(var(--label-width) - 1em); color: red; cursor: help; }
.validation-error::before { content: '\\26a0' }
.validation-error.node { left: -1em; }
.invalid > .editor { border-color: red !important; }
.ml-0  { margin-left: 0 !important; }
.pr-0  { padding-right: 0 !important; }
.mode-view .property-instance:not(:first-child) > label { visibility: hidden; }
.mode-view .property-instance label { width: var(--label-width); }

.d-flex { display: flex; }
.lang { opacity: 0.65; font-size: 0.6em; }
a, a:visited { color: inherit; }

.fadeIn, .fadeOut { animation: fadeIn 0.2s ease-out; }
.fadeOut { animation-direction: reverse; animation-timing-function: ease-out;}
@keyframes fadeIn {
    0% { opacity: 0; transform: scaleY(0.8); }
    100% { opacity: 1; transform: scaleY(1); }
}
.collapsible::part(label) { font-weight: 600; }
.collapsible > .property-instance:nth-child(even) { background-color: #F8F8F8; }
.collapsible > .property-instance > shacl-node > h1 { display: none; }
.ref-link { cursor: pointer; }
.ref-link:hover { text-decoration: underline; }
.node-id-display { color: #999; font-size: 11px; }
/* hierarchy colors */
.remove-button-wrapper { padding: 0 1px 0 calc(1px + var(--hierarchy-color-width)); align-self: stretch; position: relative; }
.remove-button-wrapper.colorize::before {
    content: '';
    position: absolute;
    width: var(--hierarchy-color-width);
    top: 0; bottom: 0; left: 0;
    --index: mod(var(--hierarchy-level), var(--hierarchy-colors-length));
    background: linear-gradient(var(--hierarchy-colors)) no-repeat 0 calc(var(--index) * 100% / (var(--hierarchy-colors-length) - 1)) / 100% calc(1px * infinity);
 }
.property-instance:not(:has(shacl-node)) > .remove-button-wrapper.colorize::before { background: 0; }
`;
class Um {
    constructor(e) {
        this.dense = !0;
        let n = zm;
        e && (n += `
` + e),
        this.stylesheet = new CSSStyleSheet,
        this.stylesheet.replaceSync(n)
    }
    apply(e) {}
    setDense(e) {
        this.dense = e
    }
    createViewer(e, n, r) {
        const o = document.createElement("div")
          , a = document.createElement("label");
        a.innerHTML = e + ":",
        r.description && a.setAttribute("title", r.description.value),
        o.appendChild(a);
        let l = n.value
          , u = null;
        if (n instanceof mi) {
            const h = r.config.store.getQuads(l, null, null, null);
            if (h.length) {
                const m = Wi(h, r.config.languages);
                m && (l = m)
            }
        } else
            n instanceof Wt && (n.language ? (u = document.createElement("span"),
            u.classList.add("lang"),
            u.innerText = `@${n.language}`) : n.datatype.value === `${Un}date` ? l = new Date(Date.parse(n.value)).toDateString() : n.datatype.value === `${Un}dateTime` && (l = new Date(Date.parse(n.value)).toLocaleString()));
        let f;
        return xl(n.value) ? (f = document.createElement("a"),
        f.setAttribute("href", n.value)) : f = document.createElement("div"),
        f.classList.add("d-flex"),
        f.innerText = l,
        u && f.appendChild(u),
        o.appendChild(f),
        o
    }
}
function $f(i, e, n) {
    if (n) {
        const r = i.aggregatedMinCount > 0;
        if (i.class && !i.hasValue)
            return i.config.theme.createListEditor(i.label, e, r, $l(i.class, i), i);
        if (i.in) {
            const o = i.config.lists[i.in];
            if (o?.length) {
                const a = xf(o, i.config.store, i.config.languages);
                return i.config.theme.createListEditor(i.label, e, r, a, i)
            } else
                console.error("list not found:", i.in, "existing lists:", i.config.lists)
        }
        if (i.datatype?.equals(bf) || i.languageIn?.length || i.datatype === void 0 && e instanceof Wt && e.language)
            return i.config.theme.createLangStringEditor(i.label, e, r, i);
        switch (i.datatype?.value.replace(Un, "")) {
        case "integer":
        case "float":
        case "double":
        case "decimal":
            return i.config.theme.createNumberEditor(i.label, e, r, i);
        case "date":
        case "dateTime":
            return i.config.theme.createDateEditor(i.label, e, r, i);
        case "boolean":
            return i.config.theme.createBooleanEditor(i.label, e, r, i);
        case "base64Binary":
            return i.config.theme.createFileEditor(i.label, e, r, i)
        }
        return i.config.theme.createTextEditor(i.label, e, r, i)
    } else {
        if (e)
            return i.config.theme.createViewer(i.label, e, i);
        const r = document.createElement("div");
        return r.innerHTML = "No value",
        r
    }
}
function Hm(i, e, n) {
    if (e === "application/ld+json")
        return Vm(i);
    {
        const r = new Cl({
            format: e,
            prefixes: n
        });
        r.addQuads(i);
        let o = "";
        return r.end((a,l)=>{
            a && console.error(a),
            o = l
        }
        ),
        o
    }
}
function Vm(i) {
    const e = [];
    for (const n of i) {
        const r = {
            "@id": n.subject.id
        };
        if (n.predicate === Rt)
            r["@type"] = n.object.id;
        else {
            let o = n.object.value;
            n.object instanceof Wt ? n.object.language ? o = {
                "@language": n.object.language,
                "@value": n.object.value
            } : n.object.datatype && n.object.datatype.value !== `${Un}#string` && (o = {
                "@type": n.object.datatype.value,
                "@value": n.object.value
            }) : o = {
                "@id": n.object.id
            },
            r[n.predicate.value] = o
        }
        e.push(r)
    }
    return JSON.stringify(e)
}
function Gm(i) {
    let e = i.shaclDatatype
      , n = i.dataset.value || i.value;
    if (n) {
        if (n.startsWith("<") && n.endsWith(">") && n.indexOf(":") > -1)
            return ze.namedNode(n.substring(1, n.length - 1));
        if (i.dataset.class || i.dataset.nodeKind === Fe + "IRI")
            return ze.namedNode(n);
        if (i.dataset.link)
            return JSON.parse(i.dataset.link);
        if (i.dataset.lang ? e = i.dataset.lang : i.type === "number" ? n = parseFloat(n) : i.type === "file" && i.binaryData ? n = i.binaryData : i.type === "datetime-local" && (n = new Date(n).toISOString().slice(0, 19)),
        (!e || e instanceof mi && Qg.equals(e)) && typeof n == "string") {
            let r = n.split("^^");
            r.length === 2 && r[0].startsWith('"') && r[0].endsWith('"') && r[1].split(":").length === 2 ? (n = r[0].substring(1, r[0].length - 1),
            e = ze.namedNode(r[1])) : (r = n.split("@"),
            r.length === 2 && r[0].startsWith('"') && r[0].endsWith('"') ? (n = r[0].substring(1, r[0].length - 1),
            e = r[1]) : n.startsWith('"') && n.endsWith('"') && (n = n.substring(1, n.length - 1)))
        }
        return ze.literal(n, e)
    } else if ((i.type === "checkbox" || i.getAttribute("type") === "checkbox") && (i.checked || parseInt(i.dataset.minCount || "0") > 0))
        return ze.literal(i.checked ? "true" : "false", e)
}
const Fr = {};
function Wm(i) {
    i.predicate === void 0 && i.datatype === void 0 ? console.warn('not registering plugin because it does neither define "predicate" nor "datatype"', i) : Fr[`${i.predicate}^${i.datatype}`] = i
}
function Zm() {
    return Object.entries(Fr).map(i=>i[1])
}
function Xm(i, e) {
    let n = Fr[`${i}^${e}`];
    return n || (n = Fr[`${i}^undefined`],
    n) ? n : Fr[`undefined^${e}`]
}
class qf {
    constructor(e, n) {
        this.predicate = e.predicate,
        this.datatype = e.datatype,
        n && (this.stylesheet = new CSSStyleSheet,
        this.stylesheet.replaceSync(n))
    }
    createViewer(e, n) {
        return e.config.theme.createViewer(e.label, n, e)
    }
}
const Is = globalThis
  , Wl = Is.ShadowRoot && (Is.ShadyCSS === void 0 || Is.ShadyCSS.nativeShadow) && "adoptedStyleSheets"in Document.prototype && "replace"in CSSStyleSheet.prototype
  , Zl = Symbol()
  , Gd = new WeakMap;
let zf = class {
    constructor(e, n, r) {
        if (this._$cssResult$ = !0,
        r !== Zl)
            throw Error("CSSResult is not constructable. Use `unsafeCSS` or `css` instead.");
        this.cssText = e,
        this.t = n
    }
    get styleSheet() {
        let e = this.o;
        const n = this.t;
        if (Wl && e === void 0) {
            const r = n !== void 0 && n.length === 1;
            r && (e = Gd.get(n)),
            e === void 0 && ((this.o = e = new CSSStyleSheet).replaceSync(this.cssText),
            r && Gd.set(n, e))
        }
        return e
    }
    toString() {
        return this.cssText
    }
}
;
const Uf = i=>new zf(typeof i == "string" ? i : i + "",void 0,Zl)
  , Jt = (i,...e)=>{
    const n = i.length === 1 ? i[0] : e.reduce(((r,o,a)=>r + (l=>{
        if (l._$cssResult$ === !0)
            return l.cssText;
        if (typeof l == "number")
            return l;
        throw Error("Value passed to 'css' function must be a 'css' function result: " + l + ". Use 'unsafeCSS' to pass non-literal values, but take care to ensure page security.")
    }
    )(o) + i[a + 1]), i[0]);
    return new zf(n,i,Zl)
}
  , Qm = (i,e)=>{
    if (Wl)
        i.adoptedStyleSheets = e.map((n=>n instanceof CSSStyleSheet ? n : n.styleSheet));
    else
        for (const n of e) {
            const r = document.createElement("style")
              , o = Is.litNonce;
            o !== void 0 && r.setAttribute("nonce", o),
            r.textContent = n.cssText,
            i.appendChild(r)
        }
}
  , Wd = Wl ? i=>i : i=>i instanceof CSSStyleSheet ? (e=>{
    let n = "";
    for (const r of e.cssRules)
        n += r.cssText;
    return Uf(n)
}
)(i) : i;
const {is: Jm, defineProperty: Km, getOwnPropertyDescriptor: Ym, getOwnPropertyNames: e_, getOwnPropertySymbols: t_, getPrototypeOf: n_} = Object
  , Js = globalThis
  , Zd = Js.trustedTypes
  , i_ = Zd ? Zd.emptyScript : ""
  , r_ = Js.reactiveElementPolyfillSupport
  , jr = (i,e)=>i
  , Fs = {
    toAttribute(i, e) {
        switch (e) {
        case Boolean:
            i = i ? i_ : null;
            break;
        case Object:
        case Array:
            i = i == null ? i : JSON.stringify(i)
        }
        return i
    },
    fromAttribute(i, e) {
        let n = i;
        switch (e) {
        case Boolean:
            n = i !== null;
            break;
        case Number:
            n = i === null ? null : Number(i);
            break;
        case Object:
        case Array:
            try {
                n = JSON.parse(i)
            } catch {
                n = null
            }
        }
        return n
    }
}
  , Xl = (i,e)=>!Jm(i, e)
  , Xd = {
    attribute: !0,
    type: String,
    converter: Fs,
    reflect: !1,
    useDefault: !1,
    hasChanged: Xl
};
Symbol.metadata ??= Symbol("metadata"),
Js.litPropertyMetadata ??= new WeakMap;
let Mi = class extends HTMLElement {
    static addInitializer(e) {
        this._$Ei(),
        (this.l ??= []).push(e)
    }
    static get observedAttributes() {
        return this.finalize(),
        this._$Eh && [...this._$Eh.keys()]
    }
    static createProperty(e, n=Xd) {
        if (n.state && (n.attribute = !1),
        this._$Ei(),
        this.prototype.hasOwnProperty(e) && ((n = Object.create(n)).wrapped = !0),
        this.elementProperties.set(e, n),
        !n.noAccessor) {
            const r = Symbol()
              , o = this.getPropertyDescriptor(e, r, n);
            o !== void 0 && Km(this.prototype, e, o)
        }
    }
    static getPropertyDescriptor(e, n, r) {
        const {get: o, set: a} = Ym(this.prototype, e) ?? {
            get() {
                return this[n]
            },
            set(l) {
                this[n] = l
            }
        };
        return {
            get: o,
            set(l) {
                const u = o?.call(this);
                a?.call(this, l),
                this.requestUpdate(e, u, r)
            },
            configurable: !0,
            enumerable: !0
        }
    }
    static getPropertyOptions(e) {
        return this.elementProperties.get(e) ?? Xd
    }
    static _$Ei() {
        if (this.hasOwnProperty(jr("elementProperties")))
            return;
        const e = n_(this);
        e.finalize(),
        e.l !== void 0 && (this.l = [...e.l]),
        this.elementProperties = new Map(e.elementProperties)
    }
    static finalize() {
        if (this.hasOwnProperty(jr("finalized")))
            return;
        if (this.finalized = !0,
        this._$Ei(),
        this.hasOwnProperty(jr("properties"))) {
            const n = this.properties
              , r = [...e_(n), ...t_(n)];
            for (const o of r)
                this.createProperty(o, n[o])
        }
        const e = this[Symbol.metadata];
        if (e !== null) {
            const n = litPropertyMetadata.get(e);
            if (n !== void 0)
                for (const [r,o] of n)
                    this.elementProperties.set(r, o)
        }
        this._$Eh = new Map;
        for (const [n,r] of this.elementProperties) {
            const o = this._$Eu(n, r);
            o !== void 0 && this._$Eh.set(o, n)
        }
        this.elementStyles = this.finalizeStyles(this.styles)
    }
    static finalizeStyles(e) {
        const n = [];
        if (Array.isArray(e)) {
            const r = new Set(e.flat(1 / 0).reverse());
            for (const o of r)
                n.unshift(Wd(o))
        } else
            e !== void 0 && n.push(Wd(e));
        return n
    }
    static _$Eu(e, n) {
        const r = n.attribute;
        return r === !1 ? void 0 : typeof r == "string" ? r : typeof e == "string" ? e.toLowerCase() : void 0
    }
    constructor() {
        super(),
        this._$Ep = void 0,
        this.isUpdatePending = !1,
        this.hasUpdated = !1,
        this._$Em = null,
        this._$Ev()
    }
    _$Ev() {
        this._$ES = new Promise((e=>this.enableUpdating = e)),
        this._$AL = new Map,
        this._$E_(),
        this.requestUpdate(),
        this.constructor.l?.forEach((e=>e(this)))
    }
    addController(e) {
        (this._$EO ??= new Set).add(e),
        this.renderRoot !== void 0 && this.isConnected && e.hostConnected?.()
    }
    removeController(e) {
        this._$EO?.delete(e)
    }
    _$E_() {
        const e = new Map
          , n = this.constructor.elementProperties;
        for (const r of n.keys())
            this.hasOwnProperty(r) && (e.set(r, this[r]),
            delete this[r]);
        e.size > 0 && (this._$Ep = e)
    }
    createRenderRoot() {
        const e = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);
        return Qm(e, this.constructor.elementStyles),
        e
    }
    connectedCallback() {
        this.renderRoot ??= this.createRenderRoot(),
        this.enableUpdating(!0),
        this._$EO?.forEach((e=>e.hostConnected?.()))
    }
    enableUpdating(e) {}
    disconnectedCallback() {
        this._$EO?.forEach((e=>e.hostDisconnected?.()))
    }
    attributeChangedCallback(e, n, r) {
        this._$AK(e, r)
    }
    _$ET(e, n) {
        const r = this.constructor.elementProperties.get(e)
          , o = this.constructor._$Eu(e, r);
        if (o !== void 0 && r.reflect === !0) {
            const a = (r.converter?.toAttribute !== void 0 ? r.converter : Fs).toAttribute(n, r.type);
            this._$Em = e,
            a == null ? this.removeAttribute(o) : this.setAttribute(o, a),
            this._$Em = null
        }
    }
    _$AK(e, n) {
        const r = this.constructor
          , o = r._$Eh.get(e);
        if (o !== void 0 && this._$Em !== o) {
            const a = r.getPropertyOptions(o)
              , l = typeof a.converter == "function" ? {
                fromAttribute: a.converter
            } : a.converter?.fromAttribute !== void 0 ? a.converter : Fs;
            this._$Em = o;
            const u = l.fromAttribute(n, a.type);
            this[o] = u ?? this._$Ej?.get(o) ?? u,
            this._$Em = null
        }
    }
    requestUpdate(e, n, r) {
        if (e !== void 0) {
            const o = this.constructor
              , a = this[e];
            if (r ??= o.getPropertyOptions(e),
            !((r.hasChanged ?? Xl)(a, n) || r.useDefault && r.reflect && a === this._$Ej?.get(e) && !this.hasAttribute(o._$Eu(e, r))))
                return;
            this.C(e, n, r)
        }
        this.isUpdatePending === !1 && (this._$ES = this._$EP())
    }
    C(e, n, {useDefault: r, reflect: o, wrapped: a}, l) {
        r && !(this._$Ej ??= new Map).has(e) && (this._$Ej.set(e, l ?? n ?? this[e]),
        a !== !0 || l !== void 0) || (this._$AL.has(e) || (this.hasUpdated || r || (n = void 0),
        this._$AL.set(e, n)),
        o === !0 && this._$Em !== e && (this._$Eq ??= new Set).add(e))
    }
    async _$EP() {
        this.isUpdatePending = !0;
        try {
            await this._$ES
        } catch (n) {
            Promise.reject(n)
        }
        const e = this.scheduleUpdate();
        return e != null && await e,
        !this.isUpdatePending
    }
    scheduleUpdate() {
        return this.performUpdate()
    }
    performUpdate() {
        if (!this.isUpdatePending)
            return;
        if (!this.hasUpdated) {
            if (this.renderRoot ??= this.createRenderRoot(),
            this._$Ep) {
                for (const [o,a] of this._$Ep)
                    this[o] = a;
                this._$Ep = void 0
            }
            const r = this.constructor.elementProperties;
            if (r.size > 0)
                for (const [o,a] of r) {
                    const {wrapped: l} = a
                      , u = this[o];
                    l !== !0 || this._$AL.has(o) || u === void 0 || this.C(o, void 0, a, u)
                }
        }
        let e = !1;
        const n = this._$AL;
        try {
            e = this.shouldUpdate(n),
            e ? (this.willUpdate(n),
            this._$EO?.forEach((r=>r.hostUpdate?.())),
            this.update(n)) : this._$EM()
        } catch (r) {
            throw e = !1,
            this._$EM(),
            r
        }
        e && this._$AE(n)
    }
    willUpdate(e) {}
    _$AE(e) {
        this._$EO?.forEach((n=>n.hostUpdated?.())),
        this.hasUpdated || (this.hasUpdated = !0,
        this.firstUpdated(e)),
        this.updated(e)
    }
    _$EM() {
        this._$AL = new Map,
        this.isUpdatePending = !1
    }
    get updateComplete() {
        return this.getUpdateComplete()
    }
    getUpdateComplete() {
        return this._$ES
    }
    shouldUpdate(e) {
        return !0
    }
    update(e) {
        this._$Eq &&= this._$Eq.forEach((n=>this._$ET(n, this[n]))),
        this._$EM()
    }
    updated(e) {}
    firstUpdated(e) {}
}
;
Mi.elementStyles = [],
Mi.shadowRootOptions = {
    mode: "open"
},
Mi[jr("elementProperties")] = new Map,
Mi[jr("finalized")] = new Map,
r_?.({
    ReactiveElement: Mi
}),
(Js.reactiveElementVersions ??= []).push("2.1.1");
const Ql = globalThis
  , js = Ql.trustedTypes
  , Qd = js ? js.createPolicy("lit-html", {
    createHTML: i=>i
}) : void 0
  , Hf = "$lit$"
  , qn = `lit$ ${Math.random().toFixed(9).slice(2)}$`
  , Vf = "?" + qn
  , s_ = `<${Vf}>`
  , yi = document
  , $r = ()=>yi.createComment("")
  , qr = i=>i === null || typeof i != "object" && typeof i != "function"
  , Jl = Array.isArray
  , o_ = i=>Jl(i) || typeof i?.[Symbol.iterator] == "function"
  , Xa = `[ 	
\f\r]`
  , Er = /<(?:(!--|\/[^a-zA-Z])|(\/?[a-zA-Z][^>\s]*)|(\/?$))/g
  , Jd = /-->/g
  , Kd = />/g
  , li = RegExp(`>|${Xa}(?:([^\\s"'>=/]+)(${Xa}*=${Xa}*(?:[^ 	
\f\r"'\`<>=]|("|')|))|$)`, "g")
  , Yd = /'/g
  , eh = /"/g
  , Gf = /^(?:script|style|textarea|title)$/i
  , a_ = i=>(e,...n)=>({
    _$litType$: i,
    strings: e,
    values: n
})
  , Ft = a_(1)
  , $i = Symbol.for("lit-noChange")
  , gt = Symbol.for("lit-nothing")
  , th = new WeakMap
  , gi = yi.createTreeWalker(yi, 129);
function Wf(i, e) {
    if (!Jl(i) || !i.hasOwnProperty("raw"))
        throw Error("invalid template strings array");
    return Qd !== void 0 ? Qd.createHTML(e) : e
}
const l_ = (i,e)=>{
    const n = i.length - 1
      , r = [];
    let o, a = e === 2 ? "<svg>" : e === 3 ? "<math>" : "", l = Er;
    for (let u = 0; u < n; u++) {
        const f = i[u];
        let h, m, _ = -1, d = 0;
        for (; d < f.length && (l.lastIndex = d,
        m = l.exec(f),
        m !== null); )
            d = l.lastIndex,
            l === Er ? m[1] === "!--" ? l = Jd : m[1] !== void 0 ? l = Kd : m[2] !== void 0 ? (Gf.test(m[2]) && (o = RegExp("</" + m[2], "g")),
            l = li) : m[3] !== void 0 && (l = li) : l === li ? m[0] === ">" ? (l = o ?? Er,
            _ = -1) : m[1] === void 0 ? _ = -2 : (_ = l.lastIndex - m[2].length,
            h = m[1],
            l = m[3] === void 0 ? li : m[3] === '"' ? eh : Yd) : l === eh || l === Yd ? l = li : l === Jd || l === Kd ? l = Er : (l = li,
            o = void 0);
        const g = l === li && i[u + 1].startsWith("/>") ? " " : "";
        a += l === Er ? f + s_ : _ >= 0 ? (r.push(h),
        f.slice(0, _) + Hf + f.slice(_) + qn + g) : f + qn + (_ === -2 ? u : g)
    }
    return [Wf(i, a + (i[n] || "<?>") + (e === 2 ? "</svg>" : e === 3 ? "</math>" : "")), r]
}
;
let El = class Zf {
    constructor({strings: e, _$litType$: n}, r) {
        let o;
        this.parts = [];
        let a = 0
          , l = 0;
        const u = e.length - 1
          , f = this.parts
          , [h,m] = l_(e, n);
        if (this.el = Zf.createElement(h, r),
        gi.currentNode = this.el.content,
        n === 2 || n === 3) {
            const _ = this.el.content.firstChild;
            _.replaceWith(..._.childNodes)
        }
        for (; (o = gi.nextNode()) !== null && f.length < u; ) {
            if (o.nodeType === 1) {
                if (o.hasAttributes())
                    for (const _ of o.getAttributeNames())
                        if (_.endsWith(Hf)) {
                            const d = m[l++]
                              , g = o.getAttribute(_).split(qn)
                              , b = /([.?@])?(.*)/.exec(d);
                            f.push({
                                type: 1,
                                index: a,
                                name: b[2],
                                strings: g,
                                ctor: b[1] === "." ? c_ : b[1] === "?" ? d_ : b[1] === "@" ? h_ : Ks
                            }),
                            o.removeAttribute(_)
                        } else
                            _.startsWith(qn) && (f.push({
                                type: 6,
                                index: a
                            }),
                            o.removeAttribute(_));
                if (Gf.test(o.tagName)) {
                    const _ = o.textContent.split(qn)
                      , d = _.length - 1;
                    if (d > 0) {
                        o.textContent = js ? js.emptyScript : "";
                        for (let g = 0; g < d; g++)
                            o.append(_[g], $r()),
                            gi.nextNode(),
                            f.push({
                                type: 2,
                                index: ++a
                            });
                        o.append(_[d], $r())
                    }
                }
            } else if (o.nodeType === 8)
                if (o.data === Vf)
                    f.push({
                        type: 2,
                        index: a
                    });
                else {
                    let _ = -1;
                    for (; (_ = o.data.indexOf(qn, _ + 1)) !== -1; )
                        f.push({
                            type: 7,
                            index: a
                        }),
                        _ += qn.length - 1
                }
            a++
        }
    }
    static createElement(e, n) {
        const r = yi.createElement("template");
        return r.innerHTML = e,
        r
    }
}
;
function qi(i, e, n=i, r) {
    if (e === $i)
        return e;
    let o = r !== void 0 ? n._$Co?.[r] : n._$Cl;
    const a = qr(e) ? void 0 : e._$litDirective$;
    return o?.constructor !== a && (o?._$AO?.(!1),
    a === void 0 ? o = void 0 : (o = new a(i),
    o._$AT(i, n, r)),
    r !== void 0 ? (n._$Co ??= [])[r] = o : n._$Cl = o),
    o !== void 0 && (e = qi(i, o._$AS(i, e.values), o, r)),
    e
}
let u_ = class {
    constructor(e, n) {
        this._$AV = [],
        this._$AN = void 0,
        this._$AD = e,
        this._$AM = n
    }
    get parentNode() {
        return this._$AM.parentNode
    }
    get _$AU() {
        return this._$AM._$AU
    }
    u(e) {
        const {el: {content: n}, parts: r} = this._$AD
          , o = (e?.creationScope ?? yi).importNode(n, !0);
        gi.currentNode = o;
        let a = gi.nextNode()
          , l = 0
          , u = 0
          , f = r[0];
        for (; f !== void 0; ) {
            if (l === f.index) {
                let h;
                f.type === 2 ? h = new Kl(a,a.nextSibling,this,e) : f.type === 1 ? h = new f.ctor(a,f.name,f.strings,this,e) : f.type === 6 && (h = new f_(a,this,e)),
                this._$AV.push(h),
                f = r[++u]
            }
            l !== f?.index && (a = gi.nextNode(),
            l++)
        }
        return gi.currentNode = yi,
        o
    }
    p(e) {
        let n = 0;
        for (const r of this._$AV)
            r !== void 0 && (r.strings !== void 0 ? (r._$AI(e, r, n),
            n += r.strings.length - 2) : r._$AI(e[n])),
            n++
    }
}
  , Kl = class Xf {
    get _$AU() {
        return this._$AM?._$AU ?? this._$Cv
    }
    constructor(e, n, r, o) {
        this.type = 2,
        this._$AH = gt,
        this._$AN = void 0,
        this._$AA = e,
        this._$AB = n,
        this._$AM = r,
        this.options = o,
        this._$Cv = o?.isConnected ?? !0
    }
    get parentNode() {
        let e = this._$AA.parentNode;
        const n = this._$AM;
        return n !== void 0 && e?.nodeType === 11 && (e = n.parentNode),
        e
    }
    get startNode() {
        return this._$AA
    }
    get endNode() {
        return this._$AB
    }
    _$AI(e, n=this) {
        e = qi(this, e, n),
        qr(e) ? e === gt || e == null || e === "" ? (this._$AH !== gt && this._$AR(),
        this._$AH = gt) : e !== this._$AH && e !== $i && this._(e) : e._$litType$ !== void 0 ? this.$(e) : e.nodeType !== void 0 ? this.T(e) : o_(e) ? this.k(e) : this._(e)
    }
    O(e) {
        return this._$AA.parentNode.insertBefore(e, this._$AB)
    }
    T(e) {
        this._$AH !== e && (this._$AR(),
        this._$AH = this.O(e))
    }
    _(e) {
        this._$AH !== gt && qr(this._$AH) ? this._$AA.nextSibling.data = e : this.T(yi.createTextNode(e)),
        this._$AH = e
    }
    $(e) {
        const {values: n, _$litType$: r} = e
          , o = typeof r == "number" ? this._$AC(e) : (r.el === void 0 && (r.el = El.createElement(Wf(r.h, r.h[0]), this.options)),
        r);
        if (this._$AH?._$AD === o)
            this._$AH.p(n);
        else {
            const a = new u_(o,this)
              , l = a.u(this.options);
            a.p(n),
            this.T(l),
            this._$AH = a
        }
    }
    _$AC(e) {
        let n = th.get(e.strings);
        return n === void 0 && th.set(e.strings, n = new El(e)),
        n
    }
    k(e) {
        Jl(this._$AH) || (this._$AH = [],
        this._$AR());
        const n = this._$AH;
        let r, o = 0;
        for (const a of e)
            o === n.length ? n.push(r = new Xf(this.O($r()),this.O($r()),this,this.options)) : r = n[o],
            r._$AI(a),
            o++;
        o < n.length && (this._$AR(r && r._$AB.nextSibling, o),
        n.length = o)
    }
    _$AR(e=this._$AA.nextSibling, n) {
        for (this._$AP?.(!1, !0, n); e !== this._$AB; ) {
            const r = e.nextSibling;
            e.remove(),
            e = r
        }
    }
    setConnected(e) {
        this._$AM === void 0 && (this._$Cv = e,
        this._$AP?.(e))
    }
}
;
class Ks {
    get tagName() {
        return this.element.tagName
    }
    get _$AU() {
        return this._$AM._$AU
    }
    constructor(e, n, r, o, a) {
        this.type = 1,
        this._$AH = gt,
        this._$AN = void 0,
        this.element = e,
        this.name = n,
        this._$AM = o,
        this.options = a,
        r.length > 2 || r[0] !== "" || r[1] !== "" ? (this._$AH = Array(r.length - 1).fill(new String),
        this.strings = r) : this._$AH = gt
    }
    _$AI(e, n=this, r, o) {
        const a = this.strings;
        let l = !1;
        if (a === void 0)
            e = qi(this, e, n, 0),
            l = !qr(e) || e !== this._$AH && e !== $i,
            l && (this._$AH = e);
        else {
            const u = e;
            let f, h;
            for (e = a[0],
            f = 0; f < a.length - 1; f++)
                h = qi(this, u[r + f], n, f),
                h === $i && (h = this._$AH[f]),
                l ||= !qr(h) || h !== this._$AH[f],
                h === gt ? e = gt : e !== gt && (e += (h ?? "") + a[f + 1]),
                this._$AH[f] = h
        }
        l && !o && this.j(e)
    }
    j(e) {
        e === gt ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, e ?? "")
    }
}
let c_ = class extends Ks {
    constructor() {
        super(...arguments),
        this.type = 3
    }
    j(e) {
        this.element[this.name] = e === gt ? void 0 : e
    }
}
  , d_ = class extends Ks {
    constructor() {
        super(...arguments),
        this.type = 4
    }
    j(e) {
        this.element.toggleAttribute(this.name, !!e && e !== gt)
    }
}
  , h_ = class extends Ks {
    constructor(e, n, r, o, a) {
        super(e, n, r, o, a),
        this.type = 5
    }
    _$AI(e, n=this) {
        if ((e = qi(this, e, n, 0) ?? gt) === $i)
            return;
        const r = this._$AH
          , o = e === gt && r !== gt || e.capture !== r.capture || e.once !== r.once || e.passive !== r.passive
          , a = e !== gt && (r === gt || o);
        o && this.element.removeEventListener(this.name, this, r),
        a && this.element.addEventListener(this.name, this, e),
        this._$AH = e
    }
    handleEvent(e) {
        typeof this._$AH == "function" ? this._$AH.call(this.options?.host ?? this.element, e) : this._$AH.handleEvent(e)
    }
}
  , f_ = class {
    constructor(e, n, r) {
        this.element = e,
        this.type = 6,
        this._$AN = void 0,
        this._$AM = n,
        this.options = r
    }
    get _$AU() {
        return this._$AM._$AU
    }
    _$AI(e) {
        qi(this, e)
    }
}
;
const p_ = Ql.litHtmlPolyfillSupport;
p_?.(El, Kl),
(Ql.litHtmlVersions ??= []).push("3.3.1");
const g_ = (i,e,n)=>{
    const r = n?.renderBefore ?? e;
    let o = r._$litPart$;
    if (o === void 0) {
        const a = n?.renderBefore ?? null;
        r._$litPart$ = o = new Kl(e.insertBefore($r(), a),a,void 0,n ?? {})
    }
    return o._$AI(i),
    o
}
;
const Yl = globalThis;
class Hn extends Mi {
    constructor() {
        super(...arguments),
        this.renderOptions = {
            host: this
        },
        this._$Do = void 0
    }
    createRenderRoot() {
        const e = super.createRenderRoot();
        return this.renderOptions.renderBefore ??= e.firstChild,
        e
    }
    update(e) {
        const n = this.render();
        this.hasUpdated || (this.renderOptions.isConnected = this.isConnected),
        super.update(e),
        this._$Do = g_(n, this.renderRoot, this.renderOptions)
    }
    connectedCallback() {
        super.connectedCallback(),
        this._$Do?.setConnected(!0)
    }
    disconnectedCallback() {
        super.disconnectedCallback(),
        this._$Do?.setConnected(!1)
    }
    render() {
        return $i
    }
}
Hn._$litElement$ = !0,
Hn.finalized = !0,
Yl.litElementHydrateSupport?.({
    LitElement: Hn
});
const m_ = Yl.litElementPolyfillSupport;
m_?.({
    LitElement: Hn
});
(Yl.litElementVersions ??= []).push("4.2.1");
const _n = i=>(e,n)=>{
    n !== void 0 ? n.addInitializer((()=>{
        customElements.define(i, e)
    }
    )) : customElements.define(i, e)
}
;
const __ = {
    attribute: !0,
    type: String,
    converter: Fs,
    reflect: !1,
    hasChanged: Xl
}
  , y_ = (i=__,e,n)=>{
    const {kind: r, metadata: o} = n;
    let a = globalThis.litPropertyMetadata.get(o);
    if (a === void 0 && globalThis.litPropertyMetadata.set(o, a = new Map),
    r === "setter" && ((i = Object.create(i)).wrapped = !0),
    a.set(n.name, i),
    r === "accessor") {
        const {name: l} = n;
        return {
            set(u) {
                const f = e.get.call(this);
                e.set.call(this, u),
                this.requestUpdate(l, f, i)
            },
            init(u) {
                return u !== void 0 && this.C(l, void 0, i, u),
                u
            }
        }
    }
    if (r === "setter") {
        const {name: l} = n;
        return function(u) {
            const f = this[l];
            e.call(this, u),
            this.requestUpdate(l, f, i)
        }
    }
    throw Error("Unsupported decorator location: " + r)
}
;
function De(i) {
    return (e,n)=>typeof n == "object" ? y_(i, e, n) : ((r,o,a)=>{
        const l = o.hasOwnProperty(a);
        return o.constructor.createProperty(a, r),
        l ? Object.getOwnPropertyDescriptor(o, a) : void 0
    }
    )(i, e, n)
}
function Ys(i) {
    return De({
        ...i,
        state: !0,
        attribute: !1
    })
}
const v_ = (i,e,n)=>(n.configurable = !0,
n.enumerable = !0,
Reflect.decorate && typeof e != "object" && Object.defineProperty(i, e, n),
n);
function zt(i, e) {
    return (n,r,o)=>{
        const a = l=>l.renderRoot?.querySelector(i) ?? null;
        return v_(n, r, {
            get() {
                return a(this)
            }
        })
    }
}
var Qf = i=>{
    throw TypeError(i)
}
  , Jf = (i,e,n)=>e.has(i) || Qf("Cannot " + n)
  , Bn = (i,e,n)=>(Jf(i, e, "read from private field"),
n ? n.call(i) : e.get(i))
  , b_ = (i,e,n)=>e.has(i) ? Qf("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, n)
  , w_ = (i,e,n,r)=>(Jf(i, e, "write to private field"),
e.set(i, n),
n)
  , x_ = Object.defineProperty
  , Wn = (i,e,n,r)=>{
    for (var o = void 0, a = i.length - 1, l; a >= 0; a--)
        (l = i[a]) && (o = l(e, n, o) || o);
    return o && x_(e, n, o),
    o
}
;
const Sl = class extends Hn {
    constructor() {
        super(...arguments),
        this.dense = !1
    }
}
;
Sl.shadowRootOptions = {
    ...Hn.shadowRootOptions,
    delegatesFocus: !0
},
Sl.styles = [Jt`
    :host {
        /* color-scheme: light dark; */
        --rokit-primary-color-inner: var(--rokit-primary-color, #008877);
        --rokit-primary-color-transparent-inner: color-mix(in srgb, var(--rokit-primary-color-inner) 20%, transparent);
        --rokit-error-color-inner: var(--rokit-error-color, #F03333);
        /*--rokit-background-color-inner: var(--rokit-background-color, #242424);*/
        --rokit-background-color-inner: var(--rokit-background-color, #FFF);
        --rokit-light-background-color-inner: var(--rokit-light-background-color, color-mix(in srgb, var(--rokit-background-color-inner) 97%, currentColor));
        --rokit-light-background-darker-color-inner: var(--rokit-light-background-darker-color, color-mix(in srgb, var(--rokit-light-background-color-inner) 80%, currentColor));
        --rokit-shadow-color-inner: var(--rokit-shadow-color, color-mix(in srgb, currentColor 40%, transparent));
        --rokit-list-indent-inner: var(--rokit-list-indent, 1em);
        --rokit-list-max-height-inner: var(--rokit-list-max-height, 300);
        --rokit-caret-size-inner: var(--rokit-caret-size, 0.5em);
        --rokit-transition-duration-inner: var(--rokit-transition-duration, 0.2s);
    }
    `];
let ln = Sl;
Wn([De({
    type: Boolean,
    reflect: !0
})], ln.prototype, "dense");
var rn;
const Tl = class extends ln {
    constructor() {
        super(),
        b_(this, rn),
        this.value = "",
        this.clearable = !1,
        this.required = !1,
        this.disabled = !1,
        w_(this, rn, this.attachInternals())
    }
    checkValidity() {
        return Bn(this, rn).checkValidity()
    }
    reportValidity() {
        const e = Bn(this, rn).reportValidity();
        return this.classList.toggle("invalid", !e),
        e
    }
    get validity() {
        return Bn(this, rn).validity
    }
    get validationMessage() {
        return Bn(this, rn).validationMessage
    }
    setCustomValidity(e, n) {
        e ? Bn(this, rn).setValidity({
            customError: !0
        }, e, n) : Bn(this, rn).setValidity(void 0)
    }
    updateValidity(e, n, r) {
        Bn(this, rn).setValidity(e, n, r)
    }
    setFormValue(e, n) {
        Bn(this, rn).setFormValue(e, n)
    }
}
;
rn = new WeakMap,
Tl.formAssociated = !0,
Tl.styles = [...ln.styles, Jt`
    :host { display: inline-flex; align-items: center; padding: 6px 8px; border-bottom: 2px solid var(--rokit-light-background-darker-color-inner); box-sizing: border-box; position: relative; }
    :host(:focus) { border-color: var(--rokit-primary-color-inner); }
    :host(.invalid) { border-color: var(--rokit-error-color-inner); }
    `];
let un = Tl;
Wn([De()], un.prototype, "name");
Wn([De()], un.prototype, "value");
Wn([De({
    type: Boolean
})], un.prototype, "clearable");
Wn([De({
    type: Boolean
})], un.prototype, "required");
Wn([De({
    type: Boolean
})], un.prototype, "disabled");
Wn([De()], un.prototype, "label");
Wn([De()], un.prototype, "placeholder");
function Kf(i) {
    const e = parseFloat(i)
      , n = i.match(/m?s/);
    let r = 0;
    if (n)
        switch (n[0]) {
        case "s":
            r = e * 1e3;
            break;
        case "ms":
            r = e;
            break;
        default:
            r = 0;
            break
        }
    return r
}
var E_ = Object.defineProperty
  , S_ = Object.getOwnPropertyDescriptor
  , eo = (i,e,n,r)=>{
    for (var o = r > 1 ? void 0 : r ? S_(e, n) : e, a = i.length - 1, l; a >= 0; a--)
        (l = i[a]) && (o = (r ? l(e, n, o) : l(o)) || o);
    return r && o && E_(e, n, o),
    o
}
;
let Nn = class extends ln {
    constructor() {
        super(...arguments),
        this.icon = !1,
        this.disabled = !1,
        this.href = ""
    }
    render() {
        return this.href ? Ft`<a part="button" class="button" href="${this.disabled ? "" : this.href}"><slot></slot></a>` : Ft`<button part="button" class="button" ?disabled="${this.disabled}"><slot></slot></button>`
    }
}
;
Nn.styles = [...ln.styles, Jt`
    :host { display: inline-flex; }
    :host([disabled]) { pointer-events: none; opacity: 0.5; }
    :host([dense]) { font-size: 0.8em; }
    :host([rounded]) .button { border-radius: 200px; }
    :host([primary]) .button { color: white; background-color: var(--rokit-primary-color-inner); }
    :host([primary][text]) .button { color: var(--rokit-primary-color-inner); }
    :host([primary]:not([text])) .button:hover { filter: brightness(115%); }
    :host([text]) .button { background-color: inherit; border-color: transparent }
    :host([icon]) .button { width: 2em; height: 2em; border-radius: 50%; border-color: transparent; background-color: inherit; }
    :host([icon]) .button:hover, :host([text]) .button:hover { background-color: transparent; backdrop-filter: invert(20%) }
    :host(.clear) .button:before { content: '\u2715'; }
    :host(.caret) .button:before {
        content: '';
        position: absolute;
        width: var(--rokit-caret-size-inner);
        height: var(--rokit-caret-size-inner);
        border-color: currentColor;
        border-style: none solid solid none;
        border-width: calc(0.2 * var(--rokit-caret-size-inner));
        transform: translate(0, -0.15em) rotate(45deg);
        transition: transform var(--rokit-transition-duration-inner) ease-out;
    }
    :host(.caret.down) .button:before { transform: translate(0, 0.15em) rotate(225deg); }
    :host(.caret.right) .button:before { transform: translate(-0.15em, 0) rotate(-45deg); }
    :host(.loading) .button:before {
        content: '';
        width: 0.7em;
        height: 0.7em;
        border: 0.15em solid;
        border-bottom-color: transparent;
        border-radius: 50%;
        animation: rotation 0.8s linear infinite;
    }
    .button {
        display: inline-flex;
        flex-grow: 1;
        gap: 0.5em;
        align-items: center;
        justify-content: center;
        text-decoration: none;
        cursor: pointer;
        white-space: nowrap;
        overflow: hidden;
        line-height: 1.2em;
        font-family: inherit;
        font-size: inherit;
        font-weight: 500;
        color: inherit;
        padding: 8px 10px;
        background-color: var(--rokit-light-background-color-inner);
        border: 1px solid var(--rokit-light-background-darker-color-inner);
        border-radius: 3px;
    }
    .button:hover { filter: brightness(102%); }
    @keyframes rotation {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
    `];
eo([De({
    type: Boolean,
    reflect: !0
})], Nn.prototype, "icon", 2);
eo([De({
    type: Boolean,
    reflect: !0
})], Nn.prototype, "disabled", 2);
eo([De()], Nn.prototype, "href", 2);
Nn = eo([_n("rokit-button")], Nn);
var T_ = Object.defineProperty, L_ = Object.getOwnPropertyDescriptor, Yf = i=>{
    throw TypeError(i)
}
, yn = (i,e,n,r)=>{
    for (var o = r > 1 ? void 0 : r ? L_(e, n) : e, a = i.length - 1, l; a >= 0; a--)
        (l = i[a]) && (o = (r ? l(e, n, o) : l(o)) || o);
    return r && o && T_(e, n, o),
    o
}
, I_ = (i,e,n)=>e.has(i) || Yf("Cannot " + n), nh = (i,e,n)=>(I_(i, e, "read from private field"),
n ? n.call(i) : e.get(i)), N_ = (i,e,n)=>e.has(i) ? Yf("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, n), Ns;
let Ct = class extends ln {
    constructor() {
        super(...arguments),
        this.open = !1,
        this.disabled = !1,
        this.headerInactive = !1,
        this.transitioning = !1,
        this.closedBeforeTransition = !1,
        N_(this, Ns, new MutationObserver(()=>this.updateContentHeight())),
        this.onMouseDown = (()=>{
            this.closedBeforeTransition = !this.open && !this.transitioning
        }
        ).bind(this),
        this.onClickToggles = (()=>{
            this.toggle(this.closedBeforeTransition, !0)
        }
        ).bind(this),
        this.onClickOpens = (()=>{
            this.toggle(!0, !0)
        }
        ).bind(this)
    }
    firstUpdated() {
        this.transitionDuration = Kf(getComputedStyle(this).getPropertyValue("--rokit-transition-duration-inner")),
        new IntersectionObserver(i=>{
            i.length && i[0].isIntersecting && this.updateContentHeight()
        }
        ).observe(this)
    }
    updated(i) {
        i.has("transitioning") && this.classList.toggle("transitioning", this.transitioning),
        (i.has("disabled") || i.has("headerInactive")) && (this.disabled ? (this.header.removeEventListener("mousedown", this.onMouseDown),
        this.header.removeEventListener("click", this.onClickToggles),
        this.header.removeEventListener("click", this.onClickOpens),
        this.toggleButton.removeEventListener("mousedown", this.onMouseDown),
        this.toggleButton.removeEventListener("click", this.onClickToggles)) : this.headerInactive ? (this.toggleButton.addEventListener("mousedown", this.onMouseDown),
        this.toggleButton.addEventListener("click", this.onClickToggles),
        this.header.addEventListener("click", this.onClickOpens)) : (this.header.addEventListener("mousedown", this.onMouseDown),
        this.header.addEventListener("click", this.onClickToggles))),
        i.has("open") && !this.transitioning && !this.disabled && this.toggle(this.open)
    }
    updateContentHeight() {
        setTimeout(()=>{
            this.content.style.maxHeight = (this.maxHeight !== void 0 ? Math.min(this.maxHeight, this.content.scrollHeight) : this.content.scrollHeight) + "px",
            this.classList.toggle("has-content", this.content.style.maxHeight !== "0px")
        }
        )
    }
    onSlotChange() {
        const i = this.shadowRoot.querySelector("#content > slot").assignedNodes();
        nh(this, Ns).disconnect();
        for (const e of i)
            nh(this, Ns).observe(e, {
                subtree: !0,
                childList: !0,
                characterData: !0,
                attributes: !0
            });
        this.updateContentHeight()
    }
    toggle(i=!this.open, e=!1) {
        this.disabled || (this.transitioning = this.open !== i,
        this.open = i,
        this.toggleButton.classList.toggle("down", i),
        setTimeout(()=>{
            this.transitioning = !1,
            this.open && e && this.content.scrollIntoView({
                block: "nearest"
            })
        }
        , this.transitionDuration))
    }
    render() {
        return Ft`
            <header part="header">
                <slot name="prefix" part="prefix"></slot>
                <span class="label"><slot name="label" part="label">${this.label}</slot></span>
                <slot name="pre-suffix" part="suffix"></slot>
                <rokit-button id="toggle" part="toggle" class="caret" icon ?dense="${this.dense}" title="${this.open ? "Collapse" : "Expand"}"></rokit-button>
                <slot name="suffix" part="suffix"></slot>
            </header>
            <div id="content" part="content">
                <slot @slotchange=${this.onSlotChange}></slot>
            </div>
        `
    }
}
;
Ns = new WeakMap;
Ct.styles = [...ln.styles, Jt`
        :host { display: flex; flex-direction: column; align-items: stretch; border-bottom: 2px solid var(--rokit-light-background-darker-color-inner); }
        :host header { cursor: pointer; }
        :host([dense]) header { padding: 2px 4px; }
        :host([maxheight]) #content { overflow:auto }
        :host(:not([open])) #content { max-height: 0 !important; }
        :host(:not([open])) #content, :host(.transitioning) #content { overflow: hidden !important; }
        :host([open]) #content, :host(.transitioning) #content { padding-top: 4px; }
        header { display: flex; align-items: center; padding: 6px 8px; background-color: var(--rokit-light-background-color-inner); user-select: none; }
        .label { flex-grow: 1; overflow: hidden; }
        #content { display: flex; transition: max-height var(--rokit-transition-duration-inner) ease-in-out; position: relative; scrollbar-width: thin; }
        #toggle { margin-left: 3px; }
    `];
yn([De({
    type: Boolean,
    reflect: !0
})], Ct.prototype, "open", 2);
yn([De()], Ct.prototype, "label", 2);
yn([De({
    reflect: !0
})], Ct.prototype, "maxHeight", 2);
yn([De({
    type: Boolean
})], Ct.prototype, "disabled", 2);
yn([De({
    type: Boolean
})], Ct.prototype, "headerInactive", 2);
yn([zt("#content")], Ct.prototype, "content", 2);
yn([zt("#toggle")], Ct.prototype, "toggleButton", 2);
yn([zt("header")], Ct.prototype, "header", 2);
yn([Ys()], Ct.prototype, "transitioning", 2);
Ct = yn([_n("rokit-collapsible")], Ct);
var A_ = Object.defineProperty, R_ = Object.getOwnPropertyDescriptor, ep = i=>{
    throw TypeError(i)
}
, jt = (i,e,n,r)=>{
    for (var o = r > 1 ? void 0 : r ? R_(e, n) : e, a = i.length - 1, l; a >= 0; a--)
        (l = i[a]) && (o = (r ? l(e, n, o) : l(o)) || o);
    return r && o && A_(e, n, o),
    o
}
, tp = (i,e,n)=>e.has(i) || ep("Cannot " + n), C_ = (i,e,n)=>(tp(i, e, "read from private field"),
e.get(i)), k_ = (i,e,n)=>e.has(i) ? ep("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, n), ih = (i,e,n,r)=>(tp(i, e, "write to private field"),
e.set(i, n),
n), kr;
let dt = class extends un {
    constructor() {
        super(),
        this.type = "text",
        this.readonly = !1,
        this.sticky = !1,
        this.minWidth = 80,
        this.autoGrowLabelWidth = !1,
        k_(this, kr, ""),
        this.addEventListener("keydown", i=>{
            i.code === "Escape" && this.blur()
        }
        ),
        this.addEventListener("focus", ()=>{
            this.classList.add("has-focus")
        }
        ),
        this.addEventListener("blur", ()=>{
            this.inputElement.scrollLeft = 0,
            this.classList.remove("has-focus")
        }
        )
    }
    firstUpdated() {
        ih(this, kr, this.value),
        this.inputElement.addEventListener("change", ()=>{
            this.value = this.inputElement.value
        }
        ),
        this.autoGrowLabelWidth && new IntersectionObserver(i=>{
            i.length && i[0].isIntersecting && this.updateMinWidth()
        }
        ).observe(this)
    }
    updateMinWidth() {
        const i = this.shadowRoot.querySelector(".wrapper");
        if (i) {
            const e = this.shadowRoot?.querySelector("label")?.scrollWidth || 0
              , n = this.minWidth > e ? this.minWidth : e;
            i.style.minWidth = n > 0 ? n + "px" : ""
        }
    }
    updated(i) {
        i.has("label") && (this.classList.toggle("has-label", this.label !== void 0),
        this.autoGrowLabelWidth && this.updateMinWidth()),
        i.has("min") && (this.inputElement.min = this.min || ""),
        i.has("max") && (this.inputElement.max = this.max || ""),
        i.has("step") && (this.inputElement.step = this.step || ""),
        i.has("placeholder") && (this.inputElement.placeholder = this.placeholder || ""),
        i.has("pattern") && (this.inputElement.pattern = this.pattern || ""),
        i.has("minLength") && (this.inputElement.minLength = this.minLength === void 0 ? -1 : this.minLength),
        i.has("maxLength") && (this.inputElement.maxLength = this.maxLength === void 0 ? -1 : this.maxLength),
        i.has("value") && (this.classList.toggle("has-value", this.value !== ""),
        this.setFormValue(this.value),
        this.updateValidity(this.inputElement.validity, this.inputElement.validationMessage, this.inputElement),
        this.value !== C_(this, kr) && (ih(this, kr, this.value),
        this.dispatchEvent(new CustomEvent("change",{
            bubbles: !0
        }))))
    }
    clear() {
        this.inputElement.value = "",
        this.value = "",
        this.blur()
    }
    renderInput() {
        return Ft`<input id="input" part="input" size="1" name="${this.name}" type="${this.type}" autocomplete="off" ?disabled="${this.disabled}" ?readonly="${this.readonly}" ?required="${this.required}" .value="${this.type === "file" ? "" : this.value}">`
    }
    render() {
        return Ft`
            <slot name="prefix" part="prefix"></slot>
            <div class="wrapper">
                <label for="input" part="label">${this.label}</label>
                ${this.renderInput()}
                ${this.clearable ? Ft`
                    <rokit-button class="clear" icon ?dense="${this.dense}" @mousedown="${i=>{
            i.preventDefault()
        }
        }" @click="${i=>{
            i.stopPropagation(),
            this.clear()
        }
        }" title="Clear"></rokit-button>
                ` : gt}
            </div>
            <slot name="suffix" part="suffix"></slot>
            <div class="supporting-text" part="supportingText">
                <slot name="supportingText">${this.supportingText}</slot>
            </div>
        `
    }
}
;
kr = new WeakMap;
dt.styles = [...un.styles, Jt`
        :host { background-color: var(--rokit-light-background-color-inner); user-select: none; flex-wrap: wrap; }
        :host([dense]) { padding: 2px 4px; }
        :host(.has-focus:not([readonly])) label, :host(.has-value) label, :host([sticky]) label { font-size: 0.75em; top: 0.5em; font-weight: 600; }
        :host(.has-focus) label { color: var(--rokit-primary-color-inner); }
        .wrapper { display: flex; position: relative; flex-grow: 1; align-items: center; }
        label { position: absolute; top: 50%; transform: translate(0, -50%); transition-property: top, font-size; transition-duration: var(--rokit-transition-duration-inner); max-width: 100%; overflow: hidden; pointer-events: none; white-space: nowrap; }
        #input { height: 1.3em; border: 0; outline: 0; flex-grow: 1; font-size: 1em; background: none; padding: 0; color: currentColor; font-family: inherit; text-overflow: ellipsis; }
        #input[type='file'] { padding-bottom: 3px; }
        #input[readonly] { caret-color: transparent; }
        #input[readonly]::placeholder { color: transparent; }
        :host(.has-label) #input { margin-top: 0.9em; }
        :host(.has-label:not(.has-focus):not(.has-value):not([sticky])) #input { clip-path: polygon(0 0, 0 0, 0 0, 0 0); }
        :host(:not(.has-value)) .clear { visibility: hidden; }
        .supporting-text { width: 100%; font-size: 0.8em; }
    `];
jt([De()], dt.prototype, "type", 2);
jt([De({
    type: Boolean,
    reflect: !0
})], dt.prototype, "readonly", 2);
jt([De({
    type: Boolean,
    reflect: !0
})], dt.prototype, "sticky", 2);
jt([De()], dt.prototype, "pattern", 2);
jt([De()], dt.prototype, "minLength", 2);
jt([De()], dt.prototype, "maxLength", 2);
jt([De()], dt.prototype, "min", 2);
jt([De()], dt.prototype, "max", 2);
jt([De()], dt.prototype, "step", 2);
jt([De()], dt.prototype, "minWidth", 2);
jt([De({
    type: Boolean
})], dt.prototype, "autoGrowLabelWidth", 2);
jt([De()], dt.prototype, "supportingText", 2);
jt([zt("#input")], dt.prototype, "inputElement", 2);
dt = jt([_n("rokit-input")], dt);
var P_ = Object.defineProperty, M_ = Object.getOwnPropertyDescriptor, np = i=>{
    throw TypeError(i)
}
, Et = (i,e,n,r)=>{
    for (var o = r > 1 ? void 0 : r ? M_(e, n) : e, a = i.length - 1, l; a >= 0; a--)
        (l = i[a]) && (o = (r ? l(e, n, o) : l(o)) || o);
    return r && o && P_(e, n, o),
    o
}
, ip = (i,e,n)=>e.has(i) || np("Cannot " + n), ws = (i,e,n)=>(ip(i, e, "read from private field"),
n ? n.call(i) : e.get(i)), Qa = (i,e,n)=>e.has(i) ? np("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, n), xs = (i,e,n,r)=>(ip(i, e, "write to private field"),
e.set(i, n),
n), Di, As, Rs;
let ht = class extends un {
    constructor() {
        super(),
        this.emptyMessage = "Nothing to select",
        this.collapsibleOrientationLeft = "0",
        this.collapsibleOrientationRight = "0",
        this.collapsibleWidth = "",
        this.autoGrowLabelWidth = !1,
        this.collapse = !1,
        this.filterableThreshold = 15,
        this.itemCount = 0,
        this.toggleOnHeaderClick = !0,
        Qa(this, Di, ""),
        Qa(this, As, ""),
        Qa(this, Rs, new MutationObserver(()=>this.onSlotChange())),
        this.addEventListener("focus", ()=>{
            this.collapsible.toggle(!0)
        }
        ),
        this.addEventListener("blur", ()=>{
            this.checkInputValue(),
            this.collapsible.toggle(!1)
        }
        ),
        this.addEventListener("input", ()=>{
            this.collapsible.toggle(!0)
        }
        )
    }
    firstUpdated() {
        xs(this, Di, this.value),
        xs(this, As, getComputedStyle(this).getPropertyValue("--rokit-list-indent-inner")),
        this.input.placeholder = this.placeholder === void 0 ? "Type to filter list..." : this.placeholder,
        this.input.label = this.label,
        this.inputMinWidth !== void 0 && (this.input.minWidth = this.inputMinWidth),
        setTimeout(()=>{
            this.collapsible.maxHeight = parseInt(this.collapsibleMaxHeight !== void 0 ? this.collapsibleMaxHeight : getComputedStyle(this).getPropertyValue("--rokit-list-max-height-inner")),
            this.collapsible.content.style.width = this.collapsibleWidth,
            this.collapsible.content.style.left = this.collapsibleOrientationLeft,
            this.collapsible.content.style.right = this.collapsibleOrientationRight
        }
        )
    }
    updated(i) {
        if (i.has("selectedItem")) {
            const e = this.value;
            this.value = this.selectedItem ? this.itemValue(this.selectedItem) : "",
            this.input.value = this.selectedItem ? this.itemText(this.selectedItem) : this.value,
            this.title || (this.input.title = this.input.value),
            this.classList.toggle("has-value", this.value !== ""),
            this.setFormValue(this.value),
            this.required && this.value === "" ? this.updateValidity({
                valueMissing: !0
            }, "Please select a value", this.listContainer) : this.updateValidity(),
            e !== this.value && this.dispatchEvent(new CustomEvent("change",{
                bubbles: !0
            }))
        }
        i.has("value") && this.selectItem(this.findItem(this.value)),
        i.has("disabled") && (this.input.disabled = this.disabled,
        this.collapsible.disabled = this.disabled),
        i.has("supportingText") && (this.input.supportingText = this.supportingText),
        (i.has("filterableThreshold") || i.has("itemCount")) && (this.input.readonly = this.filterableThreshold < 0 || this.itemCount < this.filterableThreshold,
        this.toggleOnHeaderClick = this.input.readonly),
        this.collapsible?.toggleButton && (this.collapsible.toggleButton.style.display = this.listContainer.childElementCount === 0 ? "none" : "")
    }
    checkInputValue(i=!0) {
        if (this.input.value) {
            if (this.selectedItem && this.itemText(this.selectedItem) === this.input.value)
                return;
            const e = this.findItem(this.input.value);
            if (e) {
                this.selectItem(e);
                return
            }
        }
        i && (this.input.value = "",
        this.input.title = "",
        xs(this, Di, ""),
        this.selectItem(null, !1))
    }
    filter(i) {
        i = i.toLowerCase();
        let e = !0;
        for (const n of this.listContainer.querySelectorAll("li"))
            if (n.id !== "noresult") {
                const r = this.itemText(n).toLowerCase().indexOf(i) == -1;
                n.classList.toggle("hidden", r),
                this.collapse && (n.classList.remove("open"),
                n.querySelector("ul")?.classList.remove("open")),
                r || (e = !1)
            }
        for (const n of this.listContainer.querySelectorAll("li:has(li:not(.hidden))"))
            n.classList.remove("hidden"),
            i && this.collapse && (n.classList.add("open"),
            n.querySelector("ul")?.classList.add("open")),
            e = !1;
        this.highlightItem(null),
        this.listContainer.querySelector("#noresult")?.classList.toggle("hidden", !e)
    }
    selectItem(i, e=!0) {
        i?.getAttribute("disabled") !== null && (i = null),
        this.selectedItem = i,
        this.filter(""),
        this.highlightItem(i, !1),
        e && this.value && xs(this, Di, this.value),
        setTimeout(()=>this.blur())
    }
    findItem(i) {
        let e = null;
        if (i)
            for (const n of this.listContainer.querySelectorAll("li")) {
                if (n.dataset.value === i)
                    return n;
                this.itemText(n) === i && (e = n)
            }
        return e
    }
    highlightItem(i, e=!0) {
        if (this.listContainer.querySelector("li.active")?.classList.remove("active"),
        i) {
            if (e && this.listContainer.focus(),
            i.classList.add("active"),
            this.collapse)
                for (let n = i.closest("ul"); n; n = n.parentElement.closest("ul"))
                    n.classList.add("open"),
                    n.closest("li")?.classList.add("open");
            this.collapsible.open && i.scrollIntoView({
                block: "nearest"
            })
        }
    }
    highlightNextItem() {
        const i = this.listContainer.querySelector("li.active");
        let e = i;
        const n = this.listContainer.querySelectorAll("ul.open > li:not([disabled]):not(.hidden):not(.divider)");
        if (i) {
            for (let r = 0; r < n.length; r++)
                if (n[r] === i && r < n.length - 1) {
                    e = n[r + 1];
                    break
                }
        } else
            n.length > 0 && (e = n[0]);
        this.highlightItem(e)
    }
    highlightPreviousItem() {
        const i = this.listContainer.querySelector("li.active");
        let e = null;
        if (i) {
            const n = this.listContainer.querySelectorAll("ul.open > li:not([disabled]):not(.hidden):not(.divider)");
            for (let r = 0; r < n.length; r++)
                if (n[r] === i && r > 0) {
                    e = n[r - 1];
                    break
                }
        }
        this.highlightItem(e),
        e || this.input.focus()
    }
    itemValue(i) {
        return i.dataset.value || this.itemText(i) || ""
    }
    itemText(i) {
        return i.querySelector("div > div")?.innerText || ""
    }
    elementText(i) {
        let e = "";
        for (const n of i.childNodes)
            n.nodeType == 3 && (e += n.nodeValue?.trim());
        return e
    }
    onSlotChange() {
        this.listContainer.replaceChildren(),
        this.itemCount = 0;
        let i = null;
        const e = this.shadowRoot.querySelector("#list-container-slot").assignedElements();
        if (e?.length === 1 && (i = Array.prototype.slice.call(e[0].querySelectorAll(":scope > li")),
        this.copyItems(i, this.listContainer),
        ws(this, Rs).disconnect(),
        ws(this, Rs).observe(e[0], {
            subtree: !0,
            childList: !0,
            characterData: !0,
            attributes: !0
        })),
        this.emptyMessage) {
            const n = document.createElement("li");
            n.id = "noresult",
            n.setAttribute("disabled", ""),
            n.innerText = this.emptyMessage,
            this.listContainer.appendChild(n),
            i && i.length > 0 && n.classList.add("hidden")
        }
        this.value = this.value || ws(this, Di),
        this.selectItem(this.findItem(this.value))
    }
    copyItems(i, e, n=0) {
        if (this.sort !== void 0) {
            const o = this.sort || "asc";
            i = i.sort((a,l)=>o === "desc" ? (this.elementText(l) || this.itemValue(l)).localeCompare(this.elementText(a) || this.itemValue(a)) : (this.elementText(a) || this.itemValue(a)).localeCompare(this.elementText(l) || this.itemValue(l)))
        }
        let r = "";
        n > 0 && (r = `calc(0.3em + ${n}*${ws(this, As)})`);
        for (const o of i) {
            const a = o.cloneNode();
            a.replaceChildren();
            const l = document.createElement("div");
            r && (l.style.paddingLeft = r);
            const u = document.createElement("div");
            l.appendChild(u);
            for (const h of o.childNodes)
                if (h.nodeName !== "UL") {
                    const m = h.cloneNode(!0);
                    m.nodeType === 3 && m.nodeValue && (m.nodeValue = m.nodeValue.trim()),
                    u.appendChild(m)
                }
            a.appendChild(l),
            a.title = a.title || this.itemText(a);
            const f = o.querySelector("ul");
            if (f?.childElementCount) {
                const h = document.createElement("ul");
                if (a.appendChild(h),
                this.copyItems(Array.prototype.slice.call(f.children), h, n + 1),
                this.collapse) {
                    const m = new Nn;
                    m.dense = !0,
                    m.icon = !0,
                    m.classList.add("toggle-node", "caret"),
                    m.addEventListener("click", _=>{
                        _.stopPropagation(),
                        a.classList.toggle("open"),
                        h.classList.toggle("open"),
                        this.collapsible.updateContentHeight()
                    }
                    ),
                    l.prepend(m)
                } else
                    h.classList.add("open")
            }
            e.appendChild(a),
            this.itemCount++
        }
    }
    render() {
        return Ft`
            <rokit-collapsible ?dense="${this.dense}" part="collapsible" ?headerInactive="${!this.toggleOnHeaderClick}">
                <slot name="prefix" part="prefix" slot="prefix"></slot>
                <slot name="suffix" part="suffix" slot="suffix"></slot>
                <rokit-input id="input" slot="label" exportparts="supportingText"
                    ?clearable="${this.clearable}"
                    ?dense="${this.dense}"
                    @change="${()=>{
            this.checkInputValue(this.input.inputElement.value === "" || !this.collapsible.open)
        }
        }"
                    @input="${()=>{
            this.filter(this.input.inputElement.value)
        }
        }"
                    ?autoGrowLabelWidth="${this.autoGrowLabelWidth}"
                    @keydown="${i=>{
            switch (i.code) {
            case "ArrowDown":
                i.preventDefault(),
                this.highlightNextItem();
                break;
            case "Enter":
                {
                    const e = this.findItem(this.input.value);
                    e ? this.selectItem(e) : this.filter(this.input.value);
                    break
                }
            }
        }
        }"
                ></rokit-input>
                <ul id="list-container" tabindex="-1" part="list" class="open"
                    @mousedown="${i=>{
            i.preventDefault()
        }
        }"
                    @click="${i=>{
            const e = i.target.closest("li");
            e && e.getAttribute("disabled") === null && !e.classList.contains("divider") && this.selectItem(e)
        }
        }"
                    @keydown="${i=>{
            switch (i.code) {
            case "Enter":
                this.selectItem(this.listContainer.querySelector("li.active"));
                break;
            case "ArrowDown":
                i.preventDefault(),
                this.highlightNextItem();
                break;
            case "ArrowUp":
                i.preventDefault(),
                this.highlightPreviousItem();
                break;
            case "ArrowRight":
                if (this.collapse) {
                    const e = this.listContainer.querySelector("li.active");
                    e && (i.preventDefault(),
                    e.classList.add("open"),
                    e.querySelector("ul")?.classList.add("open"),
                    this.collapsible.updateContentHeight())
                }
                break;
            case "ArrowLeft":
                if (this.collapse) {
                    const e = this.listContainer.querySelector("li.active");
                    e && (i.preventDefault(),
                    e.classList.remove("open"),
                    e.querySelector("ul")?.classList.remove("open"),
                    this.collapsible.updateContentHeight())
                }
                break;
            case "Escape":
                this.listContainer.blur();
                break
            }
        }
        }">
                </ul>
                <slot id="list-container-slot" @slotchange=${this.onSlotChange}></slot>
            </rokit-collapsible>
        `
    }
}
;
Di = new WeakMap;
As = new WeakMap;
Rs = new WeakMap;
ht.styles = [...un.styles, Jt`
        :host { background-color: var(--rokit-light-background-color-inner); user-select: none; padding: 0; }
        :host([dense]) li > div { padding: 4px 2px; }
        :host([dense]) li.large > div, :host([dense]) li.header > div { padding-top: 6px; padding-bottom: 6px; }
        #input { padding: 0; background-color: inherit; }
        rokit-collapsible, #input { display: flex; flex-grow: 1; border: 0; }
        rokit-collapsible::part(content) { display: flex; flex-direction: column; padding-top: 0; outline: 0; z-index: 1000; position: absolute; top: calc(100% + 2px); background-color: var(--rokit-background-color-inner); }
        rokit-collapsible::part(header) { background-color: inherit !important; }
        rokit-collapsible[open].has-content::part(content), rokit-collapsible.has-content.transitioning::part(content) { border: 2px solid var(--rokit-primary-color-transparent-inner); box-shadow: 0 0 10px var(--rokit-shadow-color-inner); clip-path: inset(0 -13px -13px 0); }
        #list-container { outline: 0; }
        #list-container-slot { display: none; }
        ul { list-style-type: none; margin: 0; padding: 0; width: 100%; box-sizing: border-box; }
        li > div, #noresult { display: flex; align-items:center; line-height: 1em; padding: 8px; white-space: nowrap; transition: all calc(0.5 * var(--rokit-transition-duration-inner)); }
        li:not([disabled]):not(.divider) { cursor: pointer }
        li:not([disabled]):not(.divider) > div:hover { background-color: var(--rokit-light-background-color-inner); }
        li.active > div { color: var(--rokit-primary-color-inner); background-color: var(--rokit-light-background-color-inner); }
        li.divider { border-top: 1px solid var(--rokit-light-background-darker-color-inner); height: 0; padding: 0; }
        li.divider, li.header { pointer-events: none; }
        li.header > div { font-size: 0.7rem; font-weight: bold; padding-top: 8px; }
        li.large > div { padding-top: 10px; padding-bottom: 10px; }
        .hidden { display: none !important; }
        :host([collapse]) li > div { padding-left: 0; }
        :host([collapse]) .toggle-node { position: absolute }
        :host([collapse]) li > div > div { padding-left: 1.8em; }
        :host([collapse]) ul:not(.open) { display: none; }
        :host([collapse]) li:not(.open) > div > .toggle-node::part(button):before { transform: translate(0, 0) rotate(-45deg); }
    `];
Et([De()], ht.prototype, "emptyMessage", 2);
Et([De()], ht.prototype, "sort", 2);
Et([De()], ht.prototype, "collapsibleMaxHeight", 2);
Et([De()], ht.prototype, "collapsibleOrientationLeft", 2);
Et([De()], ht.prototype, "collapsibleOrientationRight", 2);
Et([De()], ht.prototype, "collapsibleWidth", 2);
Et([De({
    type: Boolean
})], ht.prototype, "autoGrowLabelWidth", 2);
Et([De()], ht.prototype, "inputMinWidth", 2);
Et([De({
    type: Boolean,
    reflect: !0
})], ht.prototype, "collapse", 2);
Et([De()], ht.prototype, "filterableThreshold", 2);
Et([De()], ht.prototype, "supportingText", 2);
Et([zt("rokit-collapsible")], ht.prototype, "collapsible", 2);
Et([zt("#input")], ht.prototype, "input", 2);
Et([zt("#list-container")], ht.prototype, "listContainer", 2);
Et([Ys()], ht.prototype, "selectedItem", 2);
Et([Ys()], ht.prototype, "itemCount", 2);
Et([Ys()], ht.prototype, "toggleOnHeaderClick", 2);
ht = Et([_n("rokit-select")], ht);
var D_ = Object.defineProperty
  , O_ = Object.getOwnPropertyDescriptor
  , to = (i,e,n,r)=>{
    for (var o = r > 1 ? void 0 : r ? O_(e, n) : e, a = i.length - 1, l; a >= 0; a--)
        (l = i[a]) && (o = (r ? l(e, n, o) : l(o)) || o);
    return r && o && D_(e, n, o),
    o
}
;
let vi = class extends dt {
    constructor() {
        super(...arguments),
        this.resize = "none",
        this.rows = 3
    }
    firstUpdated() {
        super.firstUpdated(),
        this.inputElement.rows = this.rows,
        this.cols !== void 0 && (this.inputElement.cols = this.cols),
        this.resize === "auto" ? (this.inputElement.style.resize = "none",
        this.inputElement.addEventListener("input", ()=>this.autoResize())) : this.inputElement.style.resize = this.resize
    }
    updated(i) {
        super.updated(i),
        this.resize === "auto" && i.has("resize") && new IntersectionObserver(e=>{
            e.length && e[0].isIntersecting && this.autoResize()
        }
        ).observe(this),
        this.resize === "auto" && i.has("value") && this.autoResize()
    }
    autoResize() {
        this.inputElement.style.height = "",
        this.inputElement.style.height = this.inputElement.scrollHeight + "px"
    }
    onSlotChange() {
        const i = this.shadowRoot.querySelector("#content").assignedNodes().map(e=>e.textContent).join("");
        i.trim() !== "" && (this.value = i)
    }
    renderInput() {
        return Ft`
        <textarea id="input" part="input" autocomplete="off" name="${this.name}" ?disabled="${this.disabled}" ?readonly="${this.readonly}" ?required="${this.required}" .value="${this.value}"></textarea>
        <slot id="content" @slotchange=${this.onSlotChange}></slot>
        `
    }
}
;
vi.styles = [...dt.styles, Jt`
        :host, .wrapper { align-items: flex-start; }
        #input { height: initial; }
        #content { display: none; }
    `];
to([De()], vi.prototype, "resize", 2);
to([De()], vi.prototype, "rows", 2);
to([De()], vi.prototype, "cols", 2);
vi = to([_n("rokit-textarea")], vi);
var F_ = Object.defineProperty, j_ = Object.getOwnPropertyDescriptor, rp = i=>{
    throw TypeError(i)
}
, vn = (i,e,n,r)=>{
    for (var o = r > 1 ? void 0 : r ? j_(e, n) : e, a = i.length - 1, l; a >= 0; a--)
        (l = i[a]) && (o = (r ? l(e, n, o) : l(o)) || o);
    return r && o && F_(e, n, o),
    o
}
, sp = (i,e,n)=>e.has(i) || rp("Cannot " + n), et = (i,e,n)=>(sp(i, e, "read from private field"),
n ? n.call(i) : e.get(i)), Ja = (i,e,n)=>e.has(i) ? rp("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(i) : e.set(i, n), Es = (i,e,n,r)=>(sp(i, e, "write to private field"),
e.set(i, n),
n), lt, Ln, Oi;
const zn = 18;
let An = class extends dt {
    constructor() {
        super(...arguments),
        this.labelFormatter = i=>String(i),
        Ja(this, lt, [0, 1]),
        Ja(this, Ln, [et(this, lt)[0], et(this, lt)[1]]),
        Ja(this, Oi)
    }
    firstUpdated() {
        super.firstUpdated(),
        this.sliderElement.addEventListener("mousedown", i=>this.onKnobDrag(i)),
        this.sliderElement.addEventListener("touchstart", i=>this.onKnobDrag(i)),
        new ResizeObserver(()=>{
            this.updateKnobPositions()
        }
        ).observe(this.sliderElement)
    }
    updated(i) {
        if (super.updated(i),
        i.has("min") && (et(this, lt)[0] = parseFloat(this.min || "0"),
        et(this, lt)[1] = Math.max(et(this, lt)[0], et(this, lt)[1])),
        i.has("max") && (et(this, lt)[1] = parseFloat(this.max || "1"),
        et(this, lt)[0] = Math.min(et(this, lt)[0], et(this, lt)[1])),
        i.has("step") && Es(this, Oi, this.step ? parseFloat(this.step) : void 0),
        i.has("value") || i.has("min") || i.has("max"))
            if (this.value)
                if (this.range !== void 0) {
                    const e = JSON.parse(this.value);
                    Es(this, Ln, [this.applyConstraints(e[0]), this.applyConstraints(e[1])])
                } else
                    Es(this, Ln, [this.applyConstraints(parseFloat(this.value))]);
            else
                Es(this, Ln, [et(this, lt)[0], et(this, lt)[1]]);
        this.updateKnobPositions()
    }
    updateValidity(i, e) {
        super.updateValidity(i, e, this.sliderElement)
    }
    chooseKnob(i) {
        if (!this.endKnob)
            return this.startKnob;
        let e = Math.abs(i - this.startKnob.offsetLeft) < Math.abs(i - this.endKnob.offsetLeft) ? this.startKnob : this.endKnob;
        return this.startKnob.value === this.endKnob.value && (e.id === "start" && e.value === et(this, lt)[0] ? e = this.endKnob : e.id === "end" && e.value === et(this, lt)[1] && (e = this.startKnob)),
        e
    }
    toScreenSpace(i) {
        return (i - et(this, lt)[0]) / (et(this, lt)[1] - et(this, lt)[0]) * this.track.offsetWidth
    }
    toValueSpace(i) {
        return i / this.track.offsetWidth * (et(this, lt)[1] - et(this, lt)[0]) + et(this, lt)[0]
    }
    applyConstraints(i, e) {
        let n = Math.min(Math.max(i, et(this, lt)[0]), et(this, lt)[1]);
        return et(this, Oi) && (n = Math.round(n / et(this, Oi)) * et(this, Oi)),
        e !== void 0 && this.endKnob && (n = e ? Math.min(n, this.endKnob.value) : Math.max(n, this.startKnob.value)),
        n
    }
    updateKnob(i, e) {
        i.value = e,
        i.offset = this.toScreenSpace(e),
        i.label = this.labelFormatter(e),
        this.endKnob && (i.id === "start" ? this.track.style.borderLeftWidth = i.offset + "px" : this.track.style.borderRightWidth = this.track.offsetWidth - i.offset + "px")
    }
    updateKnobPositions() {
        this.updateKnob(this.startKnob, et(this, Ln)[0]),
        this.endKnob && this.updateKnob(this.endKnob, et(this, Ln)[1])
    }
    onKnobDrag(i) {
        if (i.target instanceof zi || this.classList.contains("has-value") || this.classList.contains("has-focus")) {
            let e;
            const n = o=>{
                let a = 0;
                o.type === "touchmove" || o.type === "touchstart" ? a = o.touches[0].clientX : a = o.clientX,
                a = a - this.track.getBoundingClientRect().left,
                e || (e = this.chooseKnob(a),
                e.classList.add("focus")),
                this.updateKnob(e, this.applyConstraints(this.toValueSpace(a), e.id === "start"))
            }
              , r = ()=>{
                document.removeEventListener("mousemove", n),
                document.removeEventListener("touchmove", n),
                document.removeEventListener("mouseup", r),
                document.removeEventListener("touchend", r),
                e && (e.classList.remove("focus"),
                this.range !== void 0 ? e.id === "end" ? this.value = JSON.stringify([et(this, Ln)[0], e.value]) : this.value = JSON.stringify([e.value, et(this, Ln)[1]]) : this.value = String(e.value)),
                e = void 0
            }
            ;
            this.sliderElement.focus(),
            document.addEventListener("mousemove", n),
            document.addEventListener("touchmove", n),
            document.addEventListener("mouseup", r),
            document.addEventListener("touchend", r),
            n(i)
        }
    }
    renderInput() {
        return Ft`
        ${super.renderInput()}
        <div id="slider" part="slider" tabindex="0" ?range="${this.range !== void 0}">
            <div id="track"></div>
            <rokit-slider-knob id="start"></rokit-slider-knob>
            ${this.range === void 0 ? gt : Ft`
                <rokit-slider-knob id="end"></rokit-slider-knob>
            `}
        </div>
        `
    }
}
;
lt = new WeakMap;
Ln = new WeakMap;
Oi = new WeakMap;
An.styles = [...dt.styles, Jt`
        :host(.has-label:not(:focus):not(.has-value):not([sticky])) #slider > * { visibility: hidden; }
        :host(.has-label) .wrapper { padding-top: 1em; }
        :host([sticky]) #slider { margin-top: ${.25 * zn + 22}px; }
        #input { display: none; }
        #slider { display: flex; position: relative; align-items: center; width: 100%; height: ${zn}px; padding: 0 ${zn / 2}px; outline: 0; }
        :host(:not([sticky])) #slider:not(:focus) rokit-slider-knob::part(label) { color: transparent; background-color: transparent; border-color: transparent; top: 0; }
        #track { height: 2px;  flex-grow: 1; background-color: #CCC; }
        #slider[range] #track { background-color: color-mix(in srgb, var(--rokit-primary-color-inner) 60%, transparent); border-width: 0; border-color: #CCC; border-style: solid; }
    `];
vn([De()], An.prototype, "range", 2);
vn([De()], An.prototype, "labelFormatter", 2);
vn([zt("#slider")], An.prototype, "sliderElement", 2);
vn([zt("#track")], An.prototype, "track", 2);
vn([zt("#start")], An.prototype, "startKnob", 2);
vn([zt("#end")], An.prototype, "endKnob", 2);
An = vn([_n("rokit-slider")], An);
let zi = class extends Hn {
    constructor() {
        super(...arguments),
        this.offset = 0,
        this.label = "",
        this.value = 0
    }
    updated(i) {
        i.has("offset") && (this.style.left = this.offset + "px")
    }
    render() {
        return Ft`<label part="label">${this.label}</label>`
    }
}
;
zi.styles = [Jt`
        :host { position: absolute; width: ${zn}px; height: ${zn}px; border-radius: ${zn}px; background-color: var(--rokit-primary-color-inner); }
        :host(.focus), :host(:hover) { box-shadow: 0 0 0 ${zn / 2}px var(--rokit-primary-color-transparent-inner); z-index: 1; }
        label {
            position: absolute;
            top: calc(-2em - ${zn / 4}px);
            left: 50%;
            transform: translate(-50%, 0);
            white-space: nowrap;
            font-size: 0.75em;
            font-weight: 500;
            transition-property: top color background-color;
            transition-duration: var(--rokit-transition-duration-inner);
            pointer-events: none;
            color: white;
            background-color: var(--rokit-primary-color-inner);
            padding: 0 4px;
            border-radius: 3px;
        }
        label:after {
            content: '';
            width: 10px;
            height: 10px;
            position: absolute;
            left: 50%;
            bottom: -4px;
            transform: translate(-50%, 0);
            background-color: inherit;
            clip-path: polygon(50% 50%, 100% 50%, 50% 100%, 0 50%);
        }
    `];
vn([De()], zi.prototype, "offset", 2);
vn([De()], zi.prototype, "label", 2);
zi = vn([_n("rokit-slider-knob")], zi);
var B_ = Object.defineProperty
  , $_ = Object.getOwnPropertyDescriptor
  , Wr = (i,e,n,r)=>{
    for (var o = r > 1 ? void 0 : r ? $_(e, n) : e, a = i.length - 1, l; a >= 0; a--)
        (l = i[a]) && (o = (r ? l(e, n, o) : l(o)) || o);
    return r && o && B_(e, n, o),
    o
}
;
let bi = class extends ln {
    constructor() {
        super(...arguments),
        this.open = !1,
        this.closable = !1,
        this.title = ""
    }
    firstUpdated() {
        this.dialogElement.addEventListener("close", ()=>{
            this.open = !1,
            this.dispatchEvent(new Event("close"))
        }
        )
    }
    updated(i) {
        if (i.has("open"))
            if (this.open)
                document.body.style.left = `-${window.scrollX}px`,
                document.body.style.top = `-${window.scrollY}px`,
                document.body.style.position = "fixed",
                this.dialogElement.showModal();
            else {
                const e = document.body.style.left
                  , n = document.body.style.top;
                document.body.style.position = "",
                document.body.style.left = "",
                document.body.style.top = "",
                window.scrollTo(parseInt(e || "0") * -1, parseInt(n || "0") * -1),
                this.dialogElement.close()
            }
    }
    render() {
        return Ft`
            <dialog id="dialog" part="dialog">
                <header>
                    <div class="title" part="title">
                        <slot name="header">${this.title}</slot>
                    </div>
                    ${this.closable ? Ft`
                        <rokit-button class="clear" icon ?dense="${this.dense}" @click="${()=>{
            this.open = !1
        }
        }" title="Close"></rokit-button>
                    ` : gt}
                </header>
                <main>
                    <slot></slot>
                </main>
            </dialog>
        `
    }
}
;
bi.styles = [...ln.styles, Jt`
        dialog[open] { display: flex; flex-direction: column; width: 100%; max-width: 90vw; max-height: 90vh; margin: auto; outline: 0; border: 0; border-radius: 1em; }
        dialog::backdrop { background-color: #0007; }
        header { display: flex; align-items: center; }
        .title { font-weight: 600; flex-grow: 1; text-align: center; }
        .clear { justify-self: flex-end; }
        main { flex-grow: 1; overflow: auto; display: flex; flex-direction: column; }
    `];
Wr([De({
    type: Boolean,
    reflect: !0
})], bi.prototype, "open", 2);
Wr([De({
    type: Boolean
})], bi.prototype, "closable", 2);
Wr([De()], bi.prototype, "title", 2);
Wr([zt("#dialog")], bi.prototype, "dialogElement", 2);
bi = Wr([_n("rokit-dialog")], bi);
var q_ = Object.defineProperty
  , z_ = Object.getOwnPropertyDescriptor
  , eu = (i,e,n,r)=>{
    for (var o = r > 1 ? void 0 : r ? z_(e, n) : e, a = i.length - 1, l; a >= 0; a--)
        (l = i[a]) && (o = (r ? l(e, n, o) : l(o)) || o);
    return r && o && q_(e, n, o),
    o
}
;
let zr = class extends ln {
    updated(i) {
        i.has("percent") && (this.bar.style.width = this.percent ? this.percent + "%" : "")
    }
    render() {
        return Ft`<div class="bar"></div>`
    }
}
;
zr.styles = [...ln.styles, Jt`
    :host { display: flex; background-color: var(--rokit-primary-color-transparent-inner); }
    .bar { height: 3px; background-color: var(--rokit-primary-color-inner); }
    :host(:not([percent])) .bar { width: 100%; --c: no-repeat linear-gradient(var(--rokit-primary-color-inner) 0 0); background: var(--c), var(--c); background-size: 60% 100%; animation: indeterminate 3s infinite; }
    @keyframes indeterminate {
        0%   { background-position:-150% 0,-150% 0 }
        66%  { background-position: 250% 0,-150% 0 }
        100% { background-position: 250% 0, 250% 0 }
    }
    `];
eu([De({
    reflect: !0
})], zr.prototype, "percent", 2);
eu([zt(".bar")], zr.prototype, "bar", 2);
zr = eu([_n("rokit-progressbar")], zr);
var U_ = (i,e,n,r)=>{
    for (var o = e, a = i.length - 1, l; a >= 0; a--)
        (l = i[a]) && (o = l(o) || o);
    return o
}
;
const H_ = "RokitSnackbarEvent"
  , op = "0.2s"
  , V_ = Kf(op)
  , G_ = 3e3;
let Ur = class extends Hn {
    constructor() {
        super(),
        this.container = document.createElement("div"),
        this.container.classList.add("snackbar"),
        this.container.part = "snackbar"
    }
    firstUpdated() {
        this.shadowRoot.appendChild(this.container),
        document.addEventListener(H_, i=>{
            const e = i.detail;
            console.log("--- received", e),
            e && Ur.showMessage(e)
        }
        )
    }
    static showMessage(i, e) {
        console.log("--- show message", i, e),
        e || (e = document.querySelector("rokit-snackbar") || void 0,
        console.log("--- 1", e),
        e || (e = new Ur,
        document.body.appendChild(e)));
        const n = document.createElement("div");
        n.classList.add("message");
        const r = document.createElement("div");
        r.classList.add("inner");
        const o = document.createElement("div");
        if (o.classList.add("text"),
        o.innerHTML = i.message,
        r.appendChild(o),
        n.appendChild(r),
        i.closable !== void 0 ? i.closable : i.ttl === 0) {
            n.classList.add("closable");
            const l = new Nn;
            l.setAttribute("icon", ""),
            l.setAttribute("dense", ""),
            l.classList.add("clear"),
            l.title = "Dismiss",
            l.addEventListener("click", ()=>{
                console.log("click"),
                a(n)
            }
            ),
            r.append(l)
        }
        i.cssStyle && (n.style = i.cssStyle),
        i.cssClass && n.classList.add(i.cssClass),
        e.container.appendChild(n),
        setTimeout(()=>{
            n.style.maxHeight = n.scrollHeight + "px",
            n.style.marginBottom = "10px"
        }
        ),
        i.ttl !== 0 && setTimeout(()=>{
            a(n)
        }
        , i.ttl || G_);
        const a = l=>{
            l.style.maxHeight = "",
            l.style.marginBottom = "",
            setTimeout(()=>{
                l.remove()
            }
            , V_)
        }
    }
}
;
Ur.styles = Jt`
    :host { display: flex; justify-content: center; width: 100%; position: fixed; bottom: 10px; pointer-events: none; }
    :host(.left)  { right: auto; left: 10px; width: auto; }
    :host(.right) { right: 10px; left: auto; width: auto; }
    :host(.top) { top: 10px; bottom: auto; }
    :host(.top) .snackbar { flex-direction: column-reverse; }
    .snackbar { display: flex; flex-direction: column; width: 300px; }
    .message { max-height: 0; margin-bottom: 0; overflow: hidden; background-color: #333; color: #FFF; border-radius: 4px; transition: all ${Uf(op)} ease-in-out; font-weight: 500; pointer-events: auto; }
    .message.error { background-color: #C22; }
    .message.success { background-color: #0a8f0a; }
    .message:not(.closable) .text { text-align: center; }
    .inner { display: flex; padding: 10px; }
    .text { flex-grow: 1; }
    .text a { color: inherit; }
    `;
Ur = U_([_n("rokit-snackbar")], Ur);
class Bs extends HTMLElement {
    constructor(e, n) {
        if (super(),
        this.template = e,
        this.parent = n,
        this.container = this,
        this.template.nodeShapes.size && this.template.config.attributes.collapse !== null && (this.template.maxCount === void 0 || this.template.maxCount > 1)) {
            const r = new Ct;
            r.classList.add("collapsible", "shacl-group"),
            r.open = e.config.attributes.collapse === "open",
            r.label = this.template.label,
            this.container = r,
            this.appendChild(this.container)
        }
        this.template.order !== void 0 && (this.style.order = `${this.template.order}`),
        this.template.cssClass && this.classList.add(this.template.cssClass),
        e.config.editMode && !n.linked && (this.addButton = this.createAddButton(),
        this.container.appendChild(this.addButton),
        this.addEventListener("change", ()=>{
            this.updateControls()
        }
        ))
    }
    async bindValues(e) {
        if (this.template.path) {
            let n = !1;
            if (e) {
                let r = this.template.config.store.getQuads(e, this.template.path, null, this.parent.linked ? null : on);
                r = await this.filterValidValues(r, e);
                for (const o of r)
                    this.template.config.store.delete(o),
                    this.addPropertyInstance(o.object),
                    this.template.hasValue && o.object.equals(this.template.hasValue) && (n = !0)
            }
            this.template.config.editMode && (this.template.hasValue && !n && !this.parent.linked && this.addPropertyInstance(this.template.hasValue),
            this.updateControls())
        }
    }
    addPropertyInstance(e) {
        let n;
        if (this.template.or?.length || this.template.xone?.length) {
            const r = this.template.or?.length ? this.template.or : this.template.xone;
            let o = !1;
            if (e) {
                const a = $m(r, e, this.template.config);
                if (a.length) {
                    const l = Gl(Ff(this.template), a);
                    n = Cs(l, e, !0),
                    o = !0
                }
            }
            o || (n = Bf(r, this, this.template.config),
            ap(n, "", this.template.config.theme.dense, this.template.config.hierarchyColorsStyleSheet !== void 0))
        } else {
            let r = !1;
            if (e && !(e instanceof Wt)) {
                const o = this.getRdfClassToLinkOrCreate();
                o && this.template.config.store.countQuads(e, Rt, o, on) === 0 && (r = !0)
            }
            n = Cs(this.template, e, void 0, r || this.parent.linked)
        }
        return this.addButton ? this.container.insertBefore(n, this.addButton) : this.container.appendChild(n),
        n
    }
    updateControls() {
        let e = this.instanceCount();
        e === 0 && (this.template.nodeShapes.size === 0 || this.template.aggregatedMinCount > 0) && (this.addPropertyInstance(),
        e = this.instanceCount());
        let n;
        this.template.aggregatedMinCount > 0 ? n = e > this.template.aggregatedMinCount : n = this.template.nodeShapes.size > 0 || e > 1;
        const r = this.template.maxCount === void 0 || e < this.template.maxCount;
        this.classList.toggle("may-remove", n),
        this.classList.toggle("may-add", r)
    }
    instanceCount() {
        return this.querySelectorAll(":scope > .property-instance, :scope > .shacl-or-constraint, :scope > shacl-node, :scope > .collapsible > .property-instance").length
    }
    toRDF(e, n) {
        const r = ze.namedNode(this.template.path);
        for (const o of this.querySelectorAll(":scope > .property-instance, :scope > .collapsible > .property-instance"))
            if (o.firstChild instanceof Ei) {
                const a = o.firstChild.toRDF(e);
                e.addQuad(n, r, a, this.template.config.valuesGraphId)
            } else
                for (const a of o.querySelectorAll(":scope > .editor")) {
                    const l = Gm(a);
                    l && e.addQuad(n, r, l, this.template.config.valuesGraphId)
                }
    }
    getRdfClassToLinkOrCreate() {
        if (this.template.class && this.template.nodeShapes.size)
            return this.template.class;
        for (const e of this.template.nodeShapes)
            if (e.targetClass)
                return e.targetClass
    }
    async filterValidValues(e, n) {
        let r = this.template.id
          , o = [n];
        if (this.template.qualifiedValueShape) {
            r = this.template.qualifiedValueShape.id,
            o = [];
            for (const u of e)
                o.push(u.object)
        }
        const a = await this.template.config.validator.validate({
            dataset: this.template.config.store,
            terms: o
        }, [{
            terms: [r]
        }])
          , l = [];
        for (const u of a.results) {
            const f = this.template.qualifiedValueShape ? u.focusNode : u.value;
            f?.ptrs?.length && l.push(f.ptrs[0]._term.id)
        }
        return e.filter(u=>l.indexOf(u.object.id) === -1)
    }
    createAddButton() {
        const e = new ht;
        e.dense = this.template.config.theme.dense,
        e.label = "+ " + this.template.label,
        e.title = "Add " + this.template.label,
        e.autoGrowLabelWidth = !0,
        e.classList.add("add-button");
        let n = []
          , r = this.getRdfClassToLinkOrCreate();
        if (r && (n = $l(r, this.template)),
        n.length === 0)
            e.emptyMessage = "",
            e.inputMinWidth = 0,
            e.addEventListener("click", o=>{
                e.blur();
                const a = this.addPropertyInstance();
                a.classList.add("fadeIn"),
                this.updateControls(),
                setTimeout(()=>{
                    Kg(a),
                    a.classList.remove("fadeIn")
                }
                , 200)
            }
            );
        else {
            const o = document.createElement("ul")
              , a = document.createElement("li");
            a.innerHTML = "&#xFF0B; Create new " + this.template.label + "...",
            a.dataset.value = "new",
            a.classList.add("large"),
            o.appendChild(a);
            const l = document.createElement("li");
            l.classList.add("divider"),
            o.appendChild(l);
            const u = document.createElement("li");
            u.classList.add("header"),
            u.innerText = "Or link existing:",
            o.appendChild(u);
            for (const f of n) {
                const h = document.createElement("li")
                  , m = typeof f.value == "string" ? f.value : f.value.value;
                h.innerText = f.label ? f.label : m,
                h.dataset.value = JSON.stringify(f.value),
                o.appendChild(h)
            }
            e.appendChild(o),
            e.collapsibleWidth = "250px",
            e.collapsibleOrientationLeft = "",
            e.addEventListener("change", ()=>{
                if (e.value === "new")
                    this.addPropertyInstance();
                else {
                    const f = JSON.parse(e.value);
                    this.container.insertBefore(Cs(this.template, f, !0, !0), e)
                }
                e.value = ""
            }
            )
        }
        return e
    }
}
function Cs(i, e, n=!1, r=!1) {
    let o;
    if (i.nodeShapes.size) {
        o = document.createElement("div"),
        o.classList.add("property-instance");
        for (const a of i.nodeShapes)
            o.appendChild(new Ei(a,e,i.nodeKind,i.label,r))
    } else {
        const a = Xm(i.path, i.datatype?.value);
        a ? i.config.editMode && !r ? o = a.createEditor(i, e) : o = a.createViewer(i, e) : o = $f(i, e || null, i.config.editMode && !r),
        o.classList.add("property-instance"),
        r && o.classList.add("linked")
    }
    return i.config.editMode && ap(o, i.label, i.config.theme.dense, i.config.hierarchyColorsStyleSheet !== void 0, n),
    o.dataset.path = i.path,
    o
}
function ap(i, e, n, r, o=!1) {
    const a = document.createElement("div");
    a.className = "remove-button-wrapper",
    r && a.classList.add("colorize");
    const l = new Nn;
    l.classList.add("remove-button", "clear"),
    l.title = "Remove " + e,
    l.dense = n,
    l.icon = !0,
    l.addEventListener("click", u=>{
        i.classList.remove("fadeIn"),
        i.classList.add("fadeOut"),
        setTimeout(()=>{
            const f = i.parentElement;
            i.remove(),
            f?.dispatchEvent(new Event("change",{
                bubbles: !0,
                cancelable: !0
            }))
        }
        , 200)
    }
    ),
    o && l.classList.add("persistent"),
    a.appendChild(l),
    i.appendChild(a)
}
window.customElements.define("shacl-property", Bs);
function W_(i, e) {
    let n = i;
    const r = e.store.getQuads(i, null, null, null)
      , o = Or(r, "label", Ol, e.languages);
    o && (n = o);
    let a;
    if (e.attributes.collapse !== null)
        a = new Ct,
        a.classList.add("collapsible"),
        a.open = e.attributes.collapse === "open",
        a.label = n;
    else {
        a = document.createElement("div");
        const u = document.createElement("h1");
        u.innerText = n,
        a.appendChild(u)
    }
    a.dataset.subject = i,
    a.classList.add("shacl-group");
    const l = Or(r, "order");
    return l && (a.style.order = l),
    a
}
const Tt = [];
for (let i = 0; i < 256; ++i)
    Tt.push((i + 256).toString(16).slice(1));
function Z_(i, e=0) {
    return (Tt[i[e + 0]] + Tt[i[e + 1]] + Tt[i[e + 2]] + Tt[i[e + 3]] + "-" + Tt[i[e + 4]] + Tt[i[e + 5]] + "-" + Tt[i[e + 6]] + Tt[i[e + 7]] + "-" + Tt[i[e + 8]] + Tt[i[e + 9]] + "-" + Tt[i[e + 10]] + Tt[i[e + 11]] + Tt[i[e + 12]] + Tt[i[e + 13]] + Tt[i[e + 14]] + Tt[i[e + 15]]).toLowerCase()
}
let Ka;
const X_ = new Uint8Array(16);
function Q_() {
    if (!Ka) {
        if (typeof crypto > "u" || !crypto.getRandomValues)
            throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        Ka = crypto.getRandomValues.bind(crypto)
    }
    return Ka(X_)
}
const J_ = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto)
  , rh = {
    randomUUID: J_
};
function K_(i, e, n) {
    i = i || {};
    const r = i.random ?? i.rng?.() ?? Q_();
    if (r.length < 16)
        throw new Error("Random bytes length must be >= 16");
    return r[6] = r[6] & 15 | 64,
    r[8] = r[8] & 63 | 128,
    Z_(r)
}
function sh(i, e, n) {
    return rh.randomUUID && !i ? rh.randomUUID() : K_(i)
}
class Ei extends HTMLElement {
    constructor(e, n, r, o, a) {
        super(),
        this.template = e,
        this.linked = a || !1;
        let l = n;
        l || (!r && e.nodeKind && (r = e.nodeKind),
        r === void 0 && e.config.attributes.valuesNamespace || r?.value === `${Fe}IRI` ? l = ze.namedNode(e.config.attributes.valuesNamespace + sh()) : l = ze.blankNode(sh())),
        this.nodeId = l;
        const u = JSON.stringify([e.id, n]);
        if (n && e.config.renderedNodes.has(u)) {
            o = o || "Link";
            const f = document.createElement("label");
            f.innerText = o,
            f.classList.add("linked"),
            this.appendChild(f);
            const h = document.createElement("a");
            let m = n.termType === "BlankNode" ? "_:" + n.value : n.value;
            h.innerText = m,
            h.classList.add("ref-link"),
            h.onclick = ()=>{
                this.template.config.form.querySelector(`shacl-node[data-node-id='${m}']`)?.scrollIntoView()
            }
            ,
            this.appendChild(h),
            this.style.flexDirection = "row"
        } else {
            if (n && e.config.renderedNodes.add(u),
            this.dataset.nodeId = this.nodeId.id,
            this.template.config.attributes.showNodeIds !== null) {
                const f = document.createElement("div");
                f.innerText = `id: ${this.nodeId.id}`,
                f.classList.add("node-id-display"),
                this.appendChild(f)
            }
            (async()=>{
                for (const [f,h] of Object.entries(e.properties))
                    for (const m of h)
                        await this.addPropertyInstance(m, n);
                for (const f of e.extendedShapes)
                    this.prepend(new Ei(f,n));
                if (e.or?.length && await this.tryResolve(e.or, n, e.config),
                e.xone?.length && await this.tryResolve(e.xone, n, e.config),
                o) {
                    const f = document.createElement("h1");
                    f.innerText = o,
                    this.prepend(f)
                }
            }
            )()
        }
    }
    toRDF(e, n, r="") {
        if (n || (n = this.nodeId),
        !this.linked) {
            for (const o of this.querySelectorAll(":scope > shacl-node, :scope > .shacl-group > shacl-node, :scope > shacl-property, :scope > .shacl-group > shacl-property"))
                o.toRDF(e, n);
            this.template.targetClass && e.addQuad(n, Rt, this.template.targetClass, this.template.config.valuesGraphId),
            r && e.addQuad(n, ze.namedNode(r), this.template.id, this.template.config.valuesGraphId)
        }
        return n
    }
    async addPropertyInstance(e, n) {
        let r = this;
        if (e.group)
            if (e.config.groups.indexOf(e.group) > -1) {
                let a = this.querySelector(`:scope > .shacl-group[data-subject='${e.group}']`);
                a || (a = W_(e.group, e.config),
                this.appendChild(a)),
                r = a
            } else
                console.warn("ignoring unknown group reference", e.group, "existing groups:", e.config.groups);
        const o = new Bs(e,this);
        await o.bindValues(n),
        (e.config.editMode || o.instanceCount() > 0) && (r.appendChild(o),
        o.updateControls())
    }
    async tryResolve(e, n, r) {
        let o = !1;
        if (n) {
            const a = qm(e, n, r);
            if (a.length) {
                for (const l of a)
                    await this.addPropertyInstance(r.getPropertyTemplate(l, this.template), n);
                o = !0
            }
        }
        o || this.appendChild(Bf(e, this, r))
    }
}
window.customElements.define("shacl-node", Ei);
const Y_ = `
.editor:not([type='checkbox']) { border: 1px solid #DDD; }
.property-instance label { display: inline-flex; word-break: break-word; line-height: 1em; padding-top: 0.15em; padding-right: 1em; flex-shrink: 0; position: relative; }
.property-instance:not(:first-child) > label:not(.persistent) { visibility: hidden; max-height: 0; }
.mode-edit .property-instance label { width: var(--label-width); }
`;
class ey extends Um {
    constructor(e) {
        super(e || Y_),
        this.idCtr = 0
    }
    createDefaultTemplate(e, n, r, o, a) {
        if (o.id = `e ${this.idCtr++}`,
        o.classList.add("editor"),
        a?.datatype ? o.shaclDatatype = a.datatype : n instanceof Wt && (o.shaclDatatype = n.datatype),
        a && a.aggregatedMinCount > 0 && (o.dataset.minCount = String(a.aggregatedMinCount)),
        a?.class && (o.dataset.class = a.class.value),
        a?.nodeKind)
            o.dataset.nodeKind = a.nodeKind.value;
        else if (n && (n instanceof mi || a?.nodeKind?.equals(wf)) && (o.dataset.nodeKind = Fe + "IRI",
        a)) {
            const h = Wi(a.config.store.getQuads(n, null, null, null), a.config.languages);
            h && (o.dataset.value = "<" + n.value + ">",
            n = ze.literal(h))
        }
        (a?.hasValue && n || a?.readonly) && (o.disabled = !0),
        o.value = n?.value || a?.defaultValue?.value || "";
        const l = document.createElement("label");
        l.htmlFor = o.id,
        l.innerText = e,
        a?.description && l.setAttribute("title", a.description.value);
        const u = a?.description ? a.description.value : a?.pattern ? a.pattern : null;
        u && o.setAttribute("placeholder", u),
        r && (o.setAttribute("required", "true"),
        l.classList.add("required"));
        const f = document.createElement("div");
        return f.appendChild(l),
        f.appendChild(o),
        f
    }
    createDateEditor(e, n, r, o) {
        const a = new dt;
        o.datatype?.value === Un + "dateTime" ? (a.type = "datetime-local",
        a.setAttribute("step", "1")) : a.type = "date",
        a.clearable = !0,
        a.dense = this.dense,
        a.classList.add("pr-0");
        const l = this.createDefaultTemplate(e, null, r, a, o);
        if (n)
            try {
                let u = new Date(n.value).toISOString();
                o.datatype?.value === Un + "dateTime" ? u = u.slice(0, 19) : u = u.slice(0, 10),
                a.value = u
            } catch (u) {
                console.error(u, n)
            }
        return l
    }
    createTextEditor(e, n, r, o) {
        let a;
        return o.singleLine === !1 ? (a = new vi,
        a.resize = "auto") : a = new dt,
        a.dense = this.dense,
        o.pattern && (a.pattern = o.pattern),
        o.minLength && (a.minLength = o.minLength),
        o.maxLength && (a.maxLength = o.maxLength),
        this.createDefaultTemplate(e, n, r, a, o)
    }
    createLangStringEditor(e, n, r, o) {
        const a = this.createTextEditor(e, n, r, o)
          , l = a.querySelector(":scope .editor");
        let u;
        if (o.languageIn?.length) {
            u = document.createElement("select");
            for (const f of o.languageIn) {
                const h = document.createElement("option");
                h.innerText = f.value,
                u.appendChild(h)
            }
        } else
            u = document.createElement("input"),
            u.maxLength = 5,
            u.size = 5,
            u.placeholder = "lang?";
        return u.title = "Language of the text",
        u.classList.add("lang-chooser"),
        u.slot = "suffix",
        u.addEventListener("change", f=>{
            f.stopPropagation(),
            l && (l.dataset.lang = u.value,
            l.dispatchEvent(new Event("change",{
                bubbles: !0
            })))
        }
        ),
        n instanceof Wt && (u.value = n.language),
        l.dataset.lang = u.value,
        l.appendChild(u),
        a
    }
    createBooleanEditor(e, n, r, o) {
        const a = document.createElement("input");
        a.type = "checkbox",
        a.classList.add("ml-0");
        const l = this.createDefaultTemplate(e, null, r, a, o);
        return a.removeAttribute("required"),
        l.querySelector(":scope label")?.classList.remove("required"),
        n instanceof Wt && (a.checked = n.value === "true"),
        l
    }
    createFileEditor(e, n, r, o) {
        const a = document.createElement("input");
        return a.type = "file",
        a.addEventListener("change", l=>{
            if (a.files?.length) {
                l.stopPropagation();
                const u = new FileReader;
                u.readAsDataURL(a.files[0]),
                u.onload = ()=>{
                    a.binaryData = btoa(u.result),
                    a.parentElement?.dispatchEvent(new Event("change",{
                        bubbles: !0
                    }))
                }
            } else
                a.binaryData = void 0
        }
        ),
        this.createDefaultTemplate(e, n, r, a, o)
    }
    createNumberEditor(e, n, r, o) {
        const a = new dt;
        a.type = "number",
        a.clearable = !0,
        a.dense = this.dense,
        a.classList.add("pr-0");
        const l = o.minInclusive !== void 0 ? o.minInclusive : o.minExclusive !== void 0 ? o.minExclusive + 1 : void 0
          , u = o.maxInclusive !== void 0 ? o.maxInclusive : o.maxExclusive !== void 0 ? o.maxExclusive - 1 : void 0;
        return l !== void 0 && (a.min = String(l)),
        u !== void 0 && (a.max = String(u)),
        o.datatype?.value !== Un + "integer" && (a.step = "0.1"),
        this.createDefaultTemplate(e, n, r, a, o)
    }
    createListEditor(e, n, r, o, a) {
        const l = new ht;
        l.clearable = !0,
        l.dense = this.dense;
        const u = this.createDefaultTemplate(e, null, r, l, a)
          , f = document.createElement("ul");
        let h = !0;
        const m = (_,d)=>{
            const g = document.createElement("li");
            if (typeof _.value == "string" ? (g.dataset.value = _.value,
            g.innerText = _.label ? _.label : _.value) : (g.dataset.value = _.value.id,
            _.value instanceof mi && (g.dataset.value = "<" + g.dataset.value + ">"),
            g.innerText = _.label ? _.label : _.value.value),
            d.appendChild(g),
            _.children?.length) {
                h = !1;
                const b = document.createElement("ul");
                g.appendChild(b);
                for (const T of _.children)
                    m(T, b)
            }
        }
        ;
        for (const _ of o)
            m(_, f);
        return h || (l.collapse = !0),
        l.appendChild(f),
        n && (l.value = n.id,
        n instanceof mi && (l.value = "<" + l.value + ">")),
        u
    }
    createButton(e, n) {
        const r = document.createElement("rokit-button");
        return r.innerHTML = e,
        r
    }
}
function ty(i) {
    return "_:" + i.value
}
function ny(i, e) {
    return [...i].map(n=>e(n)).join(`
`) + `
`
}
function iy() {
    return ""
}
function lp(i) {
    return "<" + i.value + ">"
}
const ry = /["\\\\\n\r]/
  , sy = /["\\\\\n\r]/g
  , oy = {
    '"': '\\"',
    "\\": "\\\\",
    "\n": "\\n",
    "\r": "\\r"
};
function ay(i) {
    return oy[i]
}
function ly(i) {
    return ry.test(i) ? i.replace(sy, ay) : i
}
function uy(i) {
    const e = ly(i.value);
    return i.datatype.value === "http://www.w3.org/2001/XMLSchema#string" ? '"' + e + '"' : i.datatype.value === "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString" ? '"' + e + '"@' + i.language : '"' + e + '"^^' + lp(i.datatype)
}
function cy(i, e) {
    const n = e(i.subject)
      , r = e(i.predicate)
      , o = e(i.object)
      , a = e(i.graph);
    return `${n} ${r} ${o} ${a ? a + " " : ""}.`
}
function dy(i) {
    return "?" + i.value
}
function $t(i) {
    if (!i)
        return null;
    if (i.termType === "BlankNode")
        return ty(i);
    if (i.termType === "DefaultGraph")
        return iy();
    if (i.termType === "Literal")
        return uy(i);
    if (i.termType === "NamedNode")
        return lp(i);
    if (i.termType === "Quad" || i.subject && i.predicate && i.object && i.graph)
        return cy(i, $t);
    if (i.termType === "Variable")
        return dy(i);
    if (i[Symbol.iterator])
        return ny(i, $t);
    throw new Error(`unknown termType ${i.termType}`)
}
class Zi {
    constructor(e) {
        if (this.index = new Map,
        e)
            for (const [n,r] of e)
                this.set(n, r)
    }
    get size() {
        return this.index.size
    }
    clear() {
        this.index.clear()
    }
    delete(e) {
        return this.index.delete($t(e))
    }
    *entries() {
        for (const [,{term: e, value: n}] of this.index)
            yield[e, n]
    }
    forEach(e, n) {
        for (const r of this.entries())
            e.call(n, r[1], r[0], this)
    }
    get(e) {
        const n = this.index.get($t(e));
        return n && n.value
    }
    has(e) {
        return this.index.has($t(e))
    }
    *keys() {
        for (const [,{term: e}] of this.index)
            yield e
    }
    set(e, n) {
        const r = $t(e);
        return this.index.set(r, {
            term: e,
            value: n
        }),
        this
    }
    *values() {
        for (const [,{value: e}] of this.index)
            yield e
    }
    [Symbol.iterator]() {
        return this.entries()[Symbol.iterator]()
    }
}
class oh {
    constructor({dataset: e, end: n, quad: r, start: o}) {
        this.dataset = e,
        this.end = n,
        this.quad = r,
        this.start = o
    }
    get term() {
        return this.quad[this.end]
    }
    get graph() {
        return this.quad.graph
    }
    get startTerm() {
        return this.quad[this.start]
    }
}
function ah(i) {
    try {
        return $t(i)
    } catch {
        return null
    }
}
class Xt {
    constructor(e) {
        if (this.index = new Map,
        e)
            for (const n of e)
                this.add(n)
    }
    get size() {
        return this.index.size
    }
    add(e) {
        const n = $t(e);
        return this.index.has(n) || this.index.set(n, e),
        this
    }
    clear() {
        this.index.clear()
    }
    delete(e) {
        return e ? this.index.delete(ah(e)) : !1
    }
    entries() {
        return this.values().entries()
    }
    forEach(e, n) {
        return this.values().forEach(e, n)
    }
    has(e) {
        return e ? this.index.has(ah(e)) : !1
    }
    values() {
        return new Set(this.index.values())
    }
    keys() {
        return this.values()
    }
    [Symbol.iterator]() {
        return this.index.values()
    }
}
class up {
    constructor(e) {
        this.value = e
    }
    equals(e) {
        return !!e && e.termType === this.termType && e.value === this.value
    }
}
up.prototype.termType = "BlankNode";
class tu {
    equals(e) {
        return !!e && e.termType === this.termType
    }
}
tu.prototype.termType = "DefaultGraph";
tu.prototype.value = "";
function lh(i, e) {
    if (!e)
        return null;
    if (e.termType === "BlankNode")
        return i.blankNode(e.value);
    if (e.termType === "DefaultGraph")
        return i.defaultGraph();
    if (e.termType === "Literal")
        return i.literal(e.value, e.language || i.namedNode(e.datatype.value));
    if (e.termType === "NamedNode")
        return i.namedNode(e.value);
    if (e.termType === "Quad") {
        const n = i.fromTerm(e.subject)
          , r = i.fromTerm(e.predicate)
          , o = i.fromTerm(e.object)
          , a = i.fromTerm(e.graph);
        return i.quad(n, r, o, a)
    }
    if (e.termType === "Variable")
        return i.variable(e.value);
    throw new Error(`unknown termType ${e.termType}`)
}
class ks {
    constructor(e, n, r, o="") {
        this.value = e,
        this.language = n,
        this.datatype = r,
        this.direction = o
    }
    equals(e) {
        return !!e && e.termType === this.termType && e.value === this.value && e.language === this.language && e.datatype.equals(this.datatype) && (e.direction || "") === this.direction
    }
}
ks.prototype.termType = "Literal";
class Zr {
    constructor(e) {
        this.value = e
    }
    equals(e) {
        return !!e && e.termType === this.termType && e.value === this.value
    }
}
Zr.prototype.termType = "NamedNode";
class nu {
    constructor(e, n, r, o) {
        this.subject = e,
        this.predicate = n,
        this.object = r,
        this.graph = o
    }
    equals(e) {
        return !!e && (e.termType === "Quad" || !e.termType) && e.subject.equals(this.subject) && e.predicate.equals(this.predicate) && e.object.equals(this.object) && e.graph.equals(this.graph)
    }
}
nu.prototype.termType = "Quad";
nu.prototype.value = "";
class cp {
    constructor(e) {
        this.value = e
    }
    equals(e) {
        return !!e && e.termType === this.termType && e.value === this.value
    }
}
cp.prototype.termType = "Variable";
const hy = new Zr("http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString")
  , uh = new Zr("http://www.w3.org/1999/02/22-rdf-syntax-ns#langString")
  , fy = new Zr("http://www.w3.org/2001/XMLSchema#string");
class dp {
    constructor() {
        this.init()
    }
    init() {
        this._data = {
            blankNodeCounter: 0,
            defaultGraph: new tu
        }
    }
    namedNode(e) {
        return new Zr(e)
    }
    blankNode(e) {
        return e = e || "b" + ++this._data.blankNodeCounter,
        new up(e)
    }
    literal(e, n) {
        return typeof n == "string" ? new ks(e,n,uh) : typeof n?.language == "string" ? new ks(e,n.language,n.direction ? hy : uh,n.direction) : new ks(e,"",n || fy)
    }
    variable(e) {
        return new cp(e)
    }
    defaultGraph() {
        return this._data.defaultGraph
    }
    quad(e, n, r, o=this.defaultGraph()) {
        return new nu(e,n,r,o)
    }
    fromTerm(e) {
        return lh(this, e)
    }
    fromQuad(e) {
        return lh(this, e)
    }
}
dp.exports = ["blankNode", "defaultGraph", "fromQuad", "fromTerm", "literal", "namedNode", "quad", "variable"];
const iu = new dp
  , py = {
    apply: (i,e,n)=>i(n[0]),
    get: (i,e)=>i(e)
};
function Kt(i, {factory: e=iu}={}) {
    const n = (r="")=>e.namedNode(`${i}${r.raw || r}`);
    return typeof Proxy > "u" ? n : new Proxy(n,py)
}
Kt("http://www.w3.org/2001/XMLSchema#");
const gn = Kt("http://www.w3.org/1999/02/22-rdf-syntax-ns#");
Kt("http://www.w3.org/2000/01/rdf-schema#");
class nt {
    static add({ptr: e, start: n, end: r, subjects: o=[null], predicates: a=[null], objects: l=[null], graphs: u, callback: f}={}) {
        if (!e.factory)
            throw new Error("add operation requires a factory");
        let h = ()=>{}
        ;
        f && (h = m=>{
            f(new oh({
                dataset: e.dataset,
                start: n,
                end: r,
                quad: m
            }))
        }
        );
        for (const m of o)
            for (const _ of a)
                for (const d of l)
                    for (const g of u) {
                        const b = {
                            subject: m,
                            predicate: _,
                            object: d,
                            graph: g
                        };
                        b[n] = e.term;
                        const T = e.factory.quad(b.subject, b.predicate, b.object, b.graph);
                        e.dataset.add(T),
                        h(T)
                    }
        return e
    }
    static addList({ptr: e, predicates: n, items: r, graphs: o}) {
        if (e.isAny())
            throw new Error("can't attach a list to an any ptr");
        for (const a of n)
            for (const l of o) {
                const u = r.map(()=>e.factory.blankNode());
                e.dataset.add(e.factory.quad(e.term, a, u[0] || gn.nil, l));
                for (let f = 0; f < u.length; f++)
                    e.dataset.add(e.factory.quad(u[f], gn.first, r[f], l)),
                    e.dataset.add(e.factory.quad(u[f], gn.rest, u[f + 1] || gn.nil, l))
            }
        return e
    }
    static delete({ptr: e, start: n, subjects: r=[null], predicates: o=[null], objects: a=[null]}) {
        for (const l of r)
            for (const u of o)
                for (const f of a) {
                    const h = {
                        subject: l,
                        predicate: u,
                        object: f
                    };
                    h[n] = e.term;
                    const m = e.dataset.match(h.subject, h.predicate, h.object);
                    for (const _ of m)
                        e.dataset.delete(_)
                }
        return e
    }
    static deleteList({ptr: e, predicates: n}) {
        const r = [];
        for (const o of n)
            for (const a of e.dataset.match(e.term, o)) {
                let l = a.object;
                for (r.push(a); !gn.nil.equals(l); ) {
                    l = r[r.length - 1].object;
                    const u = e.dataset.match(l);
                    if (u.size === 0)
                        break;
                    for (const f of u)
                        r.push(f)
                }
            }
        for (const o of r)
            e.dataset.delete(o);
        return e
    }
    static execute({ptr: e, operation: n="traverse", quantifier: r, start: o, end: a, subjects: l, predicates: u, objects: f, graphs: h, items: m, callback: _}={}) {
        if (n === "add")
            return nt.add({
                ptr: e,
                start: o,
                end: a,
                subjects: l,
                predicates: u,
                objects: f,
                graphs: h,
                callback: _
            });
        if (n === "addList")
            return nt.addList({
                ptr: e,
                predicates: u,
                items: m,
                graphs: h
            });
        if (n === "delete")
            return nt.delete({
                ptr: e,
                start: o,
                subjects: l,
                predicates: u,
                objects: f
            });
        if (n === "deleteList")
            return nt.deleteList({
                ptr: e,
                predicates: u
            });
        if (n === "isList")
            return nt.isList({
                ptr: e
            });
        if (n === "list")
            return nt.list({
                ptr: e
            });
        if (n === "traverse")
            return nt.traverse({
                ptr: e,
                quantifier: r,
                start: o,
                end: a,
                subjects: l,
                predicates: u,
                objects: f,
                graphs: h
            });
        throw new Error(`unknown operation ${n}`)
    }
    static isList({ptr: e}) {
        return e.isAny() ? !1 : !!(gn.nil.equals(e.term) || nt.traverse({
            ptr: e,
            predicates: [gn.first]
        }).length === 1)
    }
    static list({ptr: e}) {
        if (e.isList())
            return {
                *[Symbol.iterator]() {
                    for (; e && !e.term.equals(gn.nil); ) {
                        const n = e.out([gn.first]);
                        if (n.length !== 1)
                            throw new Error(`Invalid list: rdf:first count not equals one on ${e.value}`);
                        const r = e.out([gn.rest]);
                        if (r.length !== 1)
                            throw new Error(`Invalid list: rdf:rest count not equals one on ${e.value}`);
                        yield n[0],
                        e = r[0]
                    }
                }
            }
    }
    static traverse({ptr: e, quantifier: n="one", start: r="subject", end: o="object", subjects: a=[null], predicates: l=[null], objects: u=[null], graphs: f=[null], callback: h}) {
        if (n === "one")
            return nt.traverseOne({
                ptr: e,
                start: r,
                end: o,
                subjects: a,
                predicates: l,
                objects: u,
                graphs: f,
                callback: h
            });
        if (n === "oneOrMore") {
            const m = nt.traverse({
                ptr: e,
                end: o,
                start: r,
                subjects: a,
                predicates: l,
                objects: u,
                graphs: f,
                callback: h
            });
            return nt.traverseMore({
                ptrs: m,
                end: o,
                start: r,
                subjects: a,
                predicates: l,
                objects: u,
                graphs: f,
                callback: h
            })
        }
        if (n === "zeroOrMore")
            return nt.traverseMore({
                ptrs: [e],
                end: o,
                start: r,
                subjects: a,
                predicates: l,
                objects: u,
                graphs: f,
                callback: h
            });
        if (n === "zeroOrOne")
            return [e, ...nt.traverse({
                ptr: e,
                end: o,
                start: r,
                subjects: a,
                predicates: l,
                objects: u,
                graphs: f,
                callback: h
            })];
        throw new Error(`unknown quantifier ${n}`)
    }
    static traverseMore({ptrs: e, end: n, start: r, subjects: o, predicates: a, objects: l, graphs: u, callback: f}={}) {
        let h = [...e], m, _;
        do {
            m = [];
            for (const d of e)
                m = [...m, ...nt.traverseOne({
                    ptr: d,
                    end: n,
                    start: r,
                    subjects: o,
                    predicates: a,
                    objects: l,
                    graphs: u,
                    callback: f
                })];
            _ && (m = m.filter(d=>!_.has(d.term))),
            e = m,
            h = [...h, ...m],
            _ = new Xt(h.map(d=>d.term))
        } while (m.length > 0);
        return h
    }
    static traverseOne({ptr: e, start: n, end: r, subjects: o, predicates: a, objects: l, graphs: u, callback: f=(h,m)=>m.extend(h)}={}) {
        const h = [];
        for (const m of o)
            for (const _ of a)
                for (const d of l)
                    for (const g of u) {
                        const b = {
                            subject: m,
                            predicate: _,
                            object: d,
                            graph: g
                        };
                        b[n] = e.term;
                        for (const T of e.dataset.match(b.subject, b.predicate, b.object, b.graph))
                            h.push(f(new oh({
                                dataset: e.dataset,
                                end: r,
                                quad: T,
                                start: n
                            }), e))
                    }
        return h
    }
}
function ch(i, e) {
    return e ? n=>e(i.extend(n)) : ()=>{}
}
class dh {
    constructor({dataset: e, edges: n=[], factory: r, graph: o, term: a}) {
        if (!e && n.length === 0)
            throw new Error("dataset or edges is required");
        if (n.length === 0 && typeof a > "u")
            throw new Error("edges or term must be given");
        if (n.length > 0 && a)
            throw new Error("edges or term must be given");
        this.dataset = e || n[n.length - 1].dataset,
        this.edges = n,
        this.factory = r,
        this._graph = o,
        n.length === 0 && (this._term = a)
    }
    get edge() {
        return this.edges[this.edges.length - 1]
    }
    get graph() {
        return typeof this._graph == "object" ? this._graph : this.edge && this.edge.graph
    }
    get length() {
        return this._term !== void 0 ? 1 : this.edges.length + 1
    }
    get startTerm() {
        return this._term || this.edges[0].startTerm
    }
    get term() {
        return this._term !== void 0 ? this._term : this.edge.term
    }
    get value() {
        const e = this.term;
        return e === null ? void 0 : e.value
    }
    addIn(e, n, r) {
        return nt.add({
            ptr: this,
            start: "object",
            end: "subject",
            subjects: n,
            predicates: e,
            graphs: [this.graph || this.factory.defaultGraph()],
            callback: ch(this, r)
        })
    }
    addList(e, n) {
        return nt.addList({
            ptr: this,
            predicates: e,
            graphs: [this.graph || this.factory.defaultGraph()],
            items: n
        })
    }
    addOut(e, n, r) {
        return nt.add({
            ptr: this,
            start: "subject",
            end: "object",
            predicates: e,
            objects: n,
            graphs: [this.graph || this.factory.defaultGraph()],
            callback: ch(this, r)
        })
    }
    deleteIn(e, n) {
        return nt.delete({
            ptr: this,
            start: "object",
            subjects: n,
            predicates: e
        })
    }
    deleteList(e) {
        return nt.deleteList({
            ptr: this,
            predicates: e
        })
    }
    deleteOut(e, n) {
        return nt.delete({
            ptr: this,
            start: "subject",
            predicates: e,
            objects: n
        })
    }
    execute({operation: e, quantifier: n, start: r, end: o, subjects: a, predicates: l, objects: u, graphs: f, items: h, callback: m}) {
        return nt.execute({
            ptr: this,
            operation: e,
            quantifier: n,
            start: r,
            end: o,
            subjects: a,
            predicates: l,
            objects: u,
            graphs: f,
            items: h,
            callback: m
        })
    }
    extend(e) {
        return new this.constructor({
            dataset: this.dataset,
            edges: [...this.edges, e],
            factory: this.factory,
            graph: this._graph
        })
    }
    hasIn(e, n) {
        return nt.traverse({
            ptr: this,
            start: "object",
            end: "object",
            subjects: n,
            predicates: e,
            graphs: [this.graph]
        })
    }
    hasOut(e, n) {
        return nt.traverse({
            ptr: this,
            start: "subject",
            end: "subject",
            predicates: e,
            objects: n,
            graphs: [this.graph]
        })
    }
    in(e, n) {
        return nt.traverse({
            ptr: this,
            start: "object",
            end: "subject",
            subjects: n,
            predicates: e,
            graphs: [this.graph]
        })
    }
    isAny() {
        return !this.term
    }
    isList() {
        return nt.isList({
            ptr: this
        })
    }
    list() {
        return nt.list({
            ptr: this
        })
    }
    *nodes() {
        for (let e = 0; e < this.length; e++)
            this._term !== void 0 ? yield{
                dataset: this.dataset,
                term: this._term
            } : this.edges.length > e ? yield{
                dataset: this.edges[e].dataset,
                term: this.edges[e].startTerm
            } : this.edges.length === e && (yield{
                dataset: this.edges[e - 1].dataset,
                term: this.edges[e - 1].term
            })
    }
    out(e, n) {
        return nt.traverse({
            ptr: this,
            predicates: e,
            objects: n,
            graphs: [this.graph]
        })
    }
    *quads() {
        for (const {quad: e} of this.edges)
            yield e
    }
    trim() {
        return new this.constructor({
            dataset: this.dataset,
            factory: this.factory,
            graph: this.graph,
            term: this.term
        })
    }
}
function hh(i, e) {
    return i ? i.equals(e) : i === e
}
function gy(i, e) {
    return !(i.dataset !== e.dataset || !hh(i.graph, e.graph) || !hh(i.term, e.term))
}
function fh(i, e) {
    return e ? n=>e(new i.constructor({
        factory: i.factory,
        ptrs: [n]
    })) : ()=>{}
}
class $s {
    constructor({dataset: e, factory: n, ptrs: r, terms: o, graphs: a}) {
        if (this.factory = n,
        r)
            this.ptrs = [...r];
        else {
            this.ptrs = [];
            for (const l of o || [null])
                for (const u of a || [null])
                    this.ptrs.push(new dh({
                        dataset: e,
                        factory: n,
                        graph: u,
                        term: l
                    }))
        }
    }
    get dataset() {
        const e = new Set(this.datasets);
        return e.size !== 1 ? null : e[Symbol.iterator]().next().value
    }
    get datasets() {
        return this.ptrs.map(e=>e.dataset)
    }
    get term() {
        const e = new Xt(this.terms);
        if (e.size === 1)
            return e[Symbol.iterator]().next().value
    }
    get terms() {
        return this.ptrs.map(e=>e.term)
    }
    get value() {
        const e = this.term;
        return e?.value
    }
    get values() {
        return this.ptrs.map(e=>e.value)
    }
    addIn(e, n, r) {
        const o = fh(this, r);
        for (const a of this.ptrs)
            a.addIn(e, n, o);
        return this
    }
    addList(e, n) {
        if (this.isAny())
            throw new Error("can't attach a list to an any ptr");
        for (const r of this.ptrs)
            r.addList(e, n);
        return this
    }
    addOut(e, n, r) {
        const o = fh(this, r);
        for (const a of this.ptrs)
            a.addOut(e, n, o);
        return this
    }
    clone(e) {
        return new this.constructor({
            factory: this.factory,
            ptrs: this.ptrs,
            ...e
        })
    }
    deleteIn(e, n) {
        for (const r of this.ptrs)
            r.deleteIn(e, n);
        return this
    }
    deleteList(e) {
        for (const n of this.ptrs)
            n.deleteList(e);
        return this
    }
    deleteOut(e, n) {
        for (const r of this.ptrs)
            r.deleteOut(e, n);
        return this
    }
    distinct() {
        const e = this.ptrs.reduce((n,r)=>(n.some(o=>gy(o, r)) || n.push(r.trim()),
        n), []);
        return this.clone({
            ptrs: e
        })
    }
    execute(e) {
        return this.clone({
            ptrs: this.ptrs.flatMap(n=>n.execute(e))
        })
    }
    executeAll(e) {
        let n = this;
        for (const r of e)
            n = n.execute(r);
        return n
    }
    filter(e) {
        return this.clone({
            ptrs: [...this].filter(e).map(n=>n.ptrs[0])
        })
    }
    hasIn(e, n) {
        return this.clone({
            ptrs: this.ptrs.flatMap(r=>r.hasIn(e, n))
        })
    }
    hasOut(e, n) {
        return this.clone({
            ptrs: this.ptrs.flatMap(r=>r.hasOut(e, n))
        })
    }
    in(e, n) {
        return this.clone({
            ptrs: this.ptrs.flatMap(r=>r.in(e, n))
        })
    }
    isAny() {
        return this.ptrs.length > 0 && this.ptrs.some(e=>e.isAny())
    }
    isList() {
        return this.ptrs.length !== 1 ? !1 : this.ptrs[0].isList()
    }
    list() {
        if (!this.isList())
            return;
        const e = this.ptrs[0].list()
          , n = this;
        return (function*() {
            for (const r of e)
                yield n.clone({
                    ptrs: [r]
                })
        }
        )()
    }
    map(e) {
        return [...this].map(e)
    }
    node(e) {
        const n = this.dataset
          , r = [...e].map(o=>new dh({
            dataset: n,
            factory: this.factory,
            term: o
        }));
        return this.clone({
            ptrs: r
        })
    }
    out(e, n) {
        return this.clone({
            ptrs: this.ptrs.flatMap(r=>r.out(e, n))
        })
    }
    *quads() {
        for (const {edges: e} of this.ptrs)
            for (const {quad: n} of e)
                yield n
    }
    trim() {
        return this.clone({
            ptrs: this.ptrs.map(e=>e.trim())
        })
    }
    *[Symbol.iterator]() {
        for (const e of this.ptrs)
            yield this.clone({
                ptrs: [e]
            })
    }
}
Kt("http://www.w3.org/2002/07/owl#");
const wi = Kt("http://www.w3.org/1999/02/22-rdf-syntax-ns#")
  , my = Kt("http://www.w3.org/2000/01/rdf-schema#")
  , ge = Kt("http://www.w3.org/ns/shacl#")
  , Ll = Kt("https://schemas.link/shacl-next#")
  , ru = Kt("http://www.w3.org/2001/XMLSchema#");
function _y(i) {
    return i ? `{${[...i.quads()].map(e=>$t(e)).join(" ")}}` : "{}"
}
function yy(i) {
    return i ? `{${i.map(e=>_y(e)).join(" ")}}` : "{}"
}
var Ya, ph;
function vy() {
    if (ph)
        return Ya;
    ph = 1;
    var i = /\s/;
    function e(n) {
        for (var r = n.length; r-- && i.test(n.charAt(r)); )
            ;
        return r
    }
    return Ya = e,
    Ya
}
var el, gh;
function by() {
    if (gh)
        return el;
    gh = 1;
    var i = vy()
      , e = /^\s+/;
    function n(r) {
        return r && r.slice(0, i(r) + 1).replace(e, "")
    }
    return el = n,
    el
}
var tl, mh;
function wy() {
    if (mh)
        return tl;
    mh = 1;
    function i(e) {
        var n = typeof e;
        return e != null && (n == "object" || n == "function")
    }
    return tl = i,
    tl
}
var nl, _h;
function xy() {
    if (_h)
        return nl;
    _h = 1;
    var i = typeof Fi == "object" && Fi && Fi.Object === Object && Fi;
    return nl = i,
    nl
}
var il, yh;
function Ey() {
    if (yh)
        return il;
    yh = 1;
    var i = xy()
      , e = typeof self == "object" && self && self.Object === Object && self
      , n = i || e || Function("return this")();
    return il = n,
    il
}
var rl, vh;
function hp() {
    if (vh)
        return rl;
    vh = 1;
    var i = Ey()
      , e = i.Symbol;
    return rl = e,
    rl
}
var sl, bh;
function Sy() {
    if (bh)
        return sl;
    bh = 1;
    var i = hp()
      , e = Object.prototype
      , n = e.hasOwnProperty
      , r = e.toString
      , o = i ? i.toStringTag : void 0;
    function a(l) {
        var u = n.call(l, o)
          , f = l[o];
        try {
            l[o] = void 0;
            var h = !0
        } catch {}
        var m = r.call(l);
        return h && (u ? l[o] = f : delete l[o]),
        m
    }
    return sl = a,
    sl
}
var ol, wh;
function Ty() {
    if (wh)
        return ol;
    wh = 1;
    var i = Object.prototype
      , e = i.toString;
    function n(r) {
        return e.call(r)
    }
    return ol = n,
    ol
}
var al, xh;
function Ly() {
    if (xh)
        return al;
    xh = 1;
    var i = hp()
      , e = Sy()
      , n = Ty()
      , r = "[object Null]"
      , o = "[object Undefined]"
      , a = i ? i.toStringTag : void 0;
    function l(u) {
        return u == null ? u === void 0 ? o : r : a && a in Object(u) ? e(u) : n(u)
    }
    return al = l,
    al
}
var ll, Eh;
function Iy() {
    if (Eh)
        return ll;
    Eh = 1;
    function i(e) {
        return e != null && typeof e == "object"
    }
    return ll = i,
    ll
}
var ul, Sh;
function Ny() {
    if (Sh)
        return ul;
    Sh = 1;
    var i = Ly()
      , e = Iy()
      , n = "[object Symbol]";
    function r(o) {
        return typeof o == "symbol" || e(o) && i(o) == n
    }
    return ul = r,
    ul
}
var cl, Th;
function Ay() {
    if (Th)
        return cl;
    Th = 1;
    var i = by()
      , e = wy()
      , n = Ny()
      , r = NaN
      , o = /^[-+]0x[0-9a-f]+$/i
      , a = /^0b[01]+$/i
      , l = /^0o[0-7]+$/i
      , u = parseInt;
    function f(h) {
        if (typeof h == "number")
            return h;
        if (n(h))
            return r;
        if (e(h)) {
            var m = typeof h.valueOf == "function" ? h.valueOf() : h;
            h = e(m) ? m + "" : m
        }
        if (typeof h != "string")
            return h === 0 ? h : +h;
        h = i(h);
        var _ = a.test(h);
        return _ || l.test(h) ? u(h.slice(2), _ ? 2 : 8) : o.test(h) ? r : +h
    }
    return cl = f,
    cl
}
var dl, Lh;
function Ry() {
    if (Lh)
        return dl;
    Lh = 1;
    var i = Ay()
      , e = 1 / 0
      , n = 17976931348623157e292;
    function r(o) {
        if (!o)
            return o === 0 ? o : 0;
        if (o = i(o),
        o === e || o === -e) {
            var a = o < 0 ? -1 : 1;
            return a * n
        }
        return o === o ? o : 0
    }
    return dl = r,
    dl
}
var hl, Ih;
function Cy() {
    if (Ih)
        return hl;
    Ih = 1;
    var i = Ry();
    function e(n) {
        var r = i(n)
          , o = r % 1;
        return r === r ? o ? r - o : r : 0
    }
    return hl = e,
    hl
}
var fl, Nh;
function ky() {
    if (Nh)
        return fl;
    Nh = 1;
    var i = Cy()
      , e = "Expected a function";
    function n(r, o) {
        var a;
        if (typeof o != "function")
            throw new TypeError(e);
        return r = i(r),
        function() {
            return --r > 0 && (a = o.apply(this, arguments)),
            r <= 1 && (o = void 0),
            a
        }
    }
    return fl = n,
    fl
}
var pl, Ah;
function Py() {
    if (Ah)
        return pl;
    Ah = 1;
    var i = ky();
    function e(n) {
        return i(2, n)
    }
    return pl = e,
    pl
}
var My = Py();
const sn = ef(My);
let Rh = class {
    constructor({details: e, factory: n, options: r, results: o=[]}={}) {
        this.details = e,
        this.factory = n,
        this.options = r,
        this.results = o,
        this._conforms = sn(()=>!this.results.some(a=>a.severity.equals(ge.Info) || a.severity.equals(ge.Violation) || a.severity.equals(ge.Warning))),
        this._ptr = sn(()=>this.build())
    }
    get conforms() {
        return this._conforms()
    }
    get dataset() {
        return this.ptr.dataset
    }
    get ptr() {
        return this._ptr()
    }
    get term() {
        return this.ptr.term
    }
    build() {
        const e = new $s({
            dataset: this.factory.dataset(),
            factory: this.factory,
            terms: [this.factory.blankNode()]
        });
        e.addOut([wi.type], [ge.ValidationReport]).addOut([ge.conforms], [this.factory.literal(this.conforms.toString(), ru.boolean)]);
        for (const n of this.results)
            e.addOut([ge.result], [this.factory.blankNode()], r=>{
                n.build(r, this.options)
            }
            );
        return e
    }
    coverage() {
        return this.results.flatMap(e=>e.coverage())
    }
}
;
function Dy(i, e) {
    return Object.entries(e).reduce((n,[r,o])=>(o && o.termType && (o = $t(o)),
    n.replace(`{$ ${r}}`, o).replace(`{?${r}}`, o)), i)
}
let Oy = class {
    constructor({args: e={}, constraintComponent: n, factory: r, focusNode: o, message: a=[], path: l, results: u=[], severity: f, shape: h, source: m=[], value: _, valuePaths: d=[]}={}) {
        this.args = e,
        this.constraintComponent = n,
        this.factory = r,
        this.focusNode = o,
        this.path = l || h.path,
        this.results = u,
        this.severity = f,
        this.shape = h,
        this.source = m,
        this.value = _,
        this.valuePaths = d,
        this._message = sn(()=>(this.shape.message.length > 0 && (a = this.shape.message),
        a.length === 0 && (a = this.shape.ptr.node([this.constraintComponent]).out([ge.message]).terms),
        a.map(g=>r.literal(Dy(g.value, e), g.language || null))))
    }
    get message() {
        return this._message()
    }
    build(e, {details: n}={}) {
        e.addOut([wi.type], [ge.ValidationResult]).addOut([ge.focusNode], this.focusNode.terms).addOut([ge.resultSeverity], [this.severity]).addOut([ge.sourceConstraint], this.source).addOut([ge.sourceConstraintComponent], [this.constraintComponent]).addOut([ge.sourceShape], this.shape.ptr.terms),
        this.message && e.addOut([ge.resultMessage], this.message);
        const r = o=>{
            if (o.quantifier === "one")
                return o.predicates.length > 1 ? e.node([this.factory.blankNode()]).addList([ge.alternativePath], o.predicates) : o.start === "object" ? e.node([this.factory.blankNode()]).addOut([ge.inversePath], [o.predicates[0]]) : e.node([o.predicates[0]]);
            if (o.quantifier === "oneOrMore")
                return e.node([this.factory.blankNode()]).addOut([ge.oneOrMorePath], [o.predicates[0]]);
            if (o.quantifier === "zeroOrMore")
                return e.node([this.factory.blankNode()]).addOut([ge.zeroOrMorePath], [o.predicates[0]]);
            if (o.quantifier === "zeroOrOne")
                return e.node([this.factory.blankNode()]).addOut([ge.zeroOrOnePath], [o.predicates[0]])
        }
        ;
        if (this.path && (this.path.length === 1 ? e.addOut([ge.resultPath], r(this.path[0]).terms) : e.addList([ge.resultPath], this.path.map(o=>r(o).term))),
        typeof this.value < "u" && e.addOut([ge.value], this.value.terms),
        n)
            for (const o of this.results)
                e.addOut([ge.detail], [this.factory.blankNode()], a=>{
                    o.build(a, {
                        details: n
                    })
                }
                )
    }
    coverage() {
        return [...this.valuePaths.flatMap(e=>[...e.quads()]), ...this.results.flatMap(e=>e.coverage())]
    }
}
;
class su {
    constructor({factory: e, focusNode: n, options: r={
        debug: !1,
        details: !1
    }, processed: o=new Set, report: a=new Rh({
        factory: e,
        options: r
    }), results: l=new Map, shape: u, value: f, valueOrNode: h, valuePaths: m, values: _}={}) {
        this.factory = e,
        this.focusNode = n,
        this.options = r,
        this.processed = o,
        this.report = a,
        this.results = l,
        this.shape = u,
        this.value = f,
        this.valuePaths = m,
        this.valueOrNode = h,
        this.values = _
    }
    create({child: e, focusNode: n=this.focusNode, shape: r=this.shape, value: o=this.value, valueOrNode: a=this.valueOrNode, valuePaths: l=this.valuePaths, values: u=this.values}={}) {
        return new su({
            factory: this.factory,
            focusNode: n,
            options: this.options,
            processed: this.processed,
            report: e ? new Rh({
                factory: this.factory,
                options: this.options
            }) : this.report,
            results: this.results,
            shape: r,
            value: o,
            valueOrNode: a,
            valuePaths: l,
            values: u
        })
    }
    id({shape: e=this.shape}={}) {
        return `${$t(e.ptr.term)} - ${$t(this.focusNode.term)} - ${yy(this.valuePaths)}`
    }
    result(e) {
        const n = new Oy({
            factory: this.factory,
            focusNode: this.focusNode,
            shape: this.shape,
            value: this.value,
            valuePaths: this.valuePaths,
            ...e
        })
          , r = this.id();
        this.results.has(r) ? this.results.get(r).add(n) : this.results.set(r, new Set([n])),
        this.report.results.push(n)
    }
    debug(e, n) {
        this.options.debug && this.result({
            severity: Ll.Debug,
            constraintComponent: e,
            ...n
        })
    }
    trace(e, n) {
        this.options.trace && this.result({
            severity: Ll.Trace,
            constraintComponent: e,
            ...n
        })
    }
    test(e, n, r) {
        e ? this.debug(n, r) : this.violation(n, r)
    }
    violation(e, n) {
        this.result({
            constraintComponent: e,
            severity: this.shape.severity || ge.Violation,
            ...n
        })
    }
}
function Fy() {
    return {
        generic: jy()
    }
}
function jy() {
    return i=>{
        i.trace(Ll.TraversalConstraintComponent, {
            args: {},
            message: [i.factory.literal("Traversal")],
            value: i.valueOrNode
        })
    }
}
class By {
    constructor(e) {
        this.validations = new Zi(e)
    }
    compile(e) {
        const n = e.validator.options.coverage;
        if (e.deactivated)
            return [];
        let r = !1;
        const o = new Set;
        for (const a of e.ptr.execute({
            start: "subject",
            end: "predicate"
        })) {
            const l = this.validations.get(a.term);
            l && (o.add(l),
            a.term.equals(ge.property) && (r = !0))
        }
        return n && e.isPropertyShape && !r && o.add(Fy),
        [...o].map(a=>a(e)).filter(Boolean)
    }
}
var ui = {}, ci = {}, Sr = {}, Tr = {}, Ch;
function Ui() {
    if (Ch)
        return Tr;
    Ch = 1,
    Object.defineProperty(Tr, "__esModule", {
        value: !0
    }),
    Tr.Translator = void 0;
    let i = class {
        constructor() {
            this.supportedRdfDatatypes = [],
            this.fromRdfHandlers = {},
            this.toRdfHandlers = {}
        }
        static incorrectRdfDataType(n) {
            throw new Error(`Invalid RDF ${n.datatype.value} value: '${n.value}'`)
        }
        registerHandler(n, r, o) {
            for (const a of r)
                this.supportedRdfDatatypes.push(a),
                this.fromRdfHandlers[a.value] = n;
            for (const a of o) {
                let l = this.toRdfHandlers[a];
                l || (this.toRdfHandlers[a] = l = []),
                l.push(n)
            }
        }
        fromRdf(n, r) {
            const o = this.fromRdfHandlers[n.datatype.value];
            return o ? o.fromRdf(n, r) : n.value
        }
        toRdf(n, r) {
            const o = this.toRdfHandlers[typeof n];
            if (o)
                for (const a of o) {
                    const l = a.toRdf(n, r);
                    if (l)
                        return l
                }
            throw new Error(`Invalid JavaScript value: '${n}'`)
        }
        getSupportedRdfDatatypes() {
            return this.supportedRdfDatatypes
        }
        getSupportedJavaScriptPrimitives() {
            return Object.keys(this.toRdfHandlers)
        }
    }
    ;
    return Tr.Translator = i,
    Tr
}
var kh;
function $y() {
    if (kh)
        return Sr;
    kh = 1,
    Object.defineProperty(Sr, "__esModule", {
        value: !0
    }),
    Sr.TypeHandlerBoolean = void 0;
    const i = Ui();
    let e = class fp {
        fromRdf(r, o) {
            switch (r.value) {
            case "true":
                return !0;
            case "false":
                return !1;
            case "1":
                return !0;
            case "0":
                return !1
            }
            return o && i.Translator.incorrectRdfDataType(r),
            !1
        }
        toRdf(r, {datatype: o, dataFactory: a}) {
            return a.literal(r ? "true" : "false", o || a.namedNode(fp.TYPE))
        }
    }
    ;
    return Sr.TypeHandlerBoolean = e,
    e.TYPE = "http://www.w3.org/2001/XMLSchema#boolean",
    Sr
}
var Lr = {}, Ph;
function qy() {
    if (Ph)
        return Lr;
    Ph = 1,
    Object.defineProperty(Lr, "__esModule", {
        value: !0
    }),
    Lr.TypeHandlerDate = void 0;
    const i = Ui();
    let e = class Il {
        fromRdf(r, o) {
            switch (o && !r.value.match(Il.VALIDATORS[r.datatype.value.substr(33, r.datatype.value.length)]) && i.Translator.incorrectRdfDataType(r),
            r.datatype.value) {
            case "http://www.w3.org/2001/XMLSchema#gDay":
                return new Date(0,0,parseInt(r.value, 10));
            case "http://www.w3.org/2001/XMLSchema#gMonthDay":
                const a = r.value.split("-");
                return new Date(0,parseInt(a[0], 10) - 1,parseInt(a[1], 10));
            case "http://www.w3.org/2001/XMLSchema#gYear":
                return new Date(r.value + "-01-01");
            case "http://www.w3.org/2001/XMLSchema#gYearMonth":
                return new Date(r.value + "-01");
            default:
                return new Date(r.value)
            }
        }
        toRdf(r, {datatype: o, dataFactory: a}) {
            if (o = o || a.namedNode(Il.TYPES[0]),
            !(r instanceof Date))
                return null;
            const l = r;
            let u;
            switch (o.value) {
            case "http://www.w3.org/2001/XMLSchema#gDay":
                u = String(l.getUTCDate());
                break;
            case "http://www.w3.org/2001/XMLSchema#gMonthDay":
                u = l.getUTCMonth() + 1 + "-" + l.getUTCDate();
                break;
            case "http://www.w3.org/2001/XMLSchema#gYear":
                u = String(l.getUTCFullYear());
                break;
            case "http://www.w3.org/2001/XMLSchema#gYearMonth":
                u = l.getUTCFullYear() + "-" + (l.getUTCMonth() + 1);
                break;
            case "http://www.w3.org/2001/XMLSchema#date":
                u = l.toISOString().replace(/T.*$/, "");
                break;
            default:
                u = l.toISOString()
            }
            return a.literal(u, o)
        }
    }
    ;
    return Lr.TypeHandlerDate = e,
    e.TYPES = ["http://www.w3.org/2001/XMLSchema#dateTime", "http://www.w3.org/2001/XMLSchema#date", "http://www.w3.org/2001/XMLSchema#gDay", "http://www.w3.org/2001/XMLSchema#gMonthDay", "http://www.w3.org/2001/XMLSchema#gYear", "http://www.w3.org/2001/XMLSchema#gYearMonth"],
    e.VALIDATORS = {
        date: /^[0-9]+-[0-9][0-9]-[0-9][0-9]Z?$/,
        dateTime: /^[0-9]+-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9](\.[0-9][0-9][0-9])?((Z?)|([\+-][0-9][0-9]:[0-9][0-9]))$/,
        gDay: /^[0-9]+$/,
        gMonthDay: /^[0-9]+-[0-9][0-9]$/,
        gYear: /^[0-9]+$/,
        gYearMonth: /^[0-9]+-[0-9][0-9]$/
    },
    Lr
}
var Ir = {}, Mh;
function zy() {
    if (Mh)
        return Ir;
    Mh = 1,
    Object.defineProperty(Ir, "__esModule", {
        value: !0
    }),
    Ir.TypeHandlerNumberDouble = void 0;
    const i = Ui();
    let e = class pp {
        fromRdf(r, o) {
            const a = parseFloat(r.value);
            return o && isNaN(a) && i.Translator.incorrectRdfDataType(r),
            a
        }
        toRdf(r, {datatype: o, dataFactory: a}) {
            return o = o || a.namedNode(pp.TYPES[0]),
            isNaN(r) ? a.literal("NaN", o) : isFinite(r) ? r % 1 === 0 ? null : a.literal(r.toExponential(15).replace(/(\d)0*e\+?/, "$1E"), o) : a.literal(r > 0 ? "INF" : "-INF", o)
        }
    }
    ;
    return Ir.TypeHandlerNumberDouble = e,
    e.TYPES = ["http://www.w3.org/2001/XMLSchema#double", "http://www.w3.org/2001/XMLSchema#decimal", "http://www.w3.org/2001/XMLSchema#float"],
    Ir
}
var Nr = {}, Dh;
function Uy() {
    if (Dh)
        return Nr;
    Dh = 1,
    Object.defineProperty(Nr, "__esModule", {
        value: !0
    }),
    Nr.TypeHandlerNumberInteger = void 0;
    const i = Ui();
    let e = class Pr {
        fromRdf(r, o) {
            const a = parseInt(r.value, 10);
            return o && (isNaN(a) || r.value.indexOf(".") >= 0) && i.Translator.incorrectRdfDataType(r),
            a
        }
        toRdf(r, {datatype: o, dataFactory: a}) {
            return a.literal(String(r), o || (r <= Pr.MAX_INT && r >= Pr.MIN_INT ? a.namedNode(Pr.TYPES[0]) : a.namedNode(Pr.TYPES[1])))
        }
    }
    ;
    return Nr.TypeHandlerNumberInteger = e,
    e.TYPES = ["http://www.w3.org/2001/XMLSchema#integer", "http://www.w3.org/2001/XMLSchema#long", "http://www.w3.org/2001/XMLSchema#int", "http://www.w3.org/2001/XMLSchema#byte", "http://www.w3.org/2001/XMLSchema#short", "http://www.w3.org/2001/XMLSchema#negativeInteger", "http://www.w3.org/2001/XMLSchema#nonNegativeInteger", "http://www.w3.org/2001/XMLSchema#nonPositiveInteger", "http://www.w3.org/2001/XMLSchema#positiveInteger", "http://www.w3.org/2001/XMLSchema#unsignedByte", "http://www.w3.org/2001/XMLSchema#unsignedInt", "http://www.w3.org/2001/XMLSchema#unsignedLong", "http://www.w3.org/2001/XMLSchema#unsignedShort"],
    e.MAX_INT = 2147483647,
    e.MIN_INT = -2147483648,
    Nr
}
var Ar = {}, Oh;
function Hy() {
    if (Oh)
        return Ar;
    Oh = 1,
    Object.defineProperty(Ar, "__esModule", {
        value: !0
    }),
    Ar.TypeHandlerString = void 0;
    let i = class {
        fromRdf(n) {
            return n.value
        }
        toRdf(n, {datatype: r, dataFactory: o}) {
            return o.literal(n, r)
        }
    }
    ;
    return Ar.TypeHandlerString = i,
    i.TYPES = ["http://www.w3.org/2001/XMLSchema#string", "http://www.w3.org/2001/XMLSchema#normalizedString", "http://www.w3.org/2001/XMLSchema#anyURI", "http://www.w3.org/2001/XMLSchema#base64Binary", "http://www.w3.org/2001/XMLSchema#language", "http://www.w3.org/2001/XMLSchema#Name", "http://www.w3.org/2001/XMLSchema#NCName", "http://www.w3.org/2001/XMLSchema#NMTOKEN", "http://www.w3.org/2001/XMLSchema#token", "http://www.w3.org/2001/XMLSchema#hexBinary", "http://www.w3.org/1999/02/22-rdf-syntax-ns#langString", "http://www.w3.org/1999/02/22-rdf-syntax-ns#dirLangString", "http://www.w3.org/2001/XMLSchema#time", "http://www.w3.org/2001/XMLSchema#duration"],
    Ar
}
var Fh;
function jh() {
    return Fh || (Fh = 1,
    (function(i) {
        var e = ci && ci.__createBinding || (Object.create ? (function(r, o, a, l) {
            l === void 0 && (l = a);
            var u = Object.getOwnPropertyDescriptor(o, a);
            (!u || ("get"in u ? !o.__esModule : u.writable || u.configurable)) && (u = {
                enumerable: !0,
                get: function() {
                    return o[a]
                }
            }),
            Object.defineProperty(r, l, u)
        }
        ) : (function(r, o, a, l) {
            l === void 0 && (l = a),
            r[l] = o[a]
        }
        ))
          , n = ci && ci.__exportStar || function(r, o) {
            for (var a in r)
                a !== "default" && !Object.prototype.hasOwnProperty.call(o, a) && e(o, r, a)
        }
        ;
        Object.defineProperty(i, "__esModule", {
            value: !0
        }),
        n($y(), i),
        n(qy(), i),
        n(zy(), i),
        n(Uy(), i),
        n(Hy(), i)
    }
    )(ci)),
    ci
}
var gl = {}, Bh;
function Vy() {
    return Bh || (Bh = 1,
    Object.defineProperty(gl, "__esModule", {
        value: !0
    })),
    gl
}
var $h;
function Gy() {
    return $h || ($h = 1,
    (function(i) {
        var e = ui && ui.__createBinding || (Object.create ? (function(g, b, T, N) {
            N === void 0 && (N = T);
            var A = Object.getOwnPropertyDescriptor(b, T);
            (!A || ("get"in A ? !b.__esModule : A.writable || A.configurable)) && (A = {
                enumerable: !0,
                get: function() {
                    return b[T]
                }
            }),
            Object.defineProperty(g, N, A)
        }
        ) : (function(g, b, T, N) {
            N === void 0 && (N = T),
            g[N] = b[T]
        }
        ))
          , n = ui && ui.__exportStar || function(g, b) {
            for (var T in g)
                T !== "default" && !Object.prototype.hasOwnProperty.call(b, T) && e(b, g, T)
        }
        ;
        Object.defineProperty(i, "__esModule", {
            value: !0
        }),
        i.fromRdf = f,
        i.toRdf = h,
        i.getTermRaw = m,
        i.getSupportedRdfDatatypes = _,
        i.getSupportedJavaScriptPrimitives = d;
        const r = Af()
          , o = jh()
          , a = Ui();
        n(jh(), i),
        n(Vy(), i),
        n(Ui(), i);
        const l = new r.DataFactory
          , u = new a.Translator;
        u.registerHandler(new o.TypeHandlerString, o.TypeHandlerString.TYPES.map(g=>l.namedNode(g)), ["string"]),
        u.registerHandler(new o.TypeHandlerBoolean, [o.TypeHandlerBoolean.TYPE].map(g=>l.namedNode(g)), ["boolean"]),
        u.registerHandler(new o.TypeHandlerNumberDouble, o.TypeHandlerNumberDouble.TYPES.map(g=>l.namedNode(g)), ["number"]),
        u.registerHandler(new o.TypeHandlerNumberInteger, o.TypeHandlerNumberInteger.TYPES.map(g=>l.namedNode(g)), ["number"]),
        u.registerHandler(new o.TypeHandlerDate, o.TypeHandlerDate.TYPES.map(g=>l.namedNode(g)), ["object"]);
        function f(g, b) {
            return u.fromRdf(g, b)
        }
        function h(g, b) {
            return b && "namedNode"in b && (b = {
                dataFactory: b
            }),
            b = b || {},
            b && !b.dataFactory && (b.dataFactory = l),
            u.toRdf(g, b)
        }
        function m(g, b) {
            return g.termType === "Literal" ? f(g, b) : g.value
        }
        function _() {
            return u.getSupportedRdfDatatypes()
        }
        function d() {
            return u.getSupportedJavaScriptPrimitives()
        }
    }
    )(ui)),
    ui
}
var Hr = Gy();
function qh(i) {
    if (i.term.termType !== "BlankNode")
        return {
            quantifier: "one",
            start: "subject",
            end: "object",
            predicates: [i.term]
        };
    const e = i.out([ge.alternativePath]);
    if (e.ptrs.length === 1 && e.ptrs[0].isList())
        return {
            quantifier: "one",
            start: "subject",
            end: "object",
            predicates: [...e.list()].map(l=>l.term)
        };
    const n = i.out([ge.inversePath]);
    if (n.term)
        return {
            quantifier: "one",
            start: "object",
            end: "subject",
            predicates: [n.term]
        };
    const r = i.out([ge.oneOrMorePath]);
    if (r.term)
        return {
            quantifier: "oneOrMore",
            start: "subject",
            end: "object",
            predicates: [r.term]
        };
    const o = i.out([ge.zeroOrMorePath]);
    if (o.term)
        return {
            quantifier: "zeroOrMore",
            start: "subject",
            end: "object",
            predicates: [o.term]
        };
    const a = i.out([ge.zeroOrOnePath]);
    if (a.term)
        return {
            quantifier: "zeroOrOne",
            start: "subject",
            end: "object",
            predicates: [a.term]
        }
}
function Wy(i) {
    return i.terms.length === 0 ? null : i.ptrs[0].isList() ? [...i.list()].map(e=>qh(e)) : [qh(i)]
}
class Zy {
    constructor(e) {
        this.shape = e,
        this._compiled = sn(()=>this.shape.validator.registry.compile(e))
    }
    get compiled() {
        return this._compiled()
    }
    async validate(e) {
        return e.focusNode.dataset.size === 0 || (this.shape.isPropertyShape ? await this.validateProperty(e) : await this.validateNode(e)),
        e
    }
    async validateNode(e) {
        const n = e.create({
            shape: this.shape,
            valueOrNode: e.value || e.focusNode
        });
        for (const r of this.compiled)
            r.node && await r.node(n),
            r.generic && await r.generic(n)
    }
    async validateProperty(e) {
        let n;
        this.shape.isSparqlShape ? n = e.focusNode : n = e.focusNode.executeAll(this.shape.path);
        const r = n.node(new Xt(n.terms))
          , o = [...n].reduce((l,u)=>{
            const f = u.term
              , h = n.node([f]);
            return l.has(f) || l.set(f, {
                value: h,
                valuePaths: []
            }),
            l.get(f).valuePaths.push(u),
            l
        }
        , new Zi).values()
          , a = e.create({
            shape: this.shape,
            values: r
        });
        for (const l of this.compiled)
            l.property && await l.property(a);
        for (const {value: l, valuePaths: u} of o) {
            const f = e.create({
                shape: this.shape,
                value: l,
                valueOrNode: l,
                valuePaths: u
            });
            for (const h of this.compiled)
                h.generic && await h.generic(f)
        }
    }
}
function Nl(i) {
    const e = new Xt
      , r = new $s({
        dataset: i.dataset,
        terms: i.terms
    }).execute({
        quantifier: "zeroOrMore",
        start: "object",
        end: "subject",
        predicates: [my.subClassOf]
    });
    for (const o of r.ptrs)
        for (const {term: a} of o.nodes())
            e.add(a);
    return e
}
class Xy {
    constructor(e) {
        this.targetClass = new Xt([...Nl(e.hasOut([wi.type], [ge.NodeShape])), ...Nl(e.out([ge.targetClass]))]),
        this.targetNode = e.out([ge.targetNode]).terms,
        this.targetObjectsOf = e.out([ge.targetObjectsOf]).terms,
        this.targetSubjectsOf = e.out([ge.targetSubjectsOf]).terms
    }
    resolve(e) {
        const n = e.focusNode.node([null])
          , r = [...e.focusNode.hasOut([wi.type], this.targetClass).ptrs, ...e.focusNode.node(this.targetNode).ptrs, ...n.execute({
            start: "object",
            end: "object",
            predicates: this.targetObjectsOf
        }).ptrs, ...n.execute({
            start: "subject",
            end: "subject",
            predicates: this.targetSubjectsOf
        }).ptrs]
          , o = e.focusNode.clone({
            ptrs: r
        });
        return o.node([...new Xt(o.terms)])
    }
}
class Qy {
    constructor(e, {validator: n}) {
        this.ptr = e,
        this.validator = n,
        this._deactivated = sn(()=>{
            const r = this.ptr.out([ge.deactivated]).term;
            return r && Hr.fromRdf(r)
        }
        ),
        this._message = sn(()=>this.ptr.out([ge.message]).terms),
        this._path = sn(()=>Wy(this.ptr.out([ge.path]))),
        this._severity = sn(()=>this.ptr.out([ge.severity]).term),
        this._shapeValidator = sn(()=>new Zy(this)),
        this._sparql = sn(()=>this.ptr.out([ge.sparql])),
        this._targetResolver = sn(()=>new Xy(this.ptr))
    }
    get deactivated() {
        return this._deactivated()
    }
    get isPropertyShape() {
        return !!this.path
    }
    get isSparqlShape() {
        return this.sparql.terms.length > 0
    }
    get path() {
        return this._path()
    }
    get targetResolver() {
        return this._targetResolver()
    }
    get message() {
        return this._message()
    }
    get severity() {
        return this._severity()
    }
    get shapeValidator() {
        return this._shapeValidator()
    }
    get sparql() {
        return this._sparql()
    }
    resolveTargets(e) {
        return this.targetResolver.resolve(e)
    }
    async validate(e) {
        const n = e.id({
            shape: this
        });
        if (e.processed.has(n)) {
            if (e.results.has(n))
                for (const r of e.results.get(n))
                    e.report.results.push(r);
            return e
        }
        return e.processed.add(n),
        this.shapeValidator.validate(e)
    }
}
function Jy(i) {
    const e = parseInt(i.ptr.out([ge.maxCount]).value);
    return {
        property: Ky(e)
    }
}
function Ky(i) {
    return e=>{
        e.test(e.values.terms.length <= i, ge.MaxCountConstraintComponent, {
            args: {
                maxCount: i
            },
            message: [e.factory.literal("More than {$maxCount} values")]
        })
    }
}
function Yy(i) {
    const e = parseInt(i.ptr.out([ge.minCount]).value);
    return {
        property: ev(e)
    }
}
function ev(i) {
    return e=>{
        e.test(e.values.terms.length >= i, ge.MinCountConstraintComponent, {
            args: {
                minCount: i
            },
            message: [e.factory.literal("Less than {$minCount} values")]
        })
    }
}
async function tv(i, e) {
    for (const n of i)
        if (!await e(n))
            return !1;
    return !0
}
async function nv(i, e) {
    return (await Promise.all(i.map(n=>e(n)))).filter(Boolean)
}
async function no(i, e) {
    return Promise.all(i.map(e))
}
async function iv(i, e) {
    for (const n of i)
        if (await e(n))
            return !0;
    return !1
}
function rv(i) {
    const e = [...i.ptr.out([ge.and])].flatMap(n=>[...n.list()]).map(n=>i.validator.shape(n));
    return {
        generic: sv(e)
    }
}
function sv(i) {
    return async e=>{
        const n = await no(i, async o=>(await o.validate(e.create({
            child: !0,
            focusNode: e.valueOrNode
        }))).report)
          , r = n.every(o=>o.conforms);
        e.test(r, ge.AndConstraintComponent, {
            results: n.flatMap(o=>o.results),
            value: e.valueOrNode
        })
    }
}
function ov(i) {
    const e = i.validator.shape(i.ptr.out([ge.not]));
    return {
        generic: av(e)
    }
}
function av(i) {
    return async e=>{
        const n = (await i.validate(e.create({
            child: !0,
            focusNode: e.valueOrNode
        }))).report
          , r = !n.conforms;
        e.test(r, ge.NotConstraintComponent, {
            args: {
                not: i.ptr.term
            },
            message: [e.factory.literal("Value does have shape {$not}")],
            results: n.results,
            value: e.valueOrNode
        })
    }
}
function lv(i) {
    const e = [...i.ptr.out([ge.or])].flatMap(n=>[...n.list()]).map(n=>i.validator.shape(n));
    return {
        generic: uv(e)
    }
}
function uv(i) {
    return async e=>{
        let n = [], r;
        if (e.options.debug || e.options.details) {
            const o = await no(i, async a=>(await a.validate(e.create({
                child: !0,
                focusNode: e.valueOrNode
            }))).report);
            n = o.flatMap(a=>a.results),
            r = o.some(a=>a.conforms)
        } else
            r = await iv(i, async o=>(await o.validate(e.create({
                child: !0,
                focusNode: e.valueOrNode
            }))).report.conforms);
        e.test(r, ge.OrConstraintComponent, {
            results: n,
            value: e.valueOrNode
        })
    }
}
function cv(i) {
    const e = [...i.ptr.out([ge.xone])].flatMap(n=>[...n.list()]).map(n=>i.validator.shape(n));
    return {
        generic: dv(e)
    }
}
function dv(i) {
    return async e=>{
        const n = await no(i, async o=>(await o.validate(e.create({
            child: !0,
            focusNode: e.valueOrNode
        }))).report)
          , r = n.filter(o=>o.conforms).length === 1;
        e.test(r, ge.XoneConstraintComponent, {
            results: n.flatMap(o=>o.results),
            value: e.valueOrNode
        })
    }
}
function hv(i) {
    if (!Hr.fromRdf(i.ptr.out([ge.closed]).term))
        return null;
    const n = i.ptr.out([ge.property]).map(a=>i.validator.shape(a))
      , r = new Xt(n.filter(a=>!a.deactivated).map(a=>a.path[0].predicates[0]))
      , o = new Xt([...i.ptr.out([ge.ignoredProperties]).list() || []].map(a=>a.term));
    return {
        node: fv(r, o)
    }
}
function fv(i, e) {
    return n=>{
        const r = n.focusNode.execute({
            start: "subject",
            end: "predicate"
        }).filter(o=>e.has(o.term) ? !1 : !i.has(o.term));
        if (r.ptrs.length > 0)
            for (const o of r)
                n.violation(ge.ClosedConstraintComponent, {
                    message: [n.factory.literal("Predicate is not allowed (closed shape)")],
                    path: [{
                        quantifier: "one",
                        start: "subject",
                        end: "object",
                        predicates: [o.term]
                    }],
                    value: n.focusNode.node([[...o.quads()][0].object])
                });
        else
            n.debug(ge.ClosedConstraintComponent)
    }
}
function pv(i) {
    const e = i.ptr.out([ge.hasValue]).term;
    return {
        node: gv(e),
        property: mv(e)
    }
}
function gv(i) {
    return e=>{
        e.test(i.equals(e.valueOrNode.term), ge.HasValueConstraintComponent, {
            args: {
                hasValue: i
            },
            message: [e.factory.literal("Value must be {$hasValue}")]
        })
    }
}
function mv(i) {
    return e=>{
        const n = [...e.values].some(r=>i.equals(r.term));
        e.test(n, ge.HasValueConstraintComponent, {
            args: {
                hasValue: i
            },
            message: [e.factory.literal("Missing expected value {$hasValue}")]
        })
    }
}
function _v(i) {
    const e = new Xt([...i.ptr.out([ge.in]).list()].map(n=>n.term));
    return {
        generic: yv(e)
    }
}
function yv(i) {
    return e=>{
        e.test(i.has(e.valueOrNode.term), ge.InConstraintComponent, {
            args: {
                in: [...i].map(n=>n.value).join(", ")
            },
            message: [e.factory.literal("Value is not in {$in}")],
            value: e.valueOrNode
        })
    }
}
function Xi(i, e) {
    if (!i || i.termType !== "Literal" || !e || e.termType !== "Literal" || zh(i) !== zh(e))
        return null;
    const n = Hr.fromRdf(i)
      , r = Hr.fromRdf(e);
    return typeof n != typeof r ? null : typeof n == "string" ? n.localeCompare(r) : n - r
}
function zh(i) {
    const e = /^.*(((\+|-)\d{2}:\d{2})|Z)$/;
    return ru.dateTime.equals(i.datatype) && e.test(i.value)
}
function vv(i) {
    const e = i.ptr.out([ge.disjoint]).term;
    return {
        generic: bv(e)
    }
}
function bv(i) {
    return e=>{
        const n = e.focusNode.dataset.match(e.focusNode.term, i, e.valueOrNode.term);
        e.test(n.size === 0, ge.DisjointConstraintComponent, {
            args: {
                disjoint: i
            },
            message: [e.factory.literal("Value node must not also be one of the values of {$disjoint}")],
            value: e.valueOrNode
        })
    }
}
function wv(i) {
    const e = i.ptr.out([ge.equals]).term;
    return {
        node: xv(e),
        property: Ev(e)
    }
}
function xv(i) {
    return e=>{
        const n = e.focusNode.out([i])
          , r = n.filter(a=>!a.term.equals(e.focusNode.term))
          , o = n.terms.length !== 0 && r.terms.length === 0;
        e.test(o, ge.EqualsConstraintComponent, {
            args: {
                equals: i
            },
            message: [e.factory.literal("Must have same values as {$equals}")],
            value: r.terms[0] && e.focusNode.node([r.terms[0]]) || e.focusNode
        })
    }
}
function Ev(i) {
    return e=>{
        const n = new Xt(e.focusNode.out([i]).terms)
          , r = new Xt(e.values.terms)
          , o = [...r].filter(u=>!n.has(u))
          , a = [...n].filter(u=>!r.has(u))
          , l = [...o, ...a];
        for (const u of l)
            e.violation(ge.EqualsConstraintComponent, {
                args: {
                    equals: i
                },
                message: [e.factory.literal("Must have same values as {$equals}")],
                value: e.focusNode.node([u])
            });
        l.length === 0 && e.debug(ge.EqualsConstraintComponent, {
            args: {
                equals: i
            },
            message: [e.factory.literal("Must have same values as {$equals}")]
        })
    }
}
function Sv(i) {
    const e = i.ptr.out([ge.lessThan]).term;
    return {
        property: Tv(e)
    }
}
function Tv(i) {
    return e=>{
        const n = e.focusNode.out([i]).terms;
        for (const r of e.values)
            for (const o of n) {
                const a = Xi(r.term, o);
                a === null || a >= 0 ? e.violation(ge.LessThanConstraintComponent, {
                    args: {
                        lessThan: i
                    },
                    message: [e.factory.literal("Value is not less than value of {$lessThan}")],
                    value: r
                }) : e.debug(ge.LessThanConstraintComponent, {
                    args: {
                        lessThan: i
                    },
                    message: [e.factory.literal("Value is not less than value of {$lessThan}")],
                    value: r
                })
            }
    }
}
function Lv(i) {
    const e = i.ptr.out([ge.lessThanOrEquals]).term;
    return {
        property: Iv(e)
    }
}
function Iv(i) {
    return e=>{
        const n = e.focusNode.out([i]).terms;
        for (const r of e.values)
            for (const o of n) {
                const a = Xi(r.term, o);
                a === null || a > 0 ? e.violation(ge.LessThanOrEqualsConstraintComponent, {
                    args: {
                        lessThanOrEquals: i
                    },
                    message: [e.factory.literal("Value is not less than or equal to value of {$lessThanOrEquals}")],
                    value: r
                }) : e.debug(ge.LessThanOrEqualsConstraintComponent, {
                    args: {
                        lessThanOrEquals: i
                    },
                    message: [e.factory.literal("Value is not less than or equal to value of {$lessThanOrEquals}")],
                    value: r
                })
            }
    }
}
function Nv(i) {
    const e = i.ptr.out([ge.maxExclusive]).term;
    return {
        generic: Av(e)
    }
}
function Av(i) {
    return e=>{
        const n = Xi(e.valueOrNode.term, i);
        e.test(n !== null && n < 0, ge.MaxExclusiveConstraintComponent, {
            args: {
                maxExclusive: i
            },
            message: [e.factory.literal("Value is not less than {$maxExclusive}")],
            value: e.valueOrNode
        })
    }
}
function Rv(i) {
    const e = i.ptr.out([ge.maxInclusive]).term;
    return {
        generic: Cv(e)
    }
}
function Cv(i) {
    return e=>{
        const n = Xi(e.valueOrNode.term, i);
        e.test(n !== null && n <= 0, ge.MaxInclusiveConstraintComponent, {
            args: {
                maxInclusive: i
            },
            message: [e.factory.literal("Value is not less than or equal to {$maxInclusive}")],
            value: e.valueOrNode
        })
    }
}
function kv(i) {
    const e = i.ptr.out([ge.minExclusive]).term;
    return {
        generic: Pv(e)
    }
}
function Pv(i) {
    return e=>{
        const n = Xi(e.valueOrNode.term, i);
        e.test(n !== null && n > 0, ge.MinExclusiveConstraintComponent, {
            args: {
                minExclusive: i
            },
            message: [e.factory.literal("Value is not greater than {$minExclusive}")],
            value: e.valueOrNode
        })
    }
}
function Mv(i) {
    const e = i.ptr.out([ge.minInclusive]).term;
    return {
        generic: Dv(e)
    }
}
function Dv(i) {
    return e=>{
        const n = Xi(e.valueOrNode.term, i);
        e.test(n !== null && n >= 0, ge.MinInclusiveConstraintComponent, {
            args: {
                minInclusive: i
            },
            message: [e.factory.literal("Value is not greater than or equal to {$minInclusive}")],
            value: e.valueOrNode
        })
    }
}
function Ov(i) {
    const e = [...i.ptr.out([ge.node])].map(n=>i.validator.shape(n));
    return {
        generic: Fv(e)
    }
}
function Fv(i) {
    return async e=>{
        for (const n of i) {
            const r = await n.validate(e.create({
                child: !0,
                focusNode: e.valueOrNode
            }));
            e.test(r.report.conforms, ge.NodeConstraintComponent, {
                args: {
                    node: n.ptr.term
                },
                message: [e.factory.literal("Value does not have shape {$node}")],
                results: r.report.results,
                value: e.valueOrNode
            })
        }
    }
}
function jv(i) {
    const e = [...i.ptr.out([ge.property])].map(n=>i.validator.shape(n));
    return {
        generic: Bv(e)
    }
}
function Bv(i) {
    return async e=>{
        const n = e.create({
            focusNode: e.valueOrNode
        });
        for (const r of i)
            await r.validate(n)
    }
}
function $v(i) {
    const e = i.validator.shape(i.ptr.out([ge.qualifiedValueShape]))
      , n = i.ptr.out([ge.qualifiedValueShapesDisjoint]).term
      , r = n ? Hr.fromRdf(n) : !1
      , o = i.ptr.out([ge.qualifiedMaxCount]).term
      , a = o ? parseInt(o.value) : null
      , l = i.ptr.out([ge.qualifiedMinCount]).term
      , u = l ? parseInt(l.value) : null;
    return {
        property: qv(e, r, a, u)
    }
}
function qv(i, e, n, r) {
    return async o=>{
        const a = [];
        let l = [];
        e && (l = new Set(o.shape.ptr.in([ge.property]).out([ge.property]).out([ge.qualifiedValueShape]).filter(f=>!f.term.equals(i.ptr.term)).map(f=>o.shape.validator.shape(f))));
        const u = (await nv(o.values, async f=>{
            const h = (await i.validate(o.create({
                child: !0,
                focusNode: f
            }))).report;
            if (a.push(h.results),
            !h.conforms)
                return !1;
            if (l.length === 0)
                return !0;
            if (o.options.debug || o.options.details) {
                const m = await no([...l], async _=>(await _.validate(o.create({
                    child: !0,
                    focusNode: f
                }))).report);
                return a.push(m.flatMap(_=>_.results)),
                !m.every(_=>_.conforms)
            } else
                return !await tv([...l], async m=>(await m.validate(o.create({
                    child: !0,
                    focusNode: f
                }))).report.conforms)
        }
        )).length;
        n !== null && o.test(u <= n, ge.QualifiedMaxCountConstraintComponent, {
            args: {
                qualifiedMaxCount: n,
                qualifiedValueShape: i.ptr.term,
                qualifiedValueShapesDisjoint: e
            },
            message: [o.factory.literal("More than {$qualifiedMaxCount} values have shape {$qualifiedValueShape}")],
            results: a.flat()
        }),
        r !== null && o.test(u >= r, ge.QualifiedMinCountConstraintComponent, {
            args: {
                qualifiedMinCount: r,
                qualifiedValueShape: i.ptr.term,
                qualifiedValueShapesDisjoint: e
            },
            message: [o.factory.literal("Less than {$qualifiedMinCount} values have shape {$qualifiedValueShape}")],
            results: a.flat()
        })
    }
}
function zv(i, e) {
    return e ? e.slice(0, i.length) === i : !1
}
function Uv(i) {
    const e = [...new Set([...i.ptr.out([ge.languageIn]).list()].map(n=>n.value))];
    return {
        generic: Hv(e)
    }
}
function Hv(i) {
    return e=>{
        const n = i.some(r=>zv(r, e.valueOrNode.term.language));
        e.test(n, ge.LanguageInConstraintComponent, {
            args: {
                languageIn: i.join(", ")
            },
            message: [e.factory.literal("Language does not match any of {$languageIn}")],
            value: e.valueOrNode
        })
    }
}
function Vv(i) {
    const e = parseInt(i.ptr.out([ge.maxLength]).value);
    return {
        generic: Gv(e)
    }
}
function Gv(i) {
    return e=>{
        const n = e.valueOrNode.term.termType !== "BlankNode" && e.valueOrNode.value.length <= i;
        e.test(n, ge.MaxLengthConstraintComponent, {
            args: {
                maxLength: i
            },
            message: [e.factory.literal("Value has more than {$maxLength} characters")],
            value: e.valueOrNode
        })
    }
}
function Wv(i) {
    const e = parseInt(i.ptr.out([ge.minLength]).value);
    return {
        generic: Zv(e)
    }
}
function Zv(i) {
    return e=>{
        const n = e.valueOrNode.term.termType !== "BlankNode" && e.valueOrNode.value.length >= i;
        e.test(n, ge.MinLengthConstraintComponent, {
            args: {
                minLength: i
            },
            message: [e.factory.literal("Value has less than {$minLength} characters")],
            value: e.valueOrNode
        })
    }
}
function Xv(i) {
    const e = i.ptr.out([ge.pattern]).value
      , n = i.ptr.out([ge.flags]).value
      , r = new RegExp(e,n);
    return {
        generic: Qv(e, n, r)
    }
}
function Qv(i, e, n) {
    return r=>{
        r.test(n.test(r.valueOrNode.term.value), ge.PatternConstraintComponent, {
            args: {
                flags: e,
                pattern: i
            },
            message: [r.factory.literal('Value does not match pattern "{$pattern}"')],
            value: r.valueOrNode
        })
    }
}
function Jv(i) {
    const e = i.ptr.out([ge.uniqueLang]).term;
    return e.value === "true" && ru.boolean.equals(e.datatype) ? {
        property: Kv()
    } : null
}
function Kv() {
    return i=>{
        const n = Object.entries(i.values.terms.reduce((r,o)=>(o.language && (r[o.language] = (r[o.language] || 0) + 1),
        r), {})).filter(([,r])=>r > 1);
        for (const [r] of n)
            i.violation(ge.UniqueLangConstraintComponent, {
                args: {
                    lang: r
                },
                message: [i.factory.literal('Language "{?lang}" used more than once')]
            });
        n.length === 0 && i.debug(ge.UniqueLangConstraintComponent)
    }
}
const Ps = Kt("http://www.w3.org/ns/shacl#")
  , gp = Kt("https://schemas.link/shacl-next#");
class Hi {
    constructor({results: e=[]}={}) {
        this.results = e
    }
    get conforms() {
        return !this.results.some(e=>e.severity.equals(Ps.Info) || e.severity.equals(Ps.Violation) || e.severity.equals(Ps.Warning))
    }
}
function Yv(i, e) {
    return Object.entries(e).reduce((n,[r,o])=>(o && o.termType && (o = $t(o)),
    n.replace(`{$ ${r}}`, o).replace(`{?${r}}`, o)), i)
}
class qs {
    constructor({args: e={}, factory: n, message: r=[], severity: o=Ps.Violation}={}) {
        this.severity = o,
        this.message = r.map(a=>n.literal(Yv(a.value, e), a.language || null))
    }
}
class ou {
    constructor({factory: e=iu}={}) {
        this.factory = e
    }
    clone({factory: e}={}) {
        return new ou({
            factory: e || this.factory
        })
    }
    validate() {
        return new Hi
    }
    validateSimple() {
        return !0
    }
}
class Qi extends ou {
    constructor({datatypes: e, factory: n}={}) {
        super({
            factory: n
        }),
        this.datatypes = [];
        for (const r of Array.isArray(e) ? e : [e])
            r && this.datatypes.push(this.factory.fromTerm(r))
    }
    clone({factory: e}={}) {
        return new Qi({
            datatypes: this.datatypes,
            factory: e || this.factory
        })
    }
}
class eb {
    constructor({factory: e=iu, validations: n}={}) {
        if (this.factory = e,
        this.validations = new Zi,
        n)
            for (const r of Object.values(n)) {
                const o = r.clone({
                    factory: this.factory
                });
                for (const a of o.datatypes)
                    this.validations.set(a, o)
            }
    }
    validate(e) {
        const n = this.validations.get(e.datatype);
        return n ? n.validate(e) : new Hi
    }
    validateSimple(e) {
        const n = this.validations.get(e.datatype);
        return n ? n.validateSimple(e) : !0
    }
}
class ot extends Qi {
    constructor(e, n, {factory: r}={}) {
        super({
            datatypes: n,
            factory: r
        }),
        this.message = [this.factory.literal("term value {$this} matches pattern {$pattern}")],
        this.patterns = Array.isArray(e) ? e : [e]
    }
    clone({factory: e}={}) {
        return new ot(this.patterns,this.datatypes,{
            factory: e || this.factory
        })
    }
    validate(e) {
        const n = this.patterns.map(r=>{
            let o;
            r.test(e.value) && (o = gp.Debug);
            const a = {
                pattern: this.factory.literal(r.toString()),
                this: e
            };
            return new qs({
                args: a,
                factory: this.factory,
                message: this.message,
                severity: o
            })
        }
        );
        return new Hi({
            results: n
        })
    }
    validateSimple(e) {
        return this.patterns.every(n=>n.test(e.value))
    }
}
const tb = /^([-+]?[0-9]+)$/;
class Pt extends ot {
    constructor(e=null, n=null, r, {factory: o}={}) {
        super(tb, r, {
            factory: o
        }),
        this.maxInclusive = null,
        this.minInclusive = null,
        typeof n == "string" && (this.maxInclusive = BigInt(n)),
        typeof e == "string" && (this.minInclusive = BigInt(e))
    }
    clone({factory: e}={}) {
        return new Pt(this.minInclusive?.toString(),this.maxInclusive?.toString(),this.datatypes,{
            factory: e || this.factory
        })
    }
    validate(e) {
        const n = super.validate(e).results;
        if (!gp.Debug.equals(n[0].severity))
            return new Hi({
                results: n
            });
        const r = BigInt(e.value);
        if (this.minInclusive !== null && r < this.minInclusive) {
            const o = `term value "${e.value}" is less than "${this.minInclusive.toString()}"`
              , a = [this.factory.literal(o)];
            n.push(new qs({
                factory: this.factory,
                message: a
            }))
        }
        if (this.maxInclusive !== null && r > this.maxInclusive) {
            const o = `term value "${e.value}" is greater than "${this.maxInclusive.toString()}"`
              , a = [this.factory.literal(o)];
            n.push(new qs({
                factory: this.factory,
                message: a
            }))
        }
        return new Hi({
            results: n
        })
    }
    validateSimple(e) {
        if (!super.validateSimple(e))
            return !1;
        const n = BigInt(e.value);
        return !(this.minInclusive !== null && n < this.minInclusive || this.maxInclusive !== null && n > this.maxInclusive)
    }
}
class au extends Qi {
    constructor(e, n, {factory: r}={}) {
        super({
            datatypes: n,
            factory: r
        }),
        this.values = new Set(e)
    }
    clone({factory: e}={}) {
        return new au(this.values,this.datatypes,{
            factory: e || this.factory
        })
    }
    validate(e) {
        const n = [];
        if (!this.values.has(e.value)) {
            const r = `term value "${e.value}" is not included in the list: ${[...this.values].join(",")}`
              , o = [this.factory.literal(r)];
            n.push(new qs({
                factory: this.factory,
                message: o
            }))
        }
        return new Hi({
            results: n
        })
    }
    validateSimple(e) {
        return this.values.has(e.value)
    }
}
const Ge = {
    xsd: Kt("http://www.w3.org/2001/XMLSchema#")
}
  , nb = new Qi({
    datatypes: Ge.xsd.anySimpleType
})
  , ib = new Qi({
    datatypes: Ge.xsd.anyAtomicType
})
  , io = /^([^\ud8ff-\udfff\ufffe-\uffff]*)$/
  , rb = /^((\+|-)?([0-9]+(\.[0-9]*)?|\.[0-9]+))$/
  , mp = /^((\+|-)?([0-9]+(\.[0-9]*)?|\.[0-9]+)([Ee](\+|-)?[0-9]+)?|(\+|-)?INF|NaN)$/
  , lu = /^(-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\.[0-9]+)?S)?|([0-9]+(\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\.[0-9]+)?S)?|([0-9]+(\.[0-9]+)?S)))))$/
  , _p = /^(-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)$/
  , sb = /^((([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)$/
  , ob = /^(-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)$/
  , ab = /^(-?([1-9][0-9]{3,}|0[0-9]{3})-(0[1-9]|1[0-2])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)$/
  , lb = /^(-?([1-9][0-9]{3,}|0[0-9]{3})(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)$/
  , ub = /^(--(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)$/
  , cb = /^(---(0[1-9]|[12][0-9]|3[01])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)$/
  , db = /^(--(0[1-9]|1[0-2])(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))?)$/
  , hb = /^(([0-9a-fA-F]{2})*)$/
  , fb = /^(((([A-Za-z0-9+/] ?){4})*(([A-Za-z0-9+/] ?){3}[A-Za-z0-9+/]|([A-Za-z0-9+/] ?){2}[AEIMQUYcgkosw048] ?=|[A-Za-z0-9+/] ?[AQgw] ?= ?=))?)$/
  , pb = new ot(io,Ge.xsd.string)
  , gb = new au(["1", "true", "0", "false"],Ge.xsd.boolean)
  , mb = new ot(rb,Ge.xsd.decimal)
  , _b = new ot(mp,Ge.xsd.float)
  , yb = new ot(mp,Ge.xsd.double)
  , vb = new ot(lu,Ge.xsd.duration)
  , bb = new ot(_p,Ge.xsd.dateTime)
  , wb = new ot(sb,Ge.xsd.time)
  , xb = new ot(ob,Ge.xsd.date)
  , Eb = new ot(ab,Ge.xsd.gYearMonth)
  , Sb = new ot(lb,Ge.xsd.gYear)
  , Tb = new ot(ub,Ge.xsd.gMonthDay)
  , Lb = new ot(cb,Ge.xsd.gDay)
  , Ib = new ot(db,Ge.xsd.gMonth)
  , Nb = new ot(hb,Ge.xsd.hexBinary)
  , Ab = new ot(fb,Ge.xsd.base64Binary)
  , Rb = new ot(io,Ge.xsd.anyURI)
  , yp = /^([^\u000d\u000a\u0009]*)$/
  , Cb = /^([^ ]+( [^ ]+)*)*$/
  , kb = /^([a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*)$/
  , Pb = /^([^DT]*)$/
  , Mb = /^([^YM]*[DT].*)$/
  , Db = /^(.*(Z|(\+|-)[0-9][0-9]:[0-9][0-9]))$/
  , Ob = new ot([io, yp],Ge.xsd.normalizedString)
  , Fb = new ot([io, yp, Cb],Ge.xsd.token)
  , jb = new ot(kb,Ge.xsd.language)
  , Bb = new Pt(null,null,Ge.xsd.integer)
  , $b = new Pt(null,"0",Ge.xsd.nonPositiveInteger)
  , qb = new Pt(null,"-1",Ge.xsd.negativeInteger)
  , zb = new Pt("-9223372036854775808","9223372036854775807",Ge.xsd.long)
  , Ub = new Pt("-2147483648","2147483647",Ge.xsd.int)
  , Hb = new Pt("-32768","32767",Ge.xsd.short)
  , Vb = new Pt("-128","127",Ge.xsd.byte)
  , Gb = new Pt("0",null,Ge.xsd.nonNegativeInteger)
  , Wb = new Pt("0","18446744073709551615",Ge.xsd.unsignedLong)
  , Zb = new Pt("0","4294967295",Ge.xsd.unsignedInt)
  , Xb = new Pt("0","65535",Ge.xsd.unsignedShort)
  , Qb = new Pt("0","255",Ge.xsd.unsignedByte)
  , Jb = new Pt("1",null,Ge.xsd.positiveInteger)
  , Kb = new ot([lu, Pb],Ge.xsd.yearMonthDuration)
  , Yb = new ot([lu, Mb],Ge.xsd.dayTimeDuration)
  , e0 = new ot([_p, Db],Ge.xsd.dateTimeStamp)
  , t0 = Object.freeze(Object.defineProperty({
    __proto__: null,
    anyAtomicType: ib,
    anySimpleType: nb,
    anyURI: Rb,
    base64Binary: Ab,
    boolean: gb,
    byte: Vb,
    date: xb,
    dateTime: bb,
    dateTimeStamp: e0,
    dayTimeDuration: Yb,
    decimal: mb,
    double: yb,
    duration: vb,
    float: _b,
    gDay: Lb,
    gMonth: Ib,
    gMonthDay: Tb,
    gYear: Sb,
    gYearMonth: Eb,
    hexBinary: Nb,
    int: Ub,
    integer: Bb,
    language: jb,
    long: zb,
    negativeInteger: qb,
    nonNegativeInteger: Gb,
    nonPositiveInteger: $b,
    normalizedString: Ob,
    positiveInteger: Jb,
    short: Hb,
    string: pb,
    time: wb,
    token: Fb,
    unsignedByte: Qb,
    unsignedInt: Zb,
    unsignedLong: Wb,
    unsignedShort: Xb,
    yearMonthDuration: Kb
}, Symbol.toStringTag, {
    value: "Module"
}));
class n0 extends eb {
    constructor({factory: e}={}) {
        super({
            factory: e,
            validations: {
                ...t0
            }
        })
    }
}
const i0 = new Zi([[ge.BlankNode, new Set(["BlankNode"])], [ge.BlankNodeOrIRI, new Set(["BlankNode", "NamedNode"])], [ge.BlankNodeOrLiteral, new Set(["BlankNode", "Literal"])], [ge.IRI, new Set(["NamedNode"])], [ge.IRIOrLiteral, new Set(["NamedNode", "Literal"])], [ge.Literal, new Set(["Literal"])]]);
function r0(i) {
    const e = i.ptr.out([ge.class]).map(n=>Nl(n));
    return {
        generic: s0(e)
    }
}
function s0(i) {
    return e=>{
        const n = new Xt(e.valueOrNode.out([wi.type]).terms);
        for (const r of i) {
            const o = [...n].some(a=>r.has(a));
            e.test(o, ge.ClassConstraintComponent, {
                value: e.valueOrNode
            })
        }
    }
}
function o0(i) {
    const e = i.ptr.out([ge.datatype]).term
      , n = new n0;
    return {
        generic: a0(e, n)
    }
}
function a0(i, e) {
    return n=>{
        const r = i.equals(n.valueOrNode.term.datatype) && e.validateSimple(n.valueOrNode.term);
        n.test(r, ge.DatatypeConstraintComponent, {
            args: {
                datatype: i
            },
            message: [n.factory.literal("Value does not have datatype {$datatype}")],
            value: n.valueOrNode
        })
    }
}
function l0(i) {
    const e = i.ptr.out([ge.nodeKind]).term
      , n = i0.get(e);
    return {
        generic: u0(e, n)
    }
}
function u0(i, e) {
    return n=>{
        n.test(e.has(n.valueOrNode.term.termType), ge.NodeKindConstraintComponent, {
            args: {
                nodeKind: i
            },
            message: [n.factory.literal("Value does not have node kind {$nodeKind}")],
            value: n.valueOrNode
        })
    }
}
const c0 = new Zi([[ge.maxCount, Jy], [ge.minCount, Yy], [ge.and, rv], [ge.not, ov], [ge.or, lv], [ge.xone, cv], [ge.closed, hv], [ge.hasValue, pv], [ge.in, _v], [ge.disjoint, vv], [ge.equals, wv], [ge.lessThan, Sv], [ge.lessThanOrEquals, Lv], [ge.maxExclusive, Nv], [ge.maxInclusive, Rv], [ge.minExclusive, kv], [ge.minInclusive, Mv], [ge.node, Ov], [ge.property, jv], [ge.qualifiedValueShape, $v], [ge.languageIn, Uv], [ge.maxLength, Vv], [ge.minLength, Wv], [ge.pattern, Xv], [ge.uniqueLang, Jv], [ge.class, r0], [ge.datatype, o0], [ge.nodeKind, l0]]);
class Uh {
    constructor(e, {factory: n, ...r}) {
        if (this.factory = n,
        this.options = r,
        this.registry = new By(c0),
        this.shapesPtr = new $s({
            dataset: e,
            factory: n
        }),
        this.shapes = new Zi,
        this.options.coverage && (this.options.debug = !0,
        this.options.details = !0,
        this.options.trace = !0),
        this.options.validations)
            for (const [a,l] of this.options.validations)
                this.registry.validations.set(a, l);
        const o = [...this.shapesPtr.hasOut([ge.targetClass]), ...this.shapesPtr.hasOut([ge.targetNode]), ...this.shapesPtr.hasOut([ge.targetObjectsOf]), ...this.shapesPtr.hasOut([ge.targetSubjectsOf]), ...this.shapesPtr.hasOut([wi.type], [ge.NodeShape]), ...this.shapesPtr.hasOut([wi.type], [ge.PropertyShape])];
        for (const a of o)
            this.shape(a)
    }
    shape(e) {
        if (!e.term)
            return null;
        let n = this.shapes.get(e.term);
        return n || (n = new Qy(e,{
            validator: this
        }),
        this.shapes.set(e.term, n)),
        n
    }
    async validate(e, n) {
        const r = new $s({
            ...e,
            factory: this.factory
        })
          , o = new su({
            factory: this.factory,
            focusNode: r,
            options: this.options,
            validator: this
        });
        n ? n = n.map(a=>this.shape(this.shapesPtr.node(a.terms))) : n = this.shapes.values();
        for (const a of n) {
            const l = o.create({
                shape: a
            });
            let u;
            r.isAny() ? u = a.resolveTargets(l) : u = r;
            for (const f of u)
                await a.validate(l.create({
                    focusNode: f
                }))
        }
        return o.report
    }
}
const d0 = {
    [`${Fe}node`]: (i,e)=>{
        i.extendedShapes.add(new zs(e,i.config,i))
    }
    ,
    [`${Fe}and`]: (i,e)=>{
        for (const n of i.config.lists[e.value])
            i.extendedShapes.add(new zs(n,i.config,i))
    }
    ,
    [`${Fe}property`]: (i,e)=>{
        const n = i.config.getPropertyTemplate(e, i);
        if (n.path) {
            let r = i.properties[n.path];
            if (r || (r = [],
            i.properties[n.path] = r),
            n.qualifiedValueShape)
                r.push(n);
            else {
                let o;
                for (let a = 0; a < i.properties[n.path].length && !o; a++)
                    i.properties[n.path][a].qualifiedValueShape || (o = i.properties[n.path][a]);
                o ? jf(o, n) : r.push(n)
            }
        }
    }
    ,
    [`${Fe}nodeKind`]: (i,e)=>{
        i.nodeKind = e
    }
    ,
    [`${Fe}targetClass`]: (i,e)=>{
        i.targetClass = e
    }
    ,
    [`${Fe}or`]: (i,e)=>{
        i.or = i.config.lists[e.value]
    }
    ,
    [`${Fe}xone`]: (i,e)=>{
        i.xone = i.config.lists[e.value]
    }
    ,
    [jl.id]: (i,e)=>{
        i.owlImports.add(e)
    }
};
class zs {
    constructor(e, n, r) {
        this.extendedShapes = new Set,
        this.properties = {},
        this.owlImports = new Set,
        this.id = e,
        this.config = n,
        this.parent = r,
        n.registerNodeTemplate(this),
        h0(this, this.config.store.getQuads(e, null, null, null))
    }
}
function h0(i, e) {
    for (const n of e)
        d0[n.predicate.id]?.call(i, i, n.object);
    return i
}
function f0(i) {
    for (const e of Object.values(i.properties))
        for (const n of e) {
            const [r,o] = Al(i, n.path);
            if (r.length > 1 && o) {
                const a = r[r.length - 1];
                for (let l = r.length - 2; l >= 0; l--) {
                    const u = r[l];
                    delete u.parent.properties[u.path],
                    jf(a, u)
                }
            }
        }
}
function Al(i, e, n=new Set, r=[], o=!1) {
    if (!n.has(i.id.value)) {
        n.add(i.id.value);
        const a = i.properties[e];
        if (a?.length === 1) {
            r.push(a[0]),
            o = o || a[0].maxCount === 1;
            for (const l of a[0].nodeShapes) {
                const [u,f] = Al(l, e, n, r, o);
                o = o || f
            }
        }
        for (const l of i.extendedShapes) {
            const [u,f] = Al(l, e, n, r, o);
            o = o || f
        }
    }
    return [r, o]
}
class ml {
    constructor() {
        this.shapes = null,
        this.shapesUrl = null,
        this.shapeSubject = null,
        this.values = null,
        this.valuesUrl = null,
        this.valueSubject = null,
        this.valuesSubject = null,
        this.valuesNamespace = "",
        this.valuesGraph = null,
        this.view = null,
        this.language = null,
        this.loading = "Loading",
        this.proxy = null,
        this.ignoreOwlImports = null,
        this.collapse = null,
        this.hierarchyColors = null,
        this.submitButton = null,
        this.generateNodeShapeReference = Ds.value,
        this.showNodeIds = null,
        this.dense = "true"
    }
}
const p0 = "#4c93d785, #f85e9a85, #00327385, #87001f85";
class Hh {
    constructor(e) {
        this.attributes = new ml,
        this.editMode = !0,
        this.lists = {},
        this.groups = [],
        this.renderedNodes = new Set,
        this._store = new It,
        this._nodeTemplates = {},
        this._propertyTemplates = {},
        this.validator = new Uh(this._store,{
            details: !0,
            factory: ze
        }),
        this.form = e,
        this._theme = new ey,
        this.languages = [...new Set(navigator.languages.flatMap(n=>n.length > 2 ? [n.toLocaleLowerCase(), n.substring(0, 2)] : n)), ""]
    }
    reset() {
        this.lists = {},
        this.groups = [],
        this.renderedNodes.clear(),
        this._nodeTemplates = {},
        this._propertyTemplates = {}
    }
    updateAttributes(e) {
        const n = new ml;
        if (Object.keys(n).forEach(r=>{
            const o = e.dataset[r];
            o !== void 0 && (n[r] = o)
        }
        ),
        this.editMode = n.view === null,
        this.theme.setDense(n.dense === "true"),
        this.attributes = n,
        this.attributes.valueSubject && !this.attributes.valuesSubject && (this.attributes.valuesSubject = this.attributes.valueSubject),
        n.language) {
            const r = this.languages.indexOf(n.language);
            r > -1 && this.languages.splice(r, 1),
            this.languages.unshift(n.language)
        }
        if (n.valuesGraph && (this.valuesGraphId = ze.namedNode(n.valuesGraph)),
        n.hierarchyColors != null) {
            const r = n.hierarchyColors.length ? n.hierarchyColors : p0;
            let o = `:host { --hierarchy-colors: ${r}; --hierarchy-colors-length: ${r.split(",").length}; --hierarchy-color-width: 3px }`;
            for (let a = 8; a >= 0; a--) {
                let l = `shacl-property { --hierarchy-level: ${a} }`;
                for (let u = 0; u < a; u++)
                    l = "shacl-property " + l;
                o = o + `
` + l
            }
            this.hierarchyColorsStyleSheet = new CSSStyleSheet,
            this.hierarchyColorsStyleSheet.replaceSync(o)
        }
    }
    static dataAttributes() {
        const e = new ml;
        return Object.keys(e).map(n=>(n = n.replace(/[A-Z]/g, r=>"-" + r.toLowerCase()),
        "data-" + n))
    }
    buildTemplateKey(e, n) {
        let r = e.value;
        return n && (n instanceof Vd ? r += "*" + n.id.value : r += "*" + this.buildTemplateKey(n.id, n.parent)),
        r
    }
    registerNodeTemplate(e) {
        this._nodeTemplates[this.buildTemplateKey(e.id, e.parent)] = e
    }
    registerPropertyTemplate(e) {
        this._propertyTemplates[this.buildTemplateKey(e.id, e.parent)] = e
    }
    getNodeTemplate(e, n) {
        const r = this.buildTemplateKey(e, n);
        let o = this._nodeTemplates[r];
        return o || (o = new zs(e,this,n)),
        o
    }
    getPropertyTemplate(e, n) {
        const r = this.buildTemplateKey(e, n);
        let o = this._propertyTemplates[r];
        return o || (o = new Vd(e,n)),
        o
    }
    get nodeTemplates() {
        return Object.values(this._nodeTemplates)
    }
    get theme() {
        return this._theme
    }
    set theme(e) {
        this._theme = e,
        e.setDense(this.attributes.dense === "true")
    }
    get store() {
        return this._store
    }
    set store(e) {
        this._store = e,
        this.lists = Yg(e, {
            ignoreErrors: !0
        }),
        this.groups = [],
        e.forSubjects(n=>{
            this.groups.push(n.id)
        }
        , Rt, `${Fe}PropertyGroup`, null),
        this.validator = new Uh(e,{
            details: !0,
            factory: ze
        })
    }
}
const g0 = 50;
class m0 extends HTMLElement {
    constructor() {
        super(),
        this.shape = null,
        this.attachShadow({
            mode: "open"
        }),
        this.form = document.createElement("form"),
        this.config = new Hh(this.form),
        this.form.addEventListener("change", e=>{
            e.stopPropagation(),
            this.config.editMode && this.validate(!0).then(n=>{
                this.dispatchEvent(new CustomEvent("change",{
                    bubbles: !0,
                    cancelable: !1,
                    composed: !0,
                    detail: {
                        valid: n.conforms,
                        report: n
                    }
                }))
            }
            ).catch(n=>{
                console.warn(n)
            }
            )
        }
        )
    }
    static get observedAttributes() {
        return Hh.dataAttributes()
    }
    connectedCallback() {
        this.shadowRoot.prepend(this.form)
    }
    attributeChangedCallback() {
        this.config.updateAttributes(this),
        this.initialize()
    }
    initialize() {
        clearTimeout(this.initDebounceTimeout),
        this.setAttribute("loading", ""),
        this.form.replaceChildren(document.createTextNode(this.config.attributes.loading)),
        this.initDebounceTimeout = setTimeout(async()=>{
            try {
                this.config.reset(),
                this.config.store = await jm({
                    shapes: this.config.attributes.shapes,
                    shapesUrl: this.config.attributes.shapesUrl,
                    values: this.config.attributes.values,
                    valuesUrl: this.config.attributes.valuesUrl,
                    valuesSubject: this.config.attributes.valuesSubject,
                    loadOwlImports: this.config.attributes.ignoreOwlImports === null,
                    classInstanceProvider: this.config.classInstanceProvider,
                    proxy: this.config.attributes.proxy
                }),
                this.form.replaceChildren();
                const e = this.findRootShaclShapeSubject();
                if (e) {
                    this.form.classList.forEach(o=>{
                        this.form.classList.remove(o)
                    }
                    ),
                    this.form.classList.toggle("mode-edit", this.config.editMode),
                    this.form.classList.toggle("mode-view", !this.config.editMode),
                    this.config.theme.apply(this.form);
                    const n = [this.config.theme.stylesheet];
                    this.config.hierarchyColorsStyleSheet && n.push(this.config.hierarchyColorsStyleSheet);
                    for (const o of Zm())
                        o.stylesheet && n.push(o.stylesheet);
                    this.shadowRoot.adoptedStyleSheets = n;
                    const r = new zs(e,this.config);
                    for (const o of this.config.nodeTemplates)
                        f0(o);
                    if (this.shape = new Ei(r,this.config.attributes.valuesSubject ? ze.namedNode(this.config.attributes.valuesSubject) : void 0),
                    this.form.appendChild(this.shape),
                    this.config.editMode) {
                        if (this.config.attributes.submitButton !== null) {
                            const o = this.config.theme.createButton(this.config.attributes.submitButton || "Submit", !0);
                            o.addEventListener("click", a=>{
                                a.preventDefault(),
                                this.form.reportValidity() && this.validate().then(l=>{
                                    if (l?.conforms)
                                        this.dispatchEvent(new Event("submit",{
                                            bubbles: !0,
                                            cancelable: !0
                                        }));
                                    else {
                                        let u = this.form.querySelector(":scope .invalid > .editor");
                                        u ? u.focus() : this.form.querySelector(":scope .invalid")?.scrollIntoView()
                                    }
                                }
                                )
                            }
                            ),
                            this.form.appendChild(o)
                        }
                        setTimeout(()=>{
                            this.config.attributes.valuesSubject && this.removeFromDataGraph(ze.namedNode(this.config.attributes.valuesSubject)),
                            this.validate(!0)
                        }
                        )
                    }
                } else if (this.config.store.countQuads(null, null, null, pi) > 0)
                    throw new Error("shacl root node shape not found")
            } catch (e) {
                console.error(e);
                const n = document.createElement("div");
                n.innerText = String(e),
                this.form.replaceChildren(n)
            }
            this.removeAttribute("loading"),
            this.dispatchEvent(new Event("ready"))
        }
        , g0)
    }
    serialize(e="text/turtle", n=this.toRDF()) {
        const r = n.getQuads(null, null, null, null);
        return Hm(r, e, Bi)
    }
    toRDF(e=new It) {
        return this.shape?.toRDF(e, void 0, this.config.attributes.generateNodeShapeReference),
        e
    }
    registerPlugin(e) {
        Wm(e),
        this.initialize()
    }
    setTheme(e) {
        this.config.theme = e,
        this.initialize()
    }
    setClassInstanceProvider(e) {
        this.config.classInstanceProvider = e,
        this.initialize()
    }
    async validate(e=!1) {
        for (const n of this.form.querySelectorAll(":scope .validation-error"))
            n.remove();
        for (const n of this.form.querySelectorAll(":scope .property-instance"))
            n.classList.remove("invalid"),
            n.querySelector(":scope > .editor")?.value ? n.classList.add("valid") : n.classList.remove("valid");
        if (this.config.store.deleteGraph(this.config.valuesGraphId || ""),
        !this.shape)
            return {
                conforms: !0
            };
        this.shape.toRDF(this.config.store, void 0, this.config.attributes.generateNodeShapeReference);
        try {
            const n = await this.config.validator.validate({
                dataset: this.config.store,
                terms: [this.shape.nodeId]
            }, [{
                terms: [this.shape.template.id]
            }]);
            for (const r of n.results)
                if (r.focusNode?.ptrs?.length)
                    for (const o of r.focusNode.ptrs) {
                        const a = o._term;
                        if (r.path?.length) {
                            const l = r.path[0].predicates[0];
                            let u = this.form.querySelectorAll(`
                                :scope shacl-node[data-node-id='${a.id}'] > shacl-property > .property-instance[data-path='${l.id}'] > .editor,
                                :scope shacl-node[data-node-id='${a.id}'] > shacl-property > .shacl-group > .property-instance[data-path='${l.id}'] > .editor,
                                :scope shacl-node[data-node-id='${a.id}'] > .shacl-group > shacl-property > .property-instance[data-path='${l.id}'] > .editor,
                                :scope shacl-node[data-node-id='${a.id}'] > .shacl-group > shacl-property > .shacl-group > .property-instance[data-path='${l.id}'] > .editor`);
                            u.length === 0 && (u = this.form.querySelectorAll(`
                                    :scope [data-node-id='${a.id}']  > shacl-property > .property-instance[data-path='${l.id}'],
                                    :scope [data-node-id='${a.id}']  > shacl-property > .shacl-group > .property-instance[data-path='${l.id}']`));
                            for (const f of u)
                                if (f.classList.contains("editor")) {
                                    if (!e || f.value) {
                                        let h = f.parentElement;
                                        h.classList.add("invalid"),
                                        h.classList.remove("valid"),
                                        h.appendChild(this.createValidationErrorDisplay(r));
                                        do
                                            h instanceof Ct && (h.open = !0),
                                            h = h.parentElement;
                                        while (h)
                                    }
                                } else
                                    e || (f.classList.add("invalid"),
                                    f.classList.remove("valid"),
                                    f.appendChild(this.createValidationErrorDisplay(r, "node")))
                        } else
                            e || this.form.querySelector(`:scope [data-node-id='${a.id}']`)?.prepend(this.createValidationErrorDisplay(r, "node"))
                    }
            return n
        } catch (n) {
            return console.error(n),
            !1
        }
    }
    createValidationErrorDisplay(e, n) {
        const r = document.createElement("span");
        if (r.classList.add("validation-error"),
        n && r.classList.add(n),
        e)
            if (e.message?.length > 0)
                for (const o of e.message)
                    r.title += o.value + `
`;
            else
                r.title = e.sourceConstraintComponent?.value;
        return r
    }
    findRootShaclShapeSubject() {
        if (this.config.attributes.shapeSubject) {
            const e = ze.namedNode(this.config.attributes.shapeSubject);
            if (this.config.store.getQuads(e, Rt, sa, null).length === 0) {
                console.warn(`shapes graph does not contain requested node shape ${this.config.attributes.shapeSubject}`);
                return
            } else
                return e
        } else {
            if (this.config.attributes.valuesSubject && this.config.store.countQuads(null, null, null, on) > 0) {
                const n = ze.namedNode(this.config.attributes.valuesSubject)
                  , r = [...this.config.store.getQuads(n, Rt, null, on), ...this.config.store.getQuads(n, Ds, null, on)];
                if (r.length === 0)
                    console.warn(`value subject '${this.config.attributes.valuesSubject}' has neither ${Rt.id} nor ${Ds.id} statement`);
                else
                    for (const a of r)
                        if (this.config.store.getQuads(a.object, Rt, sa, null).length > 0)
                            return a.object;
                const o = this.config.store.getObjects(n, Rt, on);
                for (const a of o)
                    for (const l of this.config.store.getQuads(null, Zs, a, null))
                        return l.subject
            }
            const e = this.config.store.getQuads(null, Rt, sa, null);
            if (e.length == 0) {
                console.warn("shapes graph does not contain any node shapes");
                return
            }
            return e.length > 1 && (console.warn("shapes graph contains", e.length, "node shapes. choosing first found which is", e[0].subject.value),
            console.info('hint: set the node shape to use with element attribute "data-shape-subject"')),
            e[0].subject
        }
    }
    removeFromDataGraph(e) {
        this.config.attributes.valuesSubject;
        for (const n of this.config.store.getQuads(e, null, null, on))
            this.config.store.delete(n),
            (n.object.termType === "NamedNode" || n.object.termType === "BlankNode") && this.removeFromDataGraph(n.object)
    }
}
window.customElements.define("shacl-form", m0);
class iw extends qf {
    constructor(e, n, r) {
        super(e),
        this.onChange = n,
        this.fileType = r
    }
    createEditor(e) {
        const n = e.aggregatedMinCount > 0
          , r = e.config.theme.createFileEditor(e.label, null, n, e);
        return r.addEventListener("change", o=>{
            o.stopPropagation(),
            this.onChange(o)
        }
        ),
        this.fileType && r.querySelector('input[type="file"]')?.setAttribute("accept", this.fileType),
        r
    }
}
var Mr = {
    exports: {}
};
var _0 = Mr.exports, Vh;
function uu() {
    return Vh || (Vh = 1,
    (function(i, e) {
        (function(n, r) {
            r(e)
        }
        )(_0, (function(n) {
            var r = "1.9.4";
            function o(t) {
                var s, c, p, E;
                for (c = 1,
                p = arguments.length; c < p; c++) {
                    E = arguments[c];
                    for (s in E)
                        t[s] = E[s]
                }
                return t
            }
            var a = Object.create || (function() {
                function t() {}
                return function(s) {
                    return t.prototype = s,
                    new t
                }
            }
            )();
            function l(t, s) {
                var c = Array.prototype.slice;
                if (t.bind)
                    return t.bind.apply(t, c.call(arguments, 1));
                var p = c.call(arguments, 2);
                return function() {
                    return t.apply(s, p.length ? p.concat(c.call(arguments)) : arguments)
                }
            }
            var u = 0;
            function f(t) {
                return "_leaflet_id"in t || (t._leaflet_id = ++u),
                t._leaflet_id
            }
            function h(t, s, c) {
                var p, E, k, ne;
                return ne = function() {
                    p = !1,
                    E && (k.apply(c, E),
                    E = !1)
                }
                ,
                k = function() {
                    p ? E = arguments : (t.apply(c, arguments),
                    setTimeout(ne, s),
                    p = !0)
                }
                ,
                k
            }
            function m(t, s, c) {
                var p = s[1]
                  , E = s[0]
                  , k = p - E;
                return t === p && c ? t : ((t - E) % k + k) % k + E
            }
            function _() {
                return !1
            }
            function d(t, s) {
                if (s === !1)
                    return t;
                var c = Math.pow(10, s === void 0 ? 6 : s);
                return Math.round(t * c) / c
            }
            function g(t) {
                return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
            }
            function b(t) {
                return g(t).split(/\s+/)
            }
            function T(t, s) {
                Object.prototype.hasOwnProperty.call(t, "options") || (t.options = t.options ? a(t.options) : {});
                for (var c in s)
                    t.options[c] = s[c];
                return t.options
            }
            function N(t, s, c) {
                var p = [];
                for (var E in t)
                    p.push(encodeURIComponent(c ? E.toUpperCase() : E) + "=" + encodeURIComponent(t[E]));
                return (!s || s.indexOf("?") === -1 ? "?" : "&") + p.join("&")
            }
            var A = /\{ *([\w_ -]+) *\}/g;
            function R(t, s) {
                return t.replace(A, function(c, p) {
                    var E = s[p];
                    if (E === void 0)
                        throw new Error("No value provided for variable " + c);
                    return typeof E == "function" && (E = E(s)),
                    E
                })
            }
            var S = Array.isArray || function(t) {
                return Object.prototype.toString.call(t) === "[object Array]"
            }
            ;
            function y(t, s) {
                for (var c = 0; c < t.length; c++)
                    if (t[c] === s)
                        return c;
                return -1
            }
            var x = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
            function M(t) {
                return window["webkit" + t] || window["moz" + t] || window["ms" + t]
            }
            var U = 0;
            function O(t) {
                var s = +new Date
                  , c = Math.max(0, 16 - (s - U));
                return U = s + c,
                window.setTimeout(t, c)
            }
            var Q = window.requestAnimationFrame || M("RequestAnimationFrame") || O
              , D = window.cancelAnimationFrame || M("CancelAnimationFrame") || M("CancelRequestAnimationFrame") || function(t) {
                window.clearTimeout(t)
            }
            ;
            function $(t, s, c) {
                if (c && Q === O)
                    t.call(s);
                else
                    return Q.call(window, l(t, s))
            }
            function X(t) {
                t && D.call(window, t)
            }
            var F = {
                __proto__: null,
                extend: o,
                create: a,
                bind: l,
                get lastId() {
                    return u
                },
                stamp: f,
                throttle: h,
                wrapNum: m,
                falseFn: _,
                formatNum: d,
                trim: g,
                splitWords: b,
                setOptions: T,
                getParamString: N,
                template: R,
                isArray: S,
                indexOf: y,
                emptyImageUrl: x,
                requestFn: Q,
                cancelFn: D,
                requestAnimFrame: $,
                cancelAnimFrame: X
            };
            function B() {}
            B.extend = function(t) {
                var s = function() {
                    T(this),
                    this.initialize && this.initialize.apply(this, arguments),
                    this.callInitHooks()
                }
                  , c = s.__super__ = this.prototype
                  , p = a(c);
                p.constructor = s,
                s.prototype = p;
                for (var E in this)
                    Object.prototype.hasOwnProperty.call(this, E) && E !== "prototype" && E !== "__super__" && (s[E] = this[E]);
                return t.statics && o(s, t.statics),
                t.includes && (ue(t.includes),
                o.apply(null, [p].concat(t.includes))),
                o(p, t),
                delete p.statics,
                delete p.includes,
                p.options && (p.options = c.options ? a(c.options) : {},
                o(p.options, t.options)),
                p._initHooks = [],
                p.callInitHooks = function() {
                    if (!this._initHooksCalled) {
                        c.callInitHooks && c.callInitHooks.call(this),
                        this._initHooksCalled = !0;
                        for (var k = 0, ne = p._initHooks.length; k < ne; k++)
                            p._initHooks[k].call(this)
                    }
                }
                ,
                s
            }
            ,
            B.include = function(t) {
                var s = this.prototype.options;
                return o(this.prototype, t),
                t.options && (this.prototype.options = s,
                this.mergeOptions(t.options)),
                this
            }
            ,
            B.mergeOptions = function(t) {
                return o(this.prototype.options, t),
                this
            }
            ,
            B.addInitHook = function(t) {
                var s = Array.prototype.slice.call(arguments, 1)
                  , c = typeof t == "function" ? t : function() {
                    this[t].apply(this, s)
                }
                ;
                return this.prototype._initHooks = this.prototype._initHooks || [],
                this.prototype._initHooks.push(c),
                this
            }
            ;
            function ue(t) {
                if (!(typeof L > "u" || !L || !L.Mixin)) {
                    t = S(t) ? t : [t];
                    for (var s = 0; s < t.length; s++)
                        t[s] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", new Error().stack)
                }
            }
            var P = {
                on: function(t, s, c) {
                    if (typeof t == "object")
                        for (var p in t)
                            this._on(p, t[p], s);
                    else {
                        t = b(t);
                        for (var E = 0, k = t.length; E < k; E++)
                            this._on(t[E], s, c)
                    }
                    return this
                },
                off: function(t, s, c) {
                    if (!arguments.length)
                        delete this._events;
                    else if (typeof t == "object")
                        for (var p in t)
                            this._off(p, t[p], s);
                    else {
                        t = b(t);
                        for (var E = arguments.length === 1, k = 0, ne = t.length; k < ne; k++)
                            E ? this._off(t[k]) : this._off(t[k], s, c)
                    }
                    return this
                },
                _on: function(t, s, c, p) {
                    if (typeof s != "function") {
                        console.warn("wrong listener type: " + typeof s);
                        return
                    }
                    if (this._listens(t, s, c) === !1) {
                        c === this && (c = void 0);
                        var E = {
                            fn: s,
                            ctx: c
                        };
                        p && (E.once = !0),
                        this._events = this._events || {},
                        this._events[t] = this._events[t] || [],
                        this._events[t].push(E)
                    }
                },
                _off: function(t, s, c) {
                    var p, E, k;
                    if (this._events && (p = this._events[t],
                    !!p)) {
                        if (arguments.length === 1) {
                            if (this._firingCount)
                                for (E = 0,
                                k = p.length; E < k; E++)
                                    p[E].fn = _;
                            delete this._events[t];
                            return
                        }
                        if (typeof s != "function") {
                            console.warn("wrong listener type: " + typeof s);
                            return
                        }
                        var ne = this._listens(t, s, c);
                        if (ne !== !1) {
                            var he = p[ne];
                            this._firingCount && (he.fn = _,
                            this._events[t] = p = p.slice()),
                            p.splice(ne, 1)
                        }
                    }
                },
                fire: function(t, s, c) {
                    if (!this.listens(t, c))
                        return this;
                    var p = o({}, s, {
                        type: t,
                        target: this,
                        sourceTarget: s && s.sourceTarget || this
                    });
                    if (this._events) {
                        var E = this._events[t];
                        if (E) {
                            this._firingCount = this._firingCount + 1 || 1;
                            for (var k = 0, ne = E.length; k < ne; k++) {
                                var he = E[k]
                                  , ye = he.fn;
                                he.once && this.off(t, ye, he.ctx),
                                ye.call(he.ctx || this, p)
                            }
                            this._firingCount--
                        }
                    }
                    return c && this._propagateEvent(p),
                    this
                },
                listens: function(t, s, c, p) {
                    typeof t != "string" && console.warn('"string" type argument expected');
                    var E = s;
                    typeof s != "function" && (p = !!s,
                    E = void 0,
                    c = void 0);
                    var k = this._events && this._events[t];
                    if (k && k.length && this._listens(t, E, c) !== !1)
                        return !0;
                    if (p) {
                        for (var ne in this._eventParents)
                            if (this._eventParents[ne].listens(t, s, c, p))
                                return !0
                    }
                    return !1
                },
                _listens: function(t, s, c) {
                    if (!this._events)
                        return !1;
                    var p = this._events[t] || [];
                    if (!s)
                        return !!p.length;
                    c === this && (c = void 0);
                    for (var E = 0, k = p.length; E < k; E++)
                        if (p[E].fn === s && p[E].ctx === c)
                            return E;
                    return !1
                },
                once: function(t, s, c) {
                    if (typeof t == "object")
                        for (var p in t)
                            this._on(p, t[p], s, !0);
                    else {
                        t = b(t);
                        for (var E = 0, k = t.length; E < k; E++)
                            this._on(t[E], s, c, !0)
                    }
                    return this
                },
                addEventParent: function(t) {
                    return this._eventParents = this._eventParents || {},
                    this._eventParents[f(t)] = t,
                    this
                },
                removeEventParent: function(t) {
                    return this._eventParents && delete this._eventParents[f(t)],
                    this
                },
                _propagateEvent: function(t) {
                    for (var s in this._eventParents)
                        this._eventParents[s].fire(t.type, o({
                            layer: t.target,
                            propagatedFrom: t.target
                        }, t), !0)
                }
            };
            P.addEventListener = P.on,
            P.removeEventListener = P.clearAllEventListeners = P.off,
            P.addOneTimeEventListener = P.once,
            P.fireEvent = P.fire,
            P.hasEventListeners = P.listens;
            var oe = B.extend(P);
            function j(t, s, c) {
                this.x = c ? Math.round(t) : t,
                this.y = c ? Math.round(s) : s
            }
            var ae = Math.trunc || function(t) {
                return t > 0 ? Math.floor(t) : Math.ceil(t)
            }
            ;
            j.prototype = {
                clone: function() {
                    return new j(this.x,this.y)
                },
                add: function(t) {
                    return this.clone()._add(I(t))
                },
                _add: function(t) {
                    return this.x += t.x,
                    this.y += t.y,
                    this
                },
                subtract: function(t) {
                    return this.clone()._subtract(I(t))
                },
                _subtract: function(t) {
                    return this.x -= t.x,
                    this.y -= t.y,
                    this
                },
                divideBy: function(t) {
                    return this.clone()._divideBy(t)
                },
                _divideBy: function(t) {
                    return this.x /= t,
                    this.y /= t,
                    this
                },
                multiplyBy: function(t) {
                    return this.clone()._multiplyBy(t)
                },
                _multiplyBy: function(t) {
                    return this.x *= t,
                    this.y *= t,
                    this
                },
                scaleBy: function(t) {
                    return new j(this.x * t.x,this.y * t.y)
                },
                unscaleBy: function(t) {
                    return new j(this.x / t.x,this.y / t.y)
                },
                round: function() {
                    return this.clone()._round()
                },
                _round: function() {
                    return this.x = Math.round(this.x),
                    this.y = Math.round(this.y),
                    this
                },
                floor: function() {
                    return this.clone()._floor()
                },
                _floor: function() {
                    return this.x = Math.floor(this.x),
                    this.y = Math.floor(this.y),
                    this
                },
                ceil: function() {
                    return this.clone()._ceil()
                },
                _ceil: function() {
                    return this.x = Math.ceil(this.x),
                    this.y = Math.ceil(this.y),
                    this
                },
                trunc: function() {
                    return this.clone()._trunc()
                },
                _trunc: function() {
                    return this.x = ae(this.x),
                    this.y = ae(this.y),
                    this
                },
                distanceTo: function(t) {
                    t = I(t);
                    var s = t.x - this.x
                      , c = t.y - this.y;
                    return Math.sqrt(s * s + c * c)
                },
                equals: function(t) {
                    return t = I(t),
                    t.x === this.x && t.y === this.y
                },
                contains: function(t) {
                    return t = I(t),
                    Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y)
                },
                toString: function() {
                    return "Point(" + d(this.x) + ", " + d(this.y) + ")"
                }
            };
            function I(t, s, c) {
                return t instanceof j ? t : S(t) ? new j(t[0],t[1]) : t == null ? t : typeof t == "object" && "x"in t && "y"in t ? new j(t.x,t.y) : new j(t,s,c)
            }
            function Z(t, s) {
                if (t)
                    for (var c = s ? [t, s] : t, p = 0, E = c.length; p < E; p++)
                        this.extend(c[p])
            }
            Z.prototype = {
                extend: function(t) {
                    var s, c;
                    if (!t)
                        return this;
                    if (t instanceof j || typeof t[0] == "number" || "x"in t)
                        s = c = I(t);
                    else if (t = ie(t),
                    s = t.min,
                    c = t.max,
                    !s || !c)
                        return this;
                    return !this.min && !this.max ? (this.min = s.clone(),
                    this.max = c.clone()) : (this.min.x = Math.min(s.x, this.min.x),
                    this.max.x = Math.max(c.x, this.max.x),
                    this.min.y = Math.min(s.y, this.min.y),
                    this.max.y = Math.max(c.y, this.max.y)),
                    this
                },
                getCenter: function(t) {
                    return I((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t)
                },
                getBottomLeft: function() {
                    return I(this.min.x, this.max.y)
                },
                getTopRight: function() {
                    return I(this.max.x, this.min.y)
                },
                getTopLeft: function() {
                    return this.min
                },
                getBottomRight: function() {
                    return this.max
                },
                getSize: function() {
                    return this.max.subtract(this.min)
                },
                contains: function(t) {
                    var s, c;
                    return typeof t[0] == "number" || t instanceof j ? t = I(t) : t = ie(t),
                    t instanceof Z ? (s = t.min,
                    c = t.max) : s = c = t,
                    s.x >= this.min.x && c.x <= this.max.x && s.y >= this.min.y && c.y <= this.max.y
                },
                intersects: function(t) {
                    t = ie(t);
                    var s = this.min
                      , c = this.max
                      , p = t.min
                      , E = t.max
                      , k = E.x >= s.x && p.x <= c.x
                      , ne = E.y >= s.y && p.y <= c.y;
                    return k && ne
                },
                overlaps: function(t) {
                    t = ie(t);
                    var s = this.min
                      , c = this.max
                      , p = t.min
                      , E = t.max
                      , k = E.x > s.x && p.x < c.x
                      , ne = E.y > s.y && p.y < c.y;
                    return k && ne
                },
                isValid: function() {
                    return !!(this.min && this.max)
                },
                pad: function(t) {
                    var s = this.min
                      , c = this.max
                      , p = Math.abs(s.x - c.x) * t
                      , E = Math.abs(s.y - c.y) * t;
                    return ie(I(s.x - p, s.y - E), I(c.x + p, c.y + E))
                },
                equals: function(t) {
                    return t ? (t = ie(t),
                    this.min.equals(t.getTopLeft()) && this.max.equals(t.getBottomRight())) : !1
                }
            };
            function ie(t, s) {
                return !t || t instanceof Z ? t : new Z(t,s)
            }
            function ee(t, s) {
                if (t)
                    for (var c = s ? [t, s] : t, p = 0, E = c.length; p < E; p++)
                        this.extend(c[p])
            }
            ee.prototype = {
                extend: function(t) {
                    var s = this._southWest, c = this._northEast, p, E;
                    if (t instanceof W)
                        p = t,
                        E = t;
                    else if (t instanceof ee) {
                        if (p = t._southWest,
                        E = t._northEast,
                        !p || !E)
                            return this
                    } else
                        return t ? this.extend(G(t) || me(t)) : this;
                    return !s && !c ? (this._southWest = new W(p.lat,p.lng),
                    this._northEast = new W(E.lat,E.lng)) : (s.lat = Math.min(p.lat, s.lat),
                    s.lng = Math.min(p.lng, s.lng),
                    c.lat = Math.max(E.lat, c.lat),
                    c.lng = Math.max(E.lng, c.lng)),
                    this
                },
                pad: function(t) {
                    var s = this._southWest
                      , c = this._northEast
                      , p = Math.abs(s.lat - c.lat) * t
                      , E = Math.abs(s.lng - c.lng) * t;
                    return new ee(new W(s.lat - p,s.lng - E),new W(c.lat + p,c.lng + E))
                },
                getCenter: function() {
                    return new W((this._southWest.lat + this._northEast.lat) / 2,(this._southWest.lng + this._northEast.lng) / 2)
                },
                getSouthWest: function() {
                    return this._southWest
                },
                getNorthEast: function() {
                    return this._northEast
                },
                getNorthWest: function() {
                    return new W(this.getNorth(),this.getWest())
                },
                getSouthEast: function() {
                    return new W(this.getSouth(),this.getEast())
                },
                getWest: function() {
                    return this._southWest.lng
                },
                getSouth: function() {
                    return this._southWest.lat
                },
                getEast: function() {
                    return this._northEast.lng
                },
                getNorth: function() {
                    return this._northEast.lat
                },
                contains: function(t) {
                    typeof t[0] == "number" || t instanceof W || "lat"in t ? t = G(t) : t = me(t);
                    var s = this._southWest, c = this._northEast, p, E;
                    return t instanceof ee ? (p = t.getSouthWest(),
                    E = t.getNorthEast()) : p = E = t,
                    p.lat >= s.lat && E.lat <= c.lat && p.lng >= s.lng && E.lng <= c.lng
                },
                intersects: function(t) {
                    t = me(t);
                    var s = this._southWest
                      , c = this._northEast
                      , p = t.getSouthWest()
                      , E = t.getNorthEast()
                      , k = E.lat >= s.lat && p.lat <= c.lat
                      , ne = E.lng >= s.lng && p.lng <= c.lng;
                    return k && ne
                },
                overlaps: function(t) {
                    t = me(t);
                    var s = this._southWest
                      , c = this._northEast
                      , p = t.getSouthWest()
                      , E = t.getNorthEast()
                      , k = E.lat > s.lat && p.lat < c.lat
                      , ne = E.lng > s.lng && p.lng < c.lng;
                    return k && ne
                },
                toBBoxString: function() {
                    return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",")
                },
                equals: function(t, s) {
                    return t ? (t = me(t),
                    this._southWest.equals(t.getSouthWest(), s) && this._northEast.equals(t.getNorthEast(), s)) : !1
                },
                isValid: function() {
                    return !!(this._southWest && this._northEast)
                }
            };
            function me(t, s) {
                return t instanceof ee ? t : new ee(t,s)
            }
            function W(t, s, c) {
                if (isNaN(t) || isNaN(s))
                    throw new Error("Invalid LatLng object: (" + t + ", " + s + ")");
                this.lat = +t,
                this.lng = +s,
                c !== void 0 && (this.alt = +c)
            }
            W.prototype = {
                equals: function(t, s) {
                    if (!t)
                        return !1;
                    t = G(t);
                    var c = Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng));
                    return c <= (s === void 0 ? 1e-9 : s)
                },
                toString: function(t) {
                    return "LatLng(" + d(this.lat, t) + ", " + d(this.lng, t) + ")"
                },
                distanceTo: function(t) {
                    return K.distance(this, G(t))
                },
                wrap: function() {
                    return K.wrapLatLng(this)
                },
                toBounds: function(t) {
                    var s = 180 * t / 40075017
                      , c = s / Math.cos(Math.PI / 180 * this.lat);
                    return me([this.lat - s, this.lng - c], [this.lat + s, this.lng + c])
                },
                clone: function() {
                    return new W(this.lat,this.lng,this.alt)
                }
            };
            function G(t, s, c) {
                return t instanceof W ? t : S(t) && typeof t[0] != "object" ? t.length === 3 ? new W(t[0],t[1],t[2]) : t.length === 2 ? new W(t[0],t[1]) : null : t == null ? t : typeof t == "object" && "lat"in t ? new W(t.lat,"lng"in t ? t.lng : t.lon,t.alt) : s === void 0 ? null : new W(t,s,c)
            }
            var Y = {
                latLngToPoint: function(t, s) {
                    var c = this.projection.project(t)
                      , p = this.scale(s);
                    return this.transformation._transform(c, p)
                },
                pointToLatLng: function(t, s) {
                    var c = this.scale(s)
                      , p = this.transformation.untransform(t, c);
                    return this.projection.unproject(p)
                },
                project: function(t) {
                    return this.projection.project(t)
                },
                unproject: function(t) {
                    return this.projection.unproject(t)
                },
                scale: function(t) {
                    return 256 * Math.pow(2, t)
                },
                zoom: function(t) {
                    return Math.log(t / 256) / Math.LN2
                },
                getProjectedBounds: function(t) {
                    if (this.infinite)
                        return null;
                    var s = this.projection.bounds
                      , c = this.scale(t)
                      , p = this.transformation.transform(s.min, c)
                      , E = this.transformation.transform(s.max, c);
                    return new Z(p,E)
                },
                infinite: !1,
                wrapLatLng: function(t) {
                    var s = this.wrapLng ? m(t.lng, this.wrapLng, !0) : t.lng
                      , c = this.wrapLat ? m(t.lat, this.wrapLat, !0) : t.lat
                      , p = t.alt;
                    return new W(c,s,p)
                },
                wrapLatLngBounds: function(t) {
                    var s = t.getCenter()
                      , c = this.wrapLatLng(s)
                      , p = s.lat - c.lat
                      , E = s.lng - c.lng;
                    if (p === 0 && E === 0)
                        return t;
                    var k = t.getSouthWest()
                      , ne = t.getNorthEast()
                      , he = new W(k.lat - p,k.lng - E)
                      , ye = new W(ne.lat - p,ne.lng - E);
                    return new ee(he,ye)
                }
            }
              , K = o({}, Y, {
                wrapLng: [-180, 180],
                R: 6371e3,
                distance: function(t, s) {
                    var c = Math.PI / 180
                      , p = t.lat * c
                      , E = s.lat * c
                      , k = Math.sin((s.lat - t.lat) * c / 2)
                      , ne = Math.sin((s.lng - t.lng) * c / 2)
                      , he = k * k + Math.cos(p) * Math.cos(E) * ne * ne
                      , ye = 2 * Math.atan2(Math.sqrt(he), Math.sqrt(1 - he));
                    return this.R * ye
                }
            })
              , le = 6378137
              , ce = {
                R: le,
                MAX_LATITUDE: 85.0511287798,
                project: function(t) {
                    var s = Math.PI / 180
                      , c = this.MAX_LATITUDE
                      , p = Math.max(Math.min(c, t.lat), -c)
                      , E = Math.sin(p * s);
                    return new j(this.R * t.lng * s,this.R * Math.log((1 + E) / (1 - E)) / 2)
                },
                unproject: function(t) {
                    var s = 180 / Math.PI;
                    return new W((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * s,t.x * s / this.R)
                },
                bounds: (function() {
                    var t = le * Math.PI;
                    return new Z([-t, -t],[t, t])
                }
                )()
            };
            function Ee(t, s, c, p) {
                if (S(t)) {
                    this._a = t[0],
                    this._b = t[1],
                    this._c = t[2],
                    this._d = t[3];
                    return
                }
                this._a = t,
                this._b = s,
                this._c = c,
                this._d = p
            }
            Ee.prototype = {
                transform: function(t, s) {
                    return this._transform(t.clone(), s)
                },
                _transform: function(t, s) {
                    return s = s || 1,
                    t.x = s * (this._a * t.x + this._b),
                    t.y = s * (this._c * t.y + this._d),
                    t
                },
                untransform: function(t, s) {
                    return s = s || 1,
                    new j((t.x / s - this._b) / this._a,(t.y / s - this._d) / this._c)
                }
            };
            function Te(t, s, c, p) {
                return new Ee(t,s,c,p)
            }
            var q = o({}, K, {
                code: "EPSG:3857",
                projection: ce,
                transformation: (function() {
                    var t = .5 / (Math.PI * ce.R);
                    return Te(t, .5, -t, .5)
                }
                )()
            })
              , te = o({}, q, {
                code: "EPSG:900913"
            });
            function fe(t) {
                return document.createElementNS("http://www.w3.org/2000/svg", t)
            }
            function xe(t, s) {
                var c = "", p, E, k, ne, he, ye;
                for (p = 0,
                k = t.length; p < k; p++) {
                    for (he = t[p],
                    E = 0,
                    ne = he.length; E < ne; E++)
                        ye = he[E],
                        c += (E ? "L" : "M") + ye.x + " " + ye.y;
                    c += s ? Pe.svg ? "z" : "x" : ""
                }
                return c || "M0 0"
            }
            var Se = document.documentElement.style
              , Ie = "ActiveXObject"in window
              , se = Ie && !document.addEventListener
              , be = "msLaunchUri"in navigator && !("documentMode"in document)
              , Ne = Nt("webkit")
              , ve = Nt("android")
              , $e = Nt("android 2") || Nt("android 3")
              , mt = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10)
              , Be = ve && Nt("Google") && mt < 537 && !("AudioNode"in window)
              , ft = !!window.opera
              , C = !be && Nt("chrome")
              , v = Nt("gecko") && !Ne && !ft && !Ie
              , w = !C && Nt("safari")
              , H = Nt("phantom")
              , re = "OTransition"in Se
              , _e = navigator.platform.indexOf("Win") === 0
              , we = Ie && "transition"in Se
              , Oe = "WebKitCSSMatrix"in window && "m11"in new window.WebKitCSSMatrix && !$e
              , Ye = "MozPerspective"in Se
              , Qe = !window.L_DISABLE_3D && (we || Oe || Ye) && !re && !H
              , We = typeof orientation < "u" || Nt("mobile")
              , Ze = We && Ne
              , Bt = We && Oe
              , Yt = !window.PointerEvent && window.MSPointerEvent
              , st = !!(window.PointerEvent || Yt)
              , at = "ontouchstart"in window || !!window.TouchEvent
              , Si = !window.L_NO_TOUCH && (at || st)
              , cn = We && ft
              , Pn = We && v
              , Zn = (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI) > 1
              , z = (function() {
                var t = !1;
                try {
                    var s = Object.defineProperty({}, "passive", {
                        get: function() {
                            t = !0
                        }
                    });
                    window.addEventListener("testPassiveEventSupport", _, s),
                    window.removeEventListener("testPassiveEventSupport", _, s)
                } catch {}
                return t
            }
            )()
              , J = (function() {
                return !!document.createElement("canvas").getContext
            }
            )()
              , Ae = !!(document.createElementNS && fe("svg").createSVGRect)
              , Re = !!Ae && (function() {
                var t = document.createElement("div");
                return t.innerHTML = "<svg/>",
                (t.firstChild && t.firstChild.namespaceURI) === "http://www.w3.org/2000/svg"
            }
            )()
              , Me = !Ae && (function() {
                try {
                    var t = document.createElement("div");
                    t.innerHTML = '<v:shape adj="1"/>';
                    var s = t.firstChild;
                    return s.style.behavior = "url(#default#VML)",
                    s && typeof s.adj == "object"
                } catch {
                    return !1
                }
            }
            )()
              , _t = navigator.platform.indexOf("Mac") === 0
              , bt = navigator.platform.indexOf("Linux") === 0;
            function Nt(t) {
                return navigator.userAgent.toLowerCase().indexOf(t) >= 0
            }
            var Pe = {
                ie: Ie,
                ielt9: se,
                edge: be,
                webkit: Ne,
                android: ve,
                android23: $e,
                androidStock: Be,
                opera: ft,
                chrome: C,
                gecko: v,
                safari: w,
                phantom: H,
                opera12: re,
                win: _e,
                ie3d: we,
                webkit3d: Oe,
                gecko3d: Ye,
                any3d: Qe,
                mobile: We,
                mobileWebkit: Ze,
                mobileWebkit3d: Bt,
                msPointer: Yt,
                pointer: st,
                touch: Si,
                touchNative: at,
                mobileOpera: cn,
                mobileGecko: Pn,
                retina: Zn,
                passiveEvents: z,
                canvas: J,
                svg: Ae,
                vml: Me,
                inlineSvg: Re,
                mac: _t,
                linux: bt
            }
              , Xn = Pe.msPointer ? "MSPointerDown" : "pointerdown"
              , Ut = Pe.msPointer ? "MSPointerMove" : "pointermove"
              , Mn = Pe.msPointer ? "MSPointerUp" : "pointerup"
              , bn = Pe.msPointer ? "MSPointerCancel" : "pointercancel"
              , dn = {
                touchstart: Xn,
                touchmove: Ut,
                touchend: Mn,
                touchcancel: bn
            }
              , Dn = {
                touchstart: ro,
                touchmove: en,
                touchend: en,
                touchcancel: en
            }
              , it = {}
              , V = !1;
            function de(t, s, c) {
                return s === "touchstart" && wt(),
                Dn[s] ? (c = Dn[s].bind(this, c),
                t.addEventListener(dn[s], c, !1),
                c) : (console.warn("wrong event specified:", s),
                _)
            }
            function pe(t, s, c) {
                if (!dn[s]) {
                    console.warn("wrong event specified:", s);
                    return
                }
                t.removeEventListener(dn[s], c, !1)
            }
            function ke(t) {
                it[t.pointerId] = t
            }
            function He(t) {
                it[t.pointerId] && (it[t.pointerId] = t)
            }
            function Je(t) {
                delete it[t.pointerId]
            }
            function wt() {
                V || (document.addEventListener(Xn, ke, !0),
                document.addEventListener(Ut, He, !0),
                document.addEventListener(Mn, Je, !0),
                document.addEventListener(bn, Je, !0),
                V = !0)
            }
            function en(t, s) {
                if (s.pointerType !== (s.MSPOINTER_TYPE_MOUSE || "mouse")) {
                    s.touches = [];
                    for (var c in it)
                        s.touches.push(it[c]);
                    s.changedTouches = [s],
                    t(s)
                }
            }
            function ro(t, s) {
                s.MSPOINTER_TYPE_TOUCH && s.pointerType === s.MSPOINTER_TYPE_TOUCH && St(s),
                en(t, s)
            }
            function On(t) {
                var s = {}, c, p;
                for (p in t)
                    c = t[p],
                    s[p] = c && c.bind ? c.bind(t) : c;
                return t = s,
                s.type = "dblclick",
                s.detail = 2,
                s.isTrusted = !1,
                s._simulated = !0,
                s
            }
            var Qn = 200;
            function vp(t, s) {
                t.addEventListener("dblclick", s);
                var c = 0, p;
                function E(k) {
                    if (k.detail !== 1) {
                        p = k.detail;
                        return
                    }
                    if (!(k.pointerType === "mouse" || k.sourceCapabilities && !k.sourceCapabilities.firesTouchEvents)) {
                        var ne = pu(k);
                        if (!(ne.some(function(ye) {
                            return ye instanceof HTMLLabelElement && ye.attributes.for
                        }) && !ne.some(function(ye) {
                            return ye instanceof HTMLInputElement || ye instanceof HTMLSelectElement
                        }))) {
                            var he = Date.now();
                            he - c <= Qn ? (p++,
                            p === 2 && s(On(k))) : p = 1,
                            c = he
                        }
                    }
                }
                return t.addEventListener("click", E),
                {
                    dblclick: s,
                    simDblclick: E
                }
            }
            function bp(t, s) {
                t.removeEventListener("dblclick", s.dblclick),
                t.removeEventListener("click", s.simDblclick)
            }
            var so = Jr(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"])
              , Ji = Jr(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"])
              , cu = Ji === "webkitTransition" || Ji === "OTransition" ? Ji + "End" : "transitionend";
            function du(t) {
                return typeof t == "string" ? document.getElementById(t) : t
            }
            function Ki(t, s) {
                var c = t.style[s] || t.currentStyle && t.currentStyle[s];
                if ((!c || c === "auto") && document.defaultView) {
                    var p = document.defaultView.getComputedStyle(t, null);
                    c = p ? p[s] : null
                }
                return c === "auto" ? null : c
            }
            function Ke(t, s, c) {
                var p = document.createElement(t);
                return p.className = s || "",
                c && c.appendChild(p),
                p
            }
            function ut(t) {
                var s = t.parentNode;
                s && s.removeChild(t)
            }
            function Xr(t) {
                for (; t.firstChild; )
                    t.removeChild(t.firstChild)
            }
            function Ti(t) {
                var s = t.parentNode;
                s && s.lastChild !== t && s.appendChild(t)
            }
            function Li(t) {
                var s = t.parentNode;
                s && s.firstChild !== t && s.insertBefore(t, s.firstChild)
            }
            function oo(t, s) {
                if (t.classList !== void 0)
                    return t.classList.contains(s);
                var c = Qr(t);
                return c.length > 0 && new RegExp("(^|\\s)" + s + "(\\s|$)").test(c)
            }
            function Ue(t, s) {
                if (t.classList !== void 0)
                    for (var c = b(s), p = 0, E = c.length; p < E; p++)
                        t.classList.add(c[p]);
                else if (!oo(t, s)) {
                    var k = Qr(t);
                    ao(t, (k ? k + " " : "") + s)
                }
            }
            function pt(t, s) {
                t.classList !== void 0 ? t.classList.remove(s) : ao(t, g((" " + Qr(t) + " ").replace(" " + s + " ", " ")))
            }
            function ao(t, s) {
                t.className.baseVal === void 0 ? t.className = s : t.className.baseVal = s
            }
            function Qr(t) {
                return t.correspondingElement && (t = t.correspondingElement),
                t.className.baseVal === void 0 ? t.className : t.className.baseVal
            }
            function Ht(t, s) {
                "opacity"in t.style ? t.style.opacity = s : "filter"in t.style && wp(t, s)
            }
            function wp(t, s) {
                var c = !1
                  , p = "DXImageTransform.Microsoft.Alpha";
                try {
                    c = t.filters.item(p)
                } catch {
                    if (s === 1)
                        return
                }
                s = Math.round(s * 100),
                c ? (c.Enabled = s !== 100,
                c.Opacity = s) : t.style.filter += " progid:" + p + "(opacity=" + s + ")"
            }
            function Jr(t) {
                for (var s = document.documentElement.style, c = 0; c < t.length; c++)
                    if (t[c]in s)
                        return t[c];
                return !1
            }
            function Jn(t, s, c) {
                var p = s || new j(0,0);
                t.style[so] = (Pe.ie3d ? "translate(" + p.x + "px," + p.y + "px)" : "translate3d(" + p.x + "px," + p.y + "px,0)") + (c ? " scale(" + c + ")" : "")
            }
            function yt(t, s) {
                t._leaflet_pos = s,
                Pe.any3d ? Jn(t, s) : (t.style.left = s.x + "px",
                t.style.top = s.y + "px")
            }
            function Kn(t) {
                return t._leaflet_pos || new j(0,0)
            }
            var Yi, er, lo;
            if ("onselectstart"in document)
                Yi = function() {
                    qe(window, "selectstart", St)
                }
                ,
                er = function() {
                    rt(window, "selectstart", St)
                }
                ;
            else {
                var tr = Jr(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
                Yi = function() {
                    if (tr) {
                        var t = document.documentElement.style;
                        lo = t[tr],
                        t[tr] = "none"
                    }
                }
                ,
                er = function() {
                    tr && (document.documentElement.style[tr] = lo,
                    lo = void 0)
                }
            }
            function uo() {
                qe(window, "dragstart", St)
            }
            function co() {
                rt(window, "dragstart", St)
            }
            var Kr, ho;
            function fo(t) {
                for (; t.tabIndex === -1; )
                    t = t.parentNode;
                t.style && (Yr(),
                Kr = t,
                ho = t.style.outlineStyle,
                t.style.outlineStyle = "none",
                qe(window, "keydown", Yr))
            }
            function Yr() {
                Kr && (Kr.style.outlineStyle = ho,
                Kr = void 0,
                ho = void 0,
                rt(window, "keydown", Yr))
            }
            function hu(t) {
                do
                    t = t.parentNode;
                while ((!t.offsetWidth || !t.offsetHeight) && t !== document.body);
                return t
            }
            function po(t) {
                var s = t.getBoundingClientRect();
                return {
                    x: s.width / t.offsetWidth || 1,
                    y: s.height / t.offsetHeight || 1,
                    boundingClientRect: s
                }
            }
            var xp = {
                __proto__: null,
                TRANSFORM: so,
                TRANSITION: Ji,
                TRANSITION_END: cu,
                get: du,
                getStyle: Ki,
                create: Ke,
                remove: ut,
                empty: Xr,
                toFront: Ti,
                toBack: Li,
                hasClass: oo,
                addClass: Ue,
                removeClass: pt,
                setClass: ao,
                getClass: Qr,
                setOpacity: Ht,
                testProp: Jr,
                setTransform: Jn,
                setPosition: yt,
                getPosition: Kn,
                get disableTextSelection() {
                    return Yi
                },
                get enableTextSelection() {
                    return er
                },
                disableImageDrag: uo,
                enableImageDrag: co,
                preventOutline: fo,
                restoreOutline: Yr,
                getSizedParentNode: hu,
                getScale: po
            };
            function qe(t, s, c, p) {
                if (s && typeof s == "object")
                    for (var E in s)
                        mo(t, E, s[E], c);
                else {
                    s = b(s);
                    for (var k = 0, ne = s.length; k < ne; k++)
                        mo(t, s[k], c, p)
                }
                return this
            }
            var hn = "_leaflet_events";
            function rt(t, s, c, p) {
                if (arguments.length === 1)
                    fu(t),
                    delete t[hn];
                else if (s && typeof s == "object")
                    for (var E in s)
                        _o(t, E, s[E], c);
                else if (s = b(s),
                arguments.length === 2)
                    fu(t, function(he) {
                        return y(s, he) !== -1
                    });
                else
                    for (var k = 0, ne = s.length; k < ne; k++)
                        _o(t, s[k], c, p);
                return this
            }
            function fu(t, s) {
                for (var c in t[hn]) {
                    var p = c.split(/\d/)[0];
                    (!s || s(p)) && _o(t, p, null, null, c)
                }
            }
            var go = {
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                wheel: !("onwheel"in window) && "mousewheel"
            };
            function mo(t, s, c, p) {
                var E = s + f(c) + (p ? "_" + f(p) : "");
                if (t[hn] && t[hn][E])
                    return this;
                var k = function(he) {
                    return c.call(p || t, he || window.event)
                }
                  , ne = k;
                !Pe.touchNative && Pe.pointer && s.indexOf("touch") === 0 ? k = de(t, s, k) : Pe.touch && s === "dblclick" ? k = vp(t, k) : "addEventListener"in t ? s === "touchstart" || s === "touchmove" || s === "wheel" || s === "mousewheel" ? t.addEventListener(go[s] || s, k, Pe.passiveEvents ? {
                    passive: !1
                } : !1) : s === "mouseenter" || s === "mouseleave" ? (k = function(he) {
                    he = he || window.event,
                    vo(t, he) && ne(he)
                }
                ,
                t.addEventListener(go[s], k, !1)) : t.addEventListener(s, ne, !1) : t.attachEvent("on" + s, k),
                t[hn] = t[hn] || {},
                t[hn][E] = k
            }
            function _o(t, s, c, p, E) {
                E = E || s + f(c) + (p ? "_" + f(p) : "");
                var k = t[hn] && t[hn][E];
                if (!k)
                    return this;
                !Pe.touchNative && Pe.pointer && s.indexOf("touch") === 0 ? pe(t, s, k) : Pe.touch && s === "dblclick" ? bp(t, k) : "removeEventListener"in t ? t.removeEventListener(go[s] || s, k, !1) : t.detachEvent("on" + s, k),
                t[hn][E] = null
            }
            function Yn(t) {
                return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0,
                this
            }
            function yo(t) {
                return mo(t, "wheel", Yn),
                this
            }
            function nr(t) {
                return qe(t, "mousedown touchstart dblclick contextmenu", Yn),
                t._leaflet_disable_click = !0,
                this
            }
            function St(t) {
                return t.preventDefault ? t.preventDefault() : t.returnValue = !1,
                this
            }
            function ei(t) {
                return St(t),
                Yn(t),
                this
            }
            function pu(t) {
                if (t.composedPath)
                    return t.composedPath();
                for (var s = [], c = t.target; c; )
                    s.push(c),
                    c = c.parentNode;
                return s
            }
            function gu(t, s) {
                if (!s)
                    return new j(t.clientX,t.clientY);
                var c = po(s)
                  , p = c.boundingClientRect;
                return new j((t.clientX - p.left) / c.x - s.clientLeft,(t.clientY - p.top) / c.y - s.clientTop)
            }
            var Ep = Pe.linux && Pe.chrome ? window.devicePixelRatio : Pe.mac ? window.devicePixelRatio * 3 : window.devicePixelRatio > 0 ? 2 * window.devicePixelRatio : 1;
            function mu(t) {
                return Pe.edge ? t.wheelDeltaY / 2 : t.deltaY && t.deltaMode === 0 ? -t.deltaY / Ep : t.deltaY && t.deltaMode === 1 ? -t.deltaY * 20 : t.deltaY && t.deltaMode === 2 ? -t.deltaY * 60 : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? -t.detail * 20 : t.detail ? t.detail / -32765 * 60 : 0
            }
            function vo(t, s) {
                var c = s.relatedTarget;
                if (!c)
                    return !0;
                try {
                    for (; c && c !== t; )
                        c = c.parentNode
                } catch {
                    return !1
                }
                return c !== t
            }
            var Sp = {
                __proto__: null,
                on: qe,
                off: rt,
                stopPropagation: Yn,
                disableScrollPropagation: yo,
                disableClickPropagation: nr,
                preventDefault: St,
                stop: ei,
                getPropagationPath: pu,
                getMousePosition: gu,
                getWheelDelta: mu,
                isExternalTarget: vo,
                addListener: qe,
                removeListener: rt
            }
              , _u = oe.extend({
                run: function(t, s, c, p) {
                    this.stop(),
                    this._el = t,
                    this._inProgress = !0,
                    this._duration = c || .25,
                    this._easeOutPower = 1 / Math.max(p || .5, .2),
                    this._startPos = Kn(t),
                    this._offset = s.subtract(this._startPos),
                    this._startTime = +new Date,
                    this.fire("start"),
                    this._animate()
                },
                stop: function() {
                    this._inProgress && (this._step(!0),
                    this._complete())
                },
                _animate: function() {
                    this._animId = $(this._animate, this),
                    this._step()
                },
                _step: function(t) {
                    var s = +new Date - this._startTime
                      , c = this._duration * 1e3;
                    s < c ? this._runFrame(this._easeOut(s / c), t) : (this._runFrame(1),
                    this._complete())
                },
                _runFrame: function(t, s) {
                    var c = this._startPos.add(this._offset.multiplyBy(t));
                    s && c._round(),
                    yt(this._el, c),
                    this.fire("step")
                },
                _complete: function() {
                    X(this._animId),
                    this._inProgress = !1,
                    this.fire("end")
                },
                _easeOut: function(t) {
                    return 1 - Math.pow(1 - t, this._easeOutPower)
                }
            })
              , Xe = oe.extend({
                options: {
                    crs: q,
                    center: void 0,
                    zoom: void 0,
                    minZoom: void 0,
                    maxZoom: void 0,
                    layers: [],
                    maxBounds: void 0,
                    renderer: void 0,
                    zoomAnimation: !0,
                    zoomAnimationThreshold: 4,
                    fadeAnimation: !0,
                    markerZoomAnimation: !0,
                    transform3DLimit: 8388608,
                    zoomSnap: 1,
                    zoomDelta: 1,
                    trackResize: !0
                },
                initialize: function(t, s) {
                    s = T(this, s),
                    this._handlers = [],
                    this._layers = {},
                    this._zoomBoundLayers = {},
                    this._sizeChanged = !0,
                    this._initContainer(t),
                    this._initLayout(),
                    this._onResize = l(this._onResize, this),
                    this._initEvents(),
                    s.maxBounds && this.setMaxBounds(s.maxBounds),
                    s.zoom !== void 0 && (this._zoom = this._limitZoom(s.zoom)),
                    s.center && s.zoom !== void 0 && this.setView(G(s.center), s.zoom, {
                        reset: !0
                    }),
                    this.callInitHooks(),
                    this._zoomAnimated = Ji && Pe.any3d && !Pe.mobileOpera && this.options.zoomAnimation,
                    this._zoomAnimated && (this._createAnimProxy(),
                    qe(this._proxy, cu, this._catchTransitionEnd, this)),
                    this._addLayers(this.options.layers)
                },
                setView: function(t, s, c) {
                    if (s = s === void 0 ? this._zoom : this._limitZoom(s),
                    t = this._limitCenter(G(t), s, this.options.maxBounds),
                    c = c || {},
                    this._stop(),
                    this._loaded && !c.reset && c !== !0) {
                        c.animate !== void 0 && (c.zoom = o({
                            animate: c.animate
                        }, c.zoom),
                        c.pan = o({
                            animate: c.animate,
                            duration: c.duration
                        }, c.pan));
                        var p = this._zoom !== s ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, s, c.zoom) : this._tryAnimatedPan(t, c.pan);
                        if (p)
                            return clearTimeout(this._sizeTimer),
                            this
                    }
                    return this._resetView(t, s, c.pan && c.pan.noMoveStart),
                    this
                },
                setZoom: function(t, s) {
                    return this._loaded ? this.setView(this.getCenter(), t, {
                        zoom: s
                    }) : (this._zoom = t,
                    this)
                },
                zoomIn: function(t, s) {
                    return t = t || (Pe.any3d ? this.options.zoomDelta : 1),
                    this.setZoom(this._zoom + t, s)
                },
                zoomOut: function(t, s) {
                    return t = t || (Pe.any3d ? this.options.zoomDelta : 1),
                    this.setZoom(this._zoom - t, s)
                },
                setZoomAround: function(t, s, c) {
                    var p = this.getZoomScale(s)
                      , E = this.getSize().divideBy(2)
                      , k = t instanceof j ? t : this.latLngToContainerPoint(t)
                      , ne = k.subtract(E).multiplyBy(1 - 1 / p)
                      , he = this.containerPointToLatLng(E.add(ne));
                    return this.setView(he, s, {
                        zoom: c
                    })
                },
                _getBoundsCenterZoom: function(t, s) {
                    s = s || {},
                    t = t.getBounds ? t.getBounds() : me(t);
                    var c = I(s.paddingTopLeft || s.padding || [0, 0])
                      , p = I(s.paddingBottomRight || s.padding || [0, 0])
                      , E = this.getBoundsZoom(t, !1, c.add(p));
                    if (E = typeof s.maxZoom == "number" ? Math.min(s.maxZoom, E) : E,
                    E === 1 / 0)
                        return {
                            center: t.getCenter(),
                            zoom: E
                        };
                    var k = p.subtract(c).divideBy(2)
                      , ne = this.project(t.getSouthWest(), E)
                      , he = this.project(t.getNorthEast(), E)
                      , ye = this.unproject(ne.add(he).divideBy(2).add(k), E);
                    return {
                        center: ye,
                        zoom: E
                    }
                },
                fitBounds: function(t, s) {
                    if (t = me(t),
                    !t.isValid())
                        throw new Error("Bounds are not valid.");
                    var c = this._getBoundsCenterZoom(t, s);
                    return this.setView(c.center, c.zoom, s)
                },
                fitWorld: function(t) {
                    return this.fitBounds([[-90, -180], [90, 180]], t)
                },
                panTo: function(t, s) {
                    return this.setView(t, this._zoom, {
                        pan: s
                    })
                },
                panBy: function(t, s) {
                    if (t = I(t).round(),
                    s = s || {},
                    !t.x && !t.y)
                        return this.fire("moveend");
                    if (s.animate !== !0 && !this.getSize().contains(t))
                        return this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()),
                        this;
                    if (this._panAnim || (this._panAnim = new _u,
                    this._panAnim.on({
                        step: this._onPanTransitionStep,
                        end: this._onPanTransitionEnd
                    }, this)),
                    s.noMoveStart || this.fire("movestart"),
                    s.animate !== !1) {
                        Ue(this._mapPane, "leaflet-pan-anim");
                        var c = this._getMapPanePos().subtract(t).round();
                        this._panAnim.run(this._mapPane, c, s.duration || .25, s.easeLinearity)
                    } else
                        this._rawPanBy(t),
                        this.fire("move").fire("moveend");
                    return this
                },
                flyTo: function(t, s, c) {
                    if (c = c || {},
                    c.animate === !1 || !Pe.any3d)
                        return this.setView(t, s, c);
                    this._stop();
                    var p = this.project(this.getCenter())
                      , E = this.project(t)
                      , k = this.getSize()
                      , ne = this._zoom;
                    t = G(t),
                    s = s === void 0 ? ne : s;
                    var he = Math.max(k.x, k.y)
                      , ye = he * this.getZoomScale(ne, s)
                      , Le = E.distanceTo(p) || 1
                      , Ce = 1.42
                      , je = Ce * Ce;
                    function Ve(vt) {
                        var ds = vt ? -1 : 1
                          , hg = vt ? ye : he
                          , fg = ye * ye - he * he + ds * je * je * Le * Le
                          , pg = 2 * hg * je * Le
                          , Ro = fg / pg
                          , Ju = Math.sqrt(Ro * Ro + 1) - Ro
                          , gg = Ju < 1e-9 ? -18 : Math.log(Ju);
                        return gg
                    }
                    function At(vt) {
                        return (Math.exp(vt) - Math.exp(-vt)) / 2
                    }
                    function xt(vt) {
                        return (Math.exp(vt) + Math.exp(-vt)) / 2
                    }
                    function Gt(vt) {
                        return At(vt) / xt(vt)
                    }
                    var Mt = Ve(0);
                    function ki(vt) {
                        return he * (xt(Mt) / xt(Mt + Ce * vt))
                    }
                    function lg(vt) {
                        return he * (xt(Mt) * Gt(Mt + Ce * vt) - At(Mt)) / je
                    }
                    function ug(vt) {
                        return 1 - Math.pow(1 - vt, 1.5)
                    }
                    var cg = Date.now()
                      , Xu = (Ve(1) - Mt) / Ce
                      , dg = c.duration ? 1e3 * c.duration : 1e3 * Xu * .8;
                    function Qu() {
                        var vt = (Date.now() - cg) / dg
                          , ds = ug(vt) * Xu;
                        vt <= 1 ? (this._flyToFrame = $(Qu, this),
                        this._move(this.unproject(p.add(E.subtract(p).multiplyBy(lg(ds) / Le)), ne), this.getScaleZoom(he / ki(ds), ne), {
                            flyTo: !0
                        })) : this._move(t, s)._moveEnd(!0)
                    }
                    return this._moveStart(!0, c.noMoveStart),
                    Qu.call(this),
                    this
                },
                flyToBounds: function(t, s) {
                    var c = this._getBoundsCenterZoom(t, s);
                    return this.flyTo(c.center, c.zoom, s)
                },
                setMaxBounds: function(t) {
                    return t = me(t),
                    this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds),
                    t.isValid() ? (this.options.maxBounds = t,
                    this._loaded && this._panInsideMaxBounds(),
                    this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null,
                    this)
                },
                setMinZoom: function(t) {
                    var s = this.options.minZoom;
                    return this.options.minZoom = t,
                    this._loaded && s !== t && (this.fire("zoomlevelschange"),
                    this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this
                },
                setMaxZoom: function(t) {
                    var s = this.options.maxZoom;
                    return this.options.maxZoom = t,
                    this._loaded && s !== t && (this.fire("zoomlevelschange"),
                    this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this
                },
                panInsideBounds: function(t, s) {
                    this._enforcingBounds = !0;
                    var c = this.getCenter()
                      , p = this._limitCenter(c, this._zoom, me(t));
                    return c.equals(p) || this.panTo(p, s),
                    this._enforcingBounds = !1,
                    this
                },
                panInside: function(t, s) {
                    s = s || {};
                    var c = I(s.paddingTopLeft || s.padding || [0, 0])
                      , p = I(s.paddingBottomRight || s.padding || [0, 0])
                      , E = this.project(this.getCenter())
                      , k = this.project(t)
                      , ne = this.getPixelBounds()
                      , he = ie([ne.min.add(c), ne.max.subtract(p)])
                      , ye = he.getSize();
                    if (!he.contains(k)) {
                        this._enforcingBounds = !0;
                        var Le = k.subtract(he.getCenter())
                          , Ce = he.extend(k).getSize().subtract(ye);
                        E.x += Le.x < 0 ? -Ce.x : Ce.x,
                        E.y += Le.y < 0 ? -Ce.y : Ce.y,
                        this.panTo(this.unproject(E), s),
                        this._enforcingBounds = !1
                    }
                    return this
                },
                invalidateSize: function(t) {
                    if (!this._loaded)
                        return this;
                    t = o({
                        animate: !1,
                        pan: !0
                    }, t === !0 ? {
                        animate: !0
                    } : t);
                    var s = this.getSize();
                    this._sizeChanged = !0,
                    this._lastCenter = null;
                    var c = this.getSize()
                      , p = s.divideBy(2).round()
                      , E = c.divideBy(2).round()
                      , k = p.subtract(E);
                    return !k.x && !k.y ? this : (t.animate && t.pan ? this.panBy(k) : (t.pan && this._rawPanBy(k),
                    this.fire("move"),
                    t.debounceMoveend ? (clearTimeout(this._sizeTimer),
                    this._sizeTimer = setTimeout(l(this.fire, this, "moveend"), 200)) : this.fire("moveend")),
                    this.fire("resize", {
                        oldSize: s,
                        newSize: c
                    }))
                },
                stop: function() {
                    return this.setZoom(this._limitZoom(this._zoom)),
                    this.options.zoomSnap || this.fire("viewreset"),
                    this._stop()
                },
                locate: function(t) {
                    if (t = this._locateOptions = o({
                        timeout: 1e4,
                        watch: !1
                    }, t),
                    !("geolocation"in navigator))
                        return this._handleGeolocationError({
                            code: 0,
                            message: "Geolocation not supported."
                        }),
                        this;
                    var s = l(this._handleGeolocationResponse, this)
                      , c = l(this._handleGeolocationError, this);
                    return t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(s, c, t) : navigator.geolocation.getCurrentPosition(s, c, t),
                    this
                },
                stopLocate: function() {
                    return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId),
                    this._locateOptions && (this._locateOptions.setView = !1),
                    this
                },
                _handleGeolocationError: function(t) {
                    if (this._container._leaflet_id) {
                        var s = t.code
                          , c = t.message || (s === 1 ? "permission denied" : s === 2 ? "position unavailable" : "timeout");
                        this._locateOptions.setView && !this._loaded && this.fitWorld(),
                        this.fire("locationerror", {
                            code: s,
                            message: "Geolocation error: " + c + "."
                        })
                    }
                },
                _handleGeolocationResponse: function(t) {
                    if (this._container._leaflet_id) {
                        var s = t.coords.latitude
                          , c = t.coords.longitude
                          , p = new W(s,c)
                          , E = p.toBounds(t.coords.accuracy * 2)
                          , k = this._locateOptions;
                        if (k.setView) {
                            var ne = this.getBoundsZoom(E);
                            this.setView(p, k.maxZoom ? Math.min(ne, k.maxZoom) : ne)
                        }
                        var he = {
                            latlng: p,
                            bounds: E,
                            timestamp: t.timestamp
                        };
                        for (var ye in t.coords)
                            typeof t.coords[ye] == "number" && (he[ye] = t.coords[ye]);
                        this.fire("locationfound", he)
                    }
                },
                addHandler: function(t, s) {
                    if (!s)
                        return this;
                    var c = this[t] = new s(this);
                    return this._handlers.push(c),
                    this.options[t] && c.enable(),
                    this
                },
                remove: function() {
                    if (this._initEvents(!0),
                    this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds),
                    this._containerId !== this._container._leaflet_id)
                        throw new Error("Map container is being reused by another instance");
                    try {
                        delete this._container._leaflet_id,
                        delete this._containerId
                    } catch {
                        this._container._leaflet_id = void 0,
                        this._containerId = void 0
                    }
                    this._locationWatchId !== void 0 && this.stopLocate(),
                    this._stop(),
                    ut(this._mapPane),
                    this._clearControlPos && this._clearControlPos(),
                    this._resizeRequest && (X(this._resizeRequest),
                    this._resizeRequest = null),
                    this._clearHandlers(),
                    this._loaded && this.fire("unload");
                    var t;
                    for (t in this._layers)
                        this._layers[t].remove();
                    for (t in this._panes)
                        ut(this._panes[t]);
                    return this._layers = [],
                    this._panes = [],
                    delete this._mapPane,
                    delete this._renderer,
                    this
                },
                createPane: function(t, s) {
                    var c = "leaflet-pane" + (t ? " leaflet-" + t.replace("Pane", "") + "-pane" : "")
                      , p = Ke("div", c, s || this._mapPane);
                    return t && (this._panes[t] = p),
                    p
                },
                getCenter: function() {
                    return this._checkIfLoaded(),
                    this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint())
                },
                getZoom: function() {
                    return this._zoom
                },
                getBounds: function() {
                    var t = this.getPixelBounds()
                      , s = this.unproject(t.getBottomLeft())
                      , c = this.unproject(t.getTopRight());
                    return new ee(s,c)
                },
                getMinZoom: function() {
                    return this.options.minZoom === void 0 ? this._layersMinZoom || 0 : this.options.minZoom
                },
                getMaxZoom: function() {
                    return this.options.maxZoom === void 0 ? this._layersMaxZoom === void 0 ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom
                },
                getBoundsZoom: function(t, s, c) {
                    t = me(t),
                    c = I(c || [0, 0]);
                    var p = this.getZoom() || 0
                      , E = this.getMinZoom()
                      , k = this.getMaxZoom()
                      , ne = t.getNorthWest()
                      , he = t.getSouthEast()
                      , ye = this.getSize().subtract(c)
                      , Le = ie(this.project(he, p), this.project(ne, p)).getSize()
                      , Ce = Pe.any3d ? this.options.zoomSnap : 1
                      , je = ye.x / Le.x
                      , Ve = ye.y / Le.y
                      , At = s ? Math.max(je, Ve) : Math.min(je, Ve);
                    return p = this.getScaleZoom(At, p),
                    Ce && (p = Math.round(p / (Ce / 100)) * (Ce / 100),
                    p = s ? Math.ceil(p / Ce) * Ce : Math.floor(p / Ce) * Ce),
                    Math.max(E, Math.min(k, p))
                },
                getSize: function() {
                    return (!this._size || this._sizeChanged) && (this._size = new j(this._container.clientWidth || 0,this._container.clientHeight || 0),
                    this._sizeChanged = !1),
                    this._size.clone()
                },
                getPixelBounds: function(t, s) {
                    var c = this._getTopLeftPoint(t, s);
                    return new Z(c,c.add(this.getSize()))
                },
                getPixelOrigin: function() {
                    return this._checkIfLoaded(),
                    this._pixelOrigin
                },
                getPixelWorldBounds: function(t) {
                    return this.options.crs.getProjectedBounds(t === void 0 ? this.getZoom() : t)
                },
                getPane: function(t) {
                    return typeof t == "string" ? this._panes[t] : t
                },
                getPanes: function() {
                    return this._panes
                },
                getContainer: function() {
                    return this._container
                },
                getZoomScale: function(t, s) {
                    var c = this.options.crs;
                    return s = s === void 0 ? this._zoom : s,
                    c.scale(t) / c.scale(s)
                },
                getScaleZoom: function(t, s) {
                    var c = this.options.crs;
                    s = s === void 0 ? this._zoom : s;
                    var p = c.zoom(t * c.scale(s));
                    return isNaN(p) ? 1 / 0 : p
                },
                project: function(t, s) {
                    return s = s === void 0 ? this._zoom : s,
                    this.options.crs.latLngToPoint(G(t), s)
                },
                unproject: function(t, s) {
                    return s = s === void 0 ? this._zoom : s,
                    this.options.crs.pointToLatLng(I(t), s)
                },
                layerPointToLatLng: function(t) {
                    var s = I(t).add(this.getPixelOrigin());
                    return this.unproject(s)
                },
                latLngToLayerPoint: function(t) {
                    var s = this.project(G(t))._round();
                    return s._subtract(this.getPixelOrigin())
                },
                wrapLatLng: function(t) {
                    return this.options.crs.wrapLatLng(G(t))
                },
                wrapLatLngBounds: function(t) {
                    return this.options.crs.wrapLatLngBounds(me(t))
                },
                distance: function(t, s) {
                    return this.options.crs.distance(G(t), G(s))
                },
                containerPointToLayerPoint: function(t) {
                    return I(t).subtract(this._getMapPanePos())
                },
                layerPointToContainerPoint: function(t) {
                    return I(t).add(this._getMapPanePos())
                },
                containerPointToLatLng: function(t) {
                    var s = this.containerPointToLayerPoint(I(t));
                    return this.layerPointToLatLng(s)
                },
                latLngToContainerPoint: function(t) {
                    return this.layerPointToContainerPoint(this.latLngToLayerPoint(G(t)))
                },
                mouseEventToContainerPoint: function(t) {
                    return gu(t, this._container)
                },
                mouseEventToLayerPoint: function(t) {
                    return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))
                },
                mouseEventToLatLng: function(t) {
                    return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))
                },
                _initContainer: function(t) {
                    var s = this._container = du(t);
                    if (s) {
                        if (s._leaflet_id)
                            throw new Error("Map container is already initialized.")
                    } else
                        throw new Error("Map container not found.");
                    qe(s, "scroll", this._onScroll, this),
                    this._containerId = f(s)
                },
                _initLayout: function() {
                    var t = this._container;
                    this._fadeAnimated = this.options.fadeAnimation && Pe.any3d,
                    Ue(t, "leaflet-container" + (Pe.touch ? " leaflet-touch" : "") + (Pe.retina ? " leaflet-retina" : "") + (Pe.ielt9 ? " leaflet-oldie" : "") + (Pe.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : ""));
                    var s = Ki(t, "position");
                    s !== "absolute" && s !== "relative" && s !== "fixed" && s !== "sticky" && (t.style.position = "relative"),
                    this._initPanes(),
                    this._initControlPos && this._initControlPos()
                },
                _initPanes: function() {
                    var t = this._panes = {};
                    this._paneRenderers = {},
                    this._mapPane = this.createPane("mapPane", this._container),
                    yt(this._mapPane, new j(0,0)),
                    this.createPane("tilePane"),
                    this.createPane("overlayPane"),
                    this.createPane("shadowPane"),
                    this.createPane("markerPane"),
                    this.createPane("tooltipPane"),
                    this.createPane("popupPane"),
                    this.options.markerZoomAnimation || (Ue(t.markerPane, "leaflet-zoom-hide"),
                    Ue(t.shadowPane, "leaflet-zoom-hide"))
                },
                _resetView: function(t, s, c) {
                    yt(this._mapPane, new j(0,0));
                    var p = !this._loaded;
                    this._loaded = !0,
                    s = this._limitZoom(s),
                    this.fire("viewprereset");
                    var E = this._zoom !== s;
                    this._moveStart(E, c)._move(t, s)._moveEnd(E),
                    this.fire("viewreset"),
                    p && this.fire("load")
                },
                _moveStart: function(t, s) {
                    return t && this.fire("zoomstart"),
                    s || this.fire("movestart"),
                    this
                },
                _move: function(t, s, c, p) {
                    s === void 0 && (s = this._zoom);
                    var E = this._zoom !== s;
                    return this._zoom = s,
                    this._lastCenter = t,
                    this._pixelOrigin = this._getNewPixelOrigin(t),
                    p ? c && c.pinch && this.fire("zoom", c) : ((E || c && c.pinch) && this.fire("zoom", c),
                    this.fire("move", c)),
                    this
                },
                _moveEnd: function(t) {
                    return t && this.fire("zoomend"),
                    this.fire("moveend")
                },
                _stop: function() {
                    return X(this._flyToFrame),
                    this._panAnim && this._panAnim.stop(),
                    this
                },
                _rawPanBy: function(t) {
                    yt(this._mapPane, this._getMapPanePos().subtract(t))
                },
                _getZoomSpan: function() {
                    return this.getMaxZoom() - this.getMinZoom()
                },
                _panInsideMaxBounds: function() {
                    this._enforcingBounds || this.panInsideBounds(this.options.maxBounds)
                },
                _checkIfLoaded: function() {
                    if (!this._loaded)
                        throw new Error("Set map center and zoom first.")
                },
                _initEvents: function(t) {
                    this._targets = {},
                    this._targets[f(this._container)] = this;
                    var s = t ? rt : qe;
                    s(this._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this),
                    this.options.trackResize && s(window, "resize", this._onResize, this),
                    Pe.any3d && this.options.transform3DLimit && (t ? this.off : this.on).call(this, "moveend", this._onMoveEnd)
                },
                _onResize: function() {
                    X(this._resizeRequest),
                    this._resizeRequest = $(function() {
                        this.invalidateSize({
                            debounceMoveend: !0
                        })
                    }, this)
                },
                _onScroll: function() {
                    this._container.scrollTop = 0,
                    this._container.scrollLeft = 0
                },
                _onMoveEnd: function() {
                    var t = this._getMapPanePos();
                    Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom())
                },
                _findEventTargets: function(t, s) {
                    for (var c = [], p, E = s === "mouseout" || s === "mouseover", k = t.target || t.srcElement, ne = !1; k; ) {
                        if (p = this._targets[f(k)],
                        p && (s === "click" || s === "preclick") && this._draggableMoved(p)) {
                            ne = !0;
                            break
                        }
                        if (p && p.listens(s, !0) && (E && !vo(k, t) || (c.push(p),
                        E)) || k === this._container)
                            break;
                        k = k.parentNode
                    }
                    return !c.length && !ne && !E && this.listens(s, !0) && (c = [this]),
                    c
                },
                _isClickDisabled: function(t) {
                    for (; t && t !== this._container; ) {
                        if (t._leaflet_disable_click)
                            return !0;
                        t = t.parentNode
                    }
                },
                _handleDOMEvent: function(t) {
                    var s = t.target || t.srcElement;
                    if (!(!this._loaded || s._leaflet_disable_events || t.type === "click" && this._isClickDisabled(s))) {
                        var c = t.type;
                        c === "mousedown" && fo(s),
                        this._fireDOMEvent(t, c)
                    }
                },
                _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
                _fireDOMEvent: function(t, s, c) {
                    if (t.type === "click") {
                        var p = o({}, t);
                        p.type = "preclick",
                        this._fireDOMEvent(p, p.type, c)
                    }
                    var E = this._findEventTargets(t, s);
                    if (c) {
                        for (var k = [], ne = 0; ne < c.length; ne++)
                            c[ne].listens(s, !0) && k.push(c[ne]);
                        E = k.concat(E)
                    }
                    if (E.length) {
                        s === "contextmenu" && St(t);
                        var he = E[0]
                          , ye = {
                            originalEvent: t
                        };
                        if (t.type !== "keypress" && t.type !== "keydown" && t.type !== "keyup") {
                            var Le = he.getLatLng && (!he._radius || he._radius <= 10);
                            ye.containerPoint = Le ? this.latLngToContainerPoint(he.getLatLng()) : this.mouseEventToContainerPoint(t),
                            ye.layerPoint = this.containerPointToLayerPoint(ye.containerPoint),
                            ye.latlng = Le ? he.getLatLng() : this.layerPointToLatLng(ye.layerPoint)
                        }
                        for (ne = 0; ne < E.length; ne++)
                            if (E[ne].fire(s, ye, !0),
                            ye.originalEvent._stopped || E[ne].options.bubblingMouseEvents === !1 && y(this._mouseEvents, s) !== -1)
                                return
                    }
                },
                _draggableMoved: function(t) {
                    return t = t.dragging && t.dragging.enabled() ? t : this,
                    t.dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved()
                },
                _clearHandlers: function() {
                    for (var t = 0, s = this._handlers.length; t < s; t++)
                        this._handlers[t].disable()
                },
                whenReady: function(t, s) {
                    return this._loaded ? t.call(s || this, {
                        target: this
                    }) : this.on("load", t, s),
                    this
                },
                _getMapPanePos: function() {
                    return Kn(this._mapPane) || new j(0,0)
                },
                _moved: function() {
                    var t = this._getMapPanePos();
                    return t && !t.equals([0, 0])
                },
                _getTopLeftPoint: function(t, s) {
                    var c = t && s !== void 0 ? this._getNewPixelOrigin(t, s) : this.getPixelOrigin();
                    return c.subtract(this._getMapPanePos())
                },
                _getNewPixelOrigin: function(t, s) {
                    var c = this.getSize()._divideBy(2);
                    return this.project(t, s)._subtract(c)._add(this._getMapPanePos())._round()
                },
                _latLngToNewLayerPoint: function(t, s, c) {
                    var p = this._getNewPixelOrigin(c, s);
                    return this.project(t, s)._subtract(p)
                },
                _latLngBoundsToNewLayerBounds: function(t, s, c) {
                    var p = this._getNewPixelOrigin(c, s);
                    return ie([this.project(t.getSouthWest(), s)._subtract(p), this.project(t.getNorthWest(), s)._subtract(p), this.project(t.getSouthEast(), s)._subtract(p), this.project(t.getNorthEast(), s)._subtract(p)])
                },
                _getCenterLayerPoint: function() {
                    return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
                },
                _getCenterOffset: function(t) {
                    return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())
                },
                _limitCenter: function(t, s, c) {
                    if (!c)
                        return t;
                    var p = this.project(t, s)
                      , E = this.getSize().divideBy(2)
                      , k = new Z(p.subtract(E),p.add(E))
                      , ne = this._getBoundsOffset(k, c, s);
                    return Math.abs(ne.x) <= 1 && Math.abs(ne.y) <= 1 ? t : this.unproject(p.add(ne), s)
                },
                _limitOffset: function(t, s) {
                    if (!s)
                        return t;
                    var c = this.getPixelBounds()
                      , p = new Z(c.min.add(t),c.max.add(t));
                    return t.add(this._getBoundsOffset(p, s))
                },
                _getBoundsOffset: function(t, s, c) {
                    var p = ie(this.project(s.getNorthEast(), c), this.project(s.getSouthWest(), c))
                      , E = p.min.subtract(t.min)
                      , k = p.max.subtract(t.max)
                      , ne = this._rebound(E.x, -k.x)
                      , he = this._rebound(E.y, -k.y);
                    return new j(ne,he)
                },
                _rebound: function(t, s) {
                    return t + s > 0 ? Math.round(t - s) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(s))
                },
                _limitZoom: function(t) {
                    var s = this.getMinZoom()
                      , c = this.getMaxZoom()
                      , p = Pe.any3d ? this.options.zoomSnap : 1;
                    return p && (t = Math.round(t / p) * p),
                    Math.max(s, Math.min(c, t))
                },
                _onPanTransitionStep: function() {
                    this.fire("move")
                },
                _onPanTransitionEnd: function() {
                    pt(this._mapPane, "leaflet-pan-anim"),
                    this.fire("moveend")
                },
                _tryAnimatedPan: function(t, s) {
                    var c = this._getCenterOffset(t)._trunc();
                    return (s && s.animate) !== !0 && !this.getSize().contains(c) ? !1 : (this.panBy(c, s),
                    !0)
                },
                _createAnimProxy: function() {
                    var t = this._proxy = Ke("div", "leaflet-proxy leaflet-zoom-animated");
                    this._panes.mapPane.appendChild(t),
                    this.on("zoomanim", function(s) {
                        var c = so
                          , p = this._proxy.style[c];
                        Jn(this._proxy, this.project(s.center, s.zoom), this.getZoomScale(s.zoom, 1)),
                        p === this._proxy.style[c] && this._animatingZoom && this._onZoomTransitionEnd()
                    }, this),
                    this.on("load moveend", this._animMoveEnd, this),
                    this._on("unload", this._destroyAnimProxy, this)
                },
                _destroyAnimProxy: function() {
                    ut(this._proxy),
                    this.off("load moveend", this._animMoveEnd, this),
                    delete this._proxy
                },
                _animMoveEnd: function() {
                    var t = this.getCenter()
                      , s = this.getZoom();
                    Jn(this._proxy, this.project(t, s), this.getZoomScale(s, 1))
                },
                _catchTransitionEnd: function(t) {
                    this._animatingZoom && t.propertyName.indexOf("transform") >= 0 && this._onZoomTransitionEnd()
                },
                _nothingToAnimate: function() {
                    return !this._container.getElementsByClassName("leaflet-zoom-animated").length
                },
                _tryAnimatedZoom: function(t, s, c) {
                    if (this._animatingZoom)
                        return !0;
                    if (c = c || {},
                    !this._zoomAnimated || c.animate === !1 || this._nothingToAnimate() || Math.abs(s - this._zoom) > this.options.zoomAnimationThreshold)
                        return !1;
                    var p = this.getZoomScale(s)
                      , E = this._getCenterOffset(t)._divideBy(1 - 1 / p);
                    return c.animate !== !0 && !this.getSize().contains(E) ? !1 : ($(function() {
                        this._moveStart(!0, c.noMoveStart || !1)._animateZoom(t, s, !0)
                    }, this),
                    !0)
                },
                _animateZoom: function(t, s, c, p) {
                    this._mapPane && (c && (this._animatingZoom = !0,
                    this._animateToCenter = t,
                    this._animateToZoom = s,
                    Ue(this._mapPane, "leaflet-zoom-anim")),
                    this.fire("zoomanim", {
                        center: t,
                        zoom: s,
                        noUpdate: p
                    }),
                    this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom),
                    this._move(this._animateToCenter, this._animateToZoom, void 0, !0),
                    setTimeout(l(this._onZoomTransitionEnd, this), 250))
                },
                _onZoomTransitionEnd: function() {
                    this._animatingZoom && (this._mapPane && pt(this._mapPane, "leaflet-zoom-anim"),
                    this._animatingZoom = !1,
                    this._move(this._animateToCenter, this._animateToZoom, void 0, !0),
                    this._tempFireZoomEvent && this.fire("zoom"),
                    delete this._tempFireZoomEvent,
                    this.fire("move"),
                    this._moveEnd(!0))
                }
            });
            function Tp(t, s) {
                return new Xe(t,s)
            }
            var tn = B.extend({
                options: {
                    position: "topright"
                },
                initialize: function(t) {
                    T(this, t)
                },
                getPosition: function() {
                    return this.options.position
                },
                setPosition: function(t) {
                    var s = this._map;
                    return s && s.removeControl(this),
                    this.options.position = t,
                    s && s.addControl(this),
                    this
                },
                getContainer: function() {
                    return this._container
                },
                addTo: function(t) {
                    this.remove(),
                    this._map = t;
                    var s = this._container = this.onAdd(t)
                      , c = this.getPosition()
                      , p = t._controlCorners[c];
                    return Ue(s, "leaflet-control"),
                    c.indexOf("bottom") !== -1 ? p.insertBefore(s, p.firstChild) : p.appendChild(s),
                    this._map.on("unload", this.remove, this),
                    this
                },
                remove: function() {
                    return this._map ? (ut(this._container),
                    this.onRemove && this.onRemove(this._map),
                    this._map.off("unload", this.remove, this),
                    this._map = null,
                    this) : this
                },
                _refocusOnMap: function(t) {
                    this._map && t && t.screenX > 0 && t.screenY > 0 && this._map.getContainer().focus()
                }
            })
              , ir = function(t) {
                return new tn(t)
            };
            Xe.include({
                addControl: function(t) {
                    return t.addTo(this),
                    this
                },
                removeControl: function(t) {
                    return t.remove(),
                    this
                },
                _initControlPos: function() {
                    var t = this._controlCorners = {}
                      , s = "leaflet-"
                      , c = this._controlContainer = Ke("div", s + "control-container", this._container);
                    function p(E, k) {
                        var ne = s + E + " " + s + k;
                        t[E + k] = Ke("div", ne, c)
                    }
                    p("top", "left"),
                    p("top", "right"),
                    p("bottom", "left"),
                    p("bottom", "right")
                },
                _clearControlPos: function() {
                    for (var t in this._controlCorners)
                        ut(this._controlCorners[t]);
                    ut(this._controlContainer),
                    delete this._controlCorners,
                    delete this._controlContainer
                }
            });
            var yu = tn.extend({
                options: {
                    collapsed: !0,
                    position: "topright",
                    autoZIndex: !0,
                    hideSingleBase: !1,
                    sortLayers: !1,
                    sortFunction: function(t, s, c, p) {
                        return c < p ? -1 : p < c ? 1 : 0
                    }
                },
                initialize: function(t, s, c) {
                    T(this, c),
                    this._layerControlInputs = [],
                    this._layers = [],
                    this._lastZIndex = 0,
                    this._handlingClick = !1,
                    this._preventClick = !1;
                    for (var p in t)
                        this._addLayer(t[p], p);
                    for (p in s)
                        this._addLayer(s[p], p, !0)
                },
                onAdd: function(t) {
                    this._initLayout(),
                    this._update(),
                    this._map = t,
                    t.on("zoomend", this._checkDisabledLayers, this);
                    for (var s = 0; s < this._layers.length; s++)
                        this._layers[s].layer.on("add remove", this._onLayerChange, this);
                    return this._container
                },
                addTo: function(t) {
                    return tn.prototype.addTo.call(this, t),
                    this._expandIfNotCollapsed()
                },
                onRemove: function() {
                    this._map.off("zoomend", this._checkDisabledLayers, this);
                    for (var t = 0; t < this._layers.length; t++)
                        this._layers[t].layer.off("add remove", this._onLayerChange, this)
                },
                addBaseLayer: function(t, s) {
                    return this._addLayer(t, s),
                    this._map ? this._update() : this
                },
                addOverlay: function(t, s) {
                    return this._addLayer(t, s, !0),
                    this._map ? this._update() : this
                },
                removeLayer: function(t) {
                    t.off("add remove", this._onLayerChange, this);
                    var s = this._getLayer(f(t));
                    return s && this._layers.splice(this._layers.indexOf(s), 1),
                    this._map ? this._update() : this
                },
                expand: function() {
                    Ue(this._container, "leaflet-control-layers-expanded"),
                    this._section.style.height = null;
                    var t = this._map.getSize().y - (this._container.offsetTop + 50);
                    return t < this._section.clientHeight ? (Ue(this._section, "leaflet-control-layers-scrollbar"),
                    this._section.style.height = t + "px") : pt(this._section, "leaflet-control-layers-scrollbar"),
                    this._checkDisabledLayers(),
                    this
                },
                collapse: function() {
                    return pt(this._container, "leaflet-control-layers-expanded"),
                    this
                },
                _initLayout: function() {
                    var t = "leaflet-control-layers"
                      , s = this._container = Ke("div", t)
                      , c = this.options.collapsed;
                    s.setAttribute("aria-haspopup", !0),
                    nr(s),
                    yo(s);
                    var p = this._section = Ke("section", t + "-list");
                    c && (this._map.on("click", this.collapse, this),
                    qe(s, {
                        mouseenter: this._expandSafely,
                        mouseleave: this.collapse
                    }, this));
                    var E = this._layersLink = Ke("a", t + "-toggle", s);
                    E.href = "#",
                    E.title = "Layers",
                    E.setAttribute("role", "button"),
                    qe(E, {
                        keydown: function(k) {
                            k.keyCode === 13 && this._expandSafely()
                        },
                        click: function(k) {
                            St(k),
                            this._expandSafely()
                        }
                    }, this),
                    c || this.expand(),
                    this._baseLayersList = Ke("div", t + "-base", p),
                    this._separator = Ke("div", t + "-separator", p),
                    this._overlaysList = Ke("div", t + "-overlays", p),
                    s.appendChild(p)
                },
                _getLayer: function(t) {
                    for (var s = 0; s < this._layers.length; s++)
                        if (this._layers[s] && f(this._layers[s].layer) === t)
                            return this._layers[s]
                },
                _addLayer: function(t, s, c) {
                    this._map && t.on("add remove", this._onLayerChange, this),
                    this._layers.push({
                        layer: t,
                        name: s,
                        overlay: c
                    }),
                    this.options.sortLayers && this._layers.sort(l(function(p, E) {
                        return this.options.sortFunction(p.layer, E.layer, p.name, E.name)
                    }, this)),
                    this.options.autoZIndex && t.setZIndex && (this._lastZIndex++,
                    t.setZIndex(this._lastZIndex)),
                    this._expandIfNotCollapsed()
                },
                _update: function() {
                    if (!this._container)
                        return this;
                    Xr(this._baseLayersList),
                    Xr(this._overlaysList),
                    this._layerControlInputs = [];
                    var t, s, c, p, E = 0;
                    for (c = 0; c < this._layers.length; c++)
                        p = this._layers[c],
                        this._addItem(p),
                        s = s || p.overlay,
                        t = t || !p.overlay,
                        E += p.overlay ? 0 : 1;
                    return this.options.hideSingleBase && (t = t && E > 1,
                    this._baseLayersList.style.display = t ? "" : "none"),
                    this._separator.style.display = s && t ? "" : "none",
                    this
                },
                _onLayerChange: function(t) {
                    this._handlingClick || this._update();
                    var s = this._getLayer(f(t.target))
                      , c = s.overlay ? t.type === "add" ? "overlayadd" : "overlayremove" : t.type === "add" ? "baselayerchange" : null;
                    c && this._map.fire(c, s)
                },
                _createRadioElement: function(t, s) {
                    var c = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"' + (s ? ' checked="checked"' : "") + "/>"
                      , p = document.createElement("div");
                    return p.innerHTML = c,
                    p.firstChild
                },
                _addItem: function(t) {
                    var s = document.createElement("label"), c = this._map.hasLayer(t.layer), p;
                    t.overlay ? (p = document.createElement("input"),
                    p.type = "checkbox",
                    p.className = "leaflet-control-layers-selector",
                    p.defaultChecked = c) : p = this._createRadioElement("leaflet-base-layers_" + f(this), c),
                    this._layerControlInputs.push(p),
                    p.layerId = f(t.layer),
                    qe(p, "click", this._onInputClick, this);
                    var E = document.createElement("span");
                    E.innerHTML = " " + t.name;
                    var k = document.createElement("span");
                    s.appendChild(k),
                    k.appendChild(p),
                    k.appendChild(E);
                    var ne = t.overlay ? this._overlaysList : this._baseLayersList;
                    return ne.appendChild(s),
                    this._checkDisabledLayers(),
                    s
                },
                _onInputClick: function() {
                    if (!this._preventClick) {
                        var t = this._layerControlInputs, s, c, p = [], E = [];
                        this._handlingClick = !0;
                        for (var k = t.length - 1; k >= 0; k--)
                            s = t[k],
                            c = this._getLayer(s.layerId).layer,
                            s.checked ? p.push(c) : s.checked || E.push(c);
                        for (k = 0; k < E.length; k++)
                            this._map.hasLayer(E[k]) && this._map.removeLayer(E[k]);
                        for (k = 0; k < p.length; k++)
                            this._map.hasLayer(p[k]) || this._map.addLayer(p[k]);
                        this._handlingClick = !1,
                        this._refocusOnMap()
                    }
                },
                _checkDisabledLayers: function() {
                    for (var t = this._layerControlInputs, s, c, p = this._map.getZoom(), E = t.length - 1; E >= 0; E--)
                        s = t[E],
                        c = this._getLayer(s.layerId).layer,
                        s.disabled = c.options.minZoom !== void 0 && p < c.options.minZoom || c.options.maxZoom !== void 0 && p > c.options.maxZoom
                },
                _expandIfNotCollapsed: function() {
                    return this._map && !this.options.collapsed && this.expand(),
                    this
                },
                _expandSafely: function() {
                    var t = this._section;
                    this._preventClick = !0,
                    qe(t, "click", St),
                    this.expand();
                    var s = this;
                    setTimeout(function() {
                        rt(t, "click", St),
                        s._preventClick = !1
                    })
                }
            })
              , Lp = function(t, s, c) {
                return new yu(t,s,c)
            }
              , bo = tn.extend({
                options: {
                    position: "topleft",
                    zoomInText: '<span aria-hidden="true">+</span>',
                    zoomInTitle: "Zoom in",
                    zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
                    zoomOutTitle: "Zoom out"
                },
                onAdd: function(t) {
                    var s = "leaflet-control-zoom"
                      , c = Ke("div", s + " leaflet-bar")
                      , p = this.options;
                    return this._zoomInButton = this._createButton(p.zoomInText, p.zoomInTitle, s + "-in", c, this._zoomIn),
                    this._zoomOutButton = this._createButton(p.zoomOutText, p.zoomOutTitle, s + "-out", c, this._zoomOut),
                    this._updateDisabled(),
                    t.on("zoomend zoomlevelschange", this._updateDisabled, this),
                    c
                },
                onRemove: function(t) {
                    t.off("zoomend zoomlevelschange", this._updateDisabled, this)
                },
                disable: function() {
                    return this._disabled = !0,
                    this._updateDisabled(),
                    this
                },
                enable: function() {
                    return this._disabled = !1,
                    this._updateDisabled(),
                    this
                },
                _zoomIn: function(t) {
                    !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1))
                },
                _zoomOut: function(t) {
                    !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1))
                },
                _createButton: function(t, s, c, p, E) {
                    var k = Ke("a", c, p);
                    return k.innerHTML = t,
                    k.href = "#",
                    k.title = s,
                    k.setAttribute("role", "button"),
                    k.setAttribute("aria-label", s),
                    nr(k),
                    qe(k, "click", ei),
                    qe(k, "click", E, this),
                    qe(k, "click", this._refocusOnMap, this),
                    k
                },
                _updateDisabled: function() {
                    var t = this._map
                      , s = "leaflet-disabled";
                    pt(this._zoomInButton, s),
                    pt(this._zoomOutButton, s),
                    this._zoomInButton.setAttribute("aria-disabled", "false"),
                    this._zoomOutButton.setAttribute("aria-disabled", "false"),
                    (this._disabled || t._zoom === t.getMinZoom()) && (Ue(this._zoomOutButton, s),
                    this._zoomOutButton.setAttribute("aria-disabled", "true")),
                    (this._disabled || t._zoom === t.getMaxZoom()) && (Ue(this._zoomInButton, s),
                    this._zoomInButton.setAttribute("aria-disabled", "true"))
                }
            });
            Xe.mergeOptions({
                zoomControl: !0
            }),
            Xe.addInitHook(function() {
                this.options.zoomControl && (this.zoomControl = new bo,
                this.addControl(this.zoomControl))
            });
            var Ip = function(t) {
                return new bo(t)
            }
              , vu = tn.extend({
                options: {
                    position: "bottomleft",
                    maxWidth: 100,
                    metric: !0,
                    imperial: !0
                },
                onAdd: function(t) {
                    var s = "leaflet-control-scale"
                      , c = Ke("div", s)
                      , p = this.options;
                    return this._addScales(p, s + "-line", c),
                    t.on(p.updateWhenIdle ? "moveend" : "move", this._update, this),
                    t.whenReady(this._update, this),
                    c
                },
                onRemove: function(t) {
                    t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
                },
                _addScales: function(t, s, c) {
                    t.metric && (this._mScale = Ke("div", s, c)),
                    t.imperial && (this._iScale = Ke("div", s, c))
                },
                _update: function() {
                    var t = this._map
                      , s = t.getSize().y / 2
                      , c = t.distance(t.containerPointToLatLng([0, s]), t.containerPointToLatLng([this.options.maxWidth, s]));
                    this._updateScales(c)
                },
                _updateScales: function(t) {
                    this.options.metric && t && this._updateMetric(t),
                    this.options.imperial && t && this._updateImperial(t)
                },
                _updateMetric: function(t) {
                    var s = this._getRoundNum(t)
                      , c = s < 1e3 ? s + " m" : s / 1e3 + " km";
                    this._updateScale(this._mScale, c, s / t)
                },
                _updateImperial: function(t) {
                    var s = t * 3.2808399, c, p, E;
                    s > 5280 ? (c = s / 5280,
                    p = this._getRoundNum(c),
                    this._updateScale(this._iScale, p + " mi", p / c)) : (E = this._getRoundNum(s),
                    this._updateScale(this._iScale, E + " ft", E / s))
                },
                _updateScale: function(t, s, c) {
                    t.style.width = Math.round(this.options.maxWidth * c) + "px",
                    t.innerHTML = s
                },
                _getRoundNum: function(t) {
                    var s = Math.pow(10, (Math.floor(t) + "").length - 1)
                      , c = t / s;
                    return c = c >= 10 ? 10 : c >= 5 ? 5 : c >= 3 ? 3 : c >= 2 ? 2 : 1,
                    s * c
                }
            })
              , Np = function(t) {
                return new vu(t)
            }
              , Ap = '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg>'
              , wo = tn.extend({
                options: {
                    position: "bottomright",
                    prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (Pe.inlineSvg ? Ap + " " : "") + "Leaflet</a>"
                },
                initialize: function(t) {
                    T(this, t),
                    this._attributions = {}
                },
                onAdd: function(t) {
                    t.attributionControl = this,
                    this._container = Ke("div", "leaflet-control-attribution"),
                    nr(this._container);
                    for (var s in t._layers)
                        t._layers[s].getAttribution && this.addAttribution(t._layers[s].getAttribution());
                    return this._update(),
                    t.on("layeradd", this._addAttribution, this),
                    this._container
                },
                onRemove: function(t) {
                    t.off("layeradd", this._addAttribution, this)
                },
                _addAttribution: function(t) {
                    t.layer.getAttribution && (this.addAttribution(t.layer.getAttribution()),
                    t.layer.once("remove", function() {
                        this.removeAttribution(t.layer.getAttribution())
                    }, this))
                },
                setPrefix: function(t) {
                    return this.options.prefix = t,
                    this._update(),
                    this
                },
                addAttribution: function(t) {
                    return t ? (this._attributions[t] || (this._attributions[t] = 0),
                    this._attributions[t]++,
                    this._update(),
                    this) : this
                },
                removeAttribution: function(t) {
                    return t ? (this._attributions[t] && (this._attributions[t]--,
                    this._update()),
                    this) : this
                },
                _update: function() {
                    if (this._map) {
                        var t = [];
                        for (var s in this._attributions)
                            this._attributions[s] && t.push(s);
                        var c = [];
                        this.options.prefix && c.push(this.options.prefix),
                        t.length && c.push(t.join(", ")),
                        this._container.innerHTML = c.join(' <span aria-hidden="true">|</span> ')
                    }
                }
            });
            Xe.mergeOptions({
                attributionControl: !0
            }),
            Xe.addInitHook(function() {
                this.options.attributionControl && new wo().addTo(this)
            });
            var Rp = function(t) {
                return new wo(t)
            };
            tn.Layers = yu,
            tn.Zoom = bo,
            tn.Scale = vu,
            tn.Attribution = wo,
            ir.layers = Lp,
            ir.zoom = Ip,
            ir.scale = Np,
            ir.attribution = Rp;
            var fn = B.extend({
                initialize: function(t) {
                    this._map = t
                },
                enable: function() {
                    return this._enabled ? this : (this._enabled = !0,
                    this.addHooks(),
                    this)
                },
                disable: function() {
                    return this._enabled ? (this._enabled = !1,
                    this.removeHooks(),
                    this) : this
                },
                enabled: function() {
                    return !!this._enabled
                }
            });
            fn.addTo = function(t, s) {
                return t.addHandler(s, this),
                this
            }
            ;
            var Cp = {
                Events: P
            }
              , bu = Pe.touch ? "touchstart mousedown" : "mousedown"
              , Fn = oe.extend({
                options: {
                    clickTolerance: 3
                },
                initialize: function(t, s, c, p) {
                    T(this, p),
                    this._element = t,
                    this._dragStartTarget = s || t,
                    this._preventOutline = c
                },
                enable: function() {
                    this._enabled || (qe(this._dragStartTarget, bu, this._onDown, this),
                    this._enabled = !0)
                },
                disable: function() {
                    this._enabled && (Fn._dragging === this && this.finishDrag(!0),
                    rt(this._dragStartTarget, bu, this._onDown, this),
                    this._enabled = !1,
                    this._moved = !1)
                },
                _onDown: function(t) {
                    if (this._enabled && (this._moved = !1,
                    !oo(this._element, "leaflet-zoom-anim"))) {
                        if (t.touches && t.touches.length !== 1) {
                            Fn._dragging === this && this.finishDrag();
                            return
                        }
                        if (!(Fn._dragging || t.shiftKey || t.which !== 1 && t.button !== 1 && !t.touches) && (Fn._dragging = this,
                        this._preventOutline && fo(this._element),
                        uo(),
                        Yi(),
                        !this._moving)) {
                            this.fire("down");
                            var s = t.touches ? t.touches[0] : t
                              , c = hu(this._element);
                            this._startPoint = new j(s.clientX,s.clientY),
                            this._startPos = Kn(this._element),
                            this._parentScale = po(c);
                            var p = t.type === "mousedown";
                            qe(document, p ? "mousemove" : "touchmove", this._onMove, this),
                            qe(document, p ? "mouseup" : "touchend touchcancel", this._onUp, this)
                        }
                    }
                },
                _onMove: function(t) {
                    if (this._enabled) {
                        if (t.touches && t.touches.length > 1) {
                            this._moved = !0;
                            return
                        }
                        var s = t.touches && t.touches.length === 1 ? t.touches[0] : t
                          , c = new j(s.clientX,s.clientY)._subtract(this._startPoint);
                        !c.x && !c.y || Math.abs(c.x) + Math.abs(c.y) < this.options.clickTolerance || (c.x /= this._parentScale.x,
                        c.y /= this._parentScale.y,
                        St(t),
                        this._moved || (this.fire("dragstart"),
                        this._moved = !0,
                        Ue(document.body, "leaflet-dragging"),
                        this._lastTarget = t.target || t.srcElement,
                        window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement),
                        Ue(this._lastTarget, "leaflet-drag-target")),
                        this._newPos = this._startPos.add(c),
                        this._moving = !0,
                        this._lastEvent = t,
                        this._updatePosition())
                    }
                },
                _updatePosition: function() {
                    var t = {
                        originalEvent: this._lastEvent
                    };
                    this.fire("predrag", t),
                    yt(this._element, this._newPos),
                    this.fire("drag", t)
                },
                _onUp: function() {
                    this._enabled && this.finishDrag()
                },
                finishDrag: function(t) {
                    pt(document.body, "leaflet-dragging"),
                    this._lastTarget && (pt(this._lastTarget, "leaflet-drag-target"),
                    this._lastTarget = null),
                    rt(document, "mousemove touchmove", this._onMove, this),
                    rt(document, "mouseup touchend touchcancel", this._onUp, this),
                    co(),
                    er();
                    var s = this._moved && this._moving;
                    this._moving = !1,
                    Fn._dragging = !1,
                    s && this.fire("dragend", {
                        noInertia: t,
                        distance: this._newPos.distanceTo(this._startPos)
                    })
                }
            });
            function wu(t, s, c) {
                var p, E = [1, 4, 2, 8], k, ne, he, ye, Le, Ce, je, Ve;
                for (k = 0,
                Ce = t.length; k < Ce; k++)
                    t[k]._code = ti(t[k], s);
                for (he = 0; he < 4; he++) {
                    for (je = E[he],
                    p = [],
                    k = 0,
                    Ce = t.length,
                    ne = Ce - 1; k < Ce; ne = k++)
                        ye = t[k],
                        Le = t[ne],
                        ye._code & je ? Le._code & je || (Ve = es(Le, ye, je, s, c),
                        Ve._code = ti(Ve, s),
                        p.push(Ve)) : (Le._code & je && (Ve = es(Le, ye, je, s, c),
                        Ve._code = ti(Ve, s),
                        p.push(Ve)),
                        p.push(ye));
                    t = p
                }
                return t
            }
            function xu(t, s) {
                var c, p, E, k, ne, he, ye, Le, Ce;
                if (!t || t.length === 0)
                    throw new Error("latlngs not passed");
                Vt(t) || (console.warn("latlngs are not flat! Only the first ring will be used"),
                t = t[0]);
                var je = G([0, 0])
                  , Ve = me(t)
                  , At = Ve.getNorthWest().distanceTo(Ve.getSouthWest()) * Ve.getNorthEast().distanceTo(Ve.getNorthWest());
                At < 1700 && (je = xo(t));
                var xt = t.length
                  , Gt = [];
                for (c = 0; c < xt; c++) {
                    var Mt = G(t[c]);
                    Gt.push(s.project(G([Mt.lat - je.lat, Mt.lng - je.lng])))
                }
                for (he = ye = Le = 0,
                c = 0,
                p = xt - 1; c < xt; p = c++)
                    E = Gt[c],
                    k = Gt[p],
                    ne = E.y * k.x - k.y * E.x,
                    ye += (E.x + k.x) * ne,
                    Le += (E.y + k.y) * ne,
                    he += ne * 3;
                he === 0 ? Ce = Gt[0] : Ce = [ye / he, Le / he];
                var ki = s.unproject(I(Ce));
                return G([ki.lat + je.lat, ki.lng + je.lng])
            }
            function xo(t) {
                for (var s = 0, c = 0, p = 0, E = 0; E < t.length; E++) {
                    var k = G(t[E]);
                    s += k.lat,
                    c += k.lng,
                    p++
                }
                return G([s / p, c / p])
            }
            var kp = {
                __proto__: null,
                clipPolygon: wu,
                polygonCenter: xu,
                centroid: xo
            };
            function Eu(t, s) {
                if (!s || !t.length)
                    return t.slice();
                var c = s * s;
                return t = Dp(t, c),
                t = Mp(t, c),
                t
            }
            function Su(t, s, c) {
                return Math.sqrt(rr(t, s, c, !0))
            }
            function Pp(t, s, c) {
                return rr(t, s, c)
            }
            function Mp(t, s) {
                var c = t.length
                  , p = typeof Uint8Array < "u" ? Uint8Array : Array
                  , E = new p(c);
                E[0] = E[c - 1] = 1,
                Eo(t, E, s, 0, c - 1);
                var k, ne = [];
                for (k = 0; k < c; k++)
                    E[k] && ne.push(t[k]);
                return ne
            }
            function Eo(t, s, c, p, E) {
                var k = 0, ne, he, ye;
                for (he = p + 1; he <= E - 1; he++)
                    ye = rr(t[he], t[p], t[E], !0),
                    ye > k && (ne = he,
                    k = ye);
                k > c && (s[ne] = 1,
                Eo(t, s, c, p, ne),
                Eo(t, s, c, ne, E))
            }
            function Dp(t, s) {
                for (var c = [t[0]], p = 1, E = 0, k = t.length; p < k; p++)
                    Op(t[p], t[E]) > s && (c.push(t[p]),
                    E = p);
                return E < k - 1 && c.push(t[k - 1]),
                c
            }
            var Tu;
            function Lu(t, s, c, p, E) {
                var k = p ? Tu : ti(t, c), ne = ti(s, c), he, ye, Le;
                for (Tu = ne; ; ) {
                    if (!(k | ne))
                        return [t, s];
                    if (k & ne)
                        return !1;
                    he = k || ne,
                    ye = es(t, s, he, c, E),
                    Le = ti(ye, c),
                    he === k ? (t = ye,
                    k = Le) : (s = ye,
                    ne = Le)
                }
            }
            function es(t, s, c, p, E) {
                var k = s.x - t.x, ne = s.y - t.y, he = p.min, ye = p.max, Le, Ce;
                return c & 8 ? (Le = t.x + k * (ye.y - t.y) / ne,
                Ce = ye.y) : c & 4 ? (Le = t.x + k * (he.y - t.y) / ne,
                Ce = he.y) : c & 2 ? (Le = ye.x,
                Ce = t.y + ne * (ye.x - t.x) / k) : c & 1 && (Le = he.x,
                Ce = t.y + ne * (he.x - t.x) / k),
                new j(Le,Ce,E)
            }
            function ti(t, s) {
                var c = 0;
                return t.x < s.min.x ? c |= 1 : t.x > s.max.x && (c |= 2),
                t.y < s.min.y ? c |= 4 : t.y > s.max.y && (c |= 8),
                c
            }
            function Op(t, s) {
                var c = s.x - t.x
                  , p = s.y - t.y;
                return c * c + p * p
            }
            function rr(t, s, c, p) {
                var E = s.x, k = s.y, ne = c.x - E, he = c.y - k, ye = ne * ne + he * he, Le;
                return ye > 0 && (Le = ((t.x - E) * ne + (t.y - k) * he) / ye,
                Le > 1 ? (E = c.x,
                k = c.y) : Le > 0 && (E += ne * Le,
                k += he * Le)),
                ne = t.x - E,
                he = t.y - k,
                p ? ne * ne + he * he : new j(E,k)
            }
            function Vt(t) {
                return !S(t[0]) || typeof t[0][0] != "object" && typeof t[0][0] < "u"
            }
            function Iu(t) {
                return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."),
                Vt(t)
            }
            function Nu(t, s) {
                var c, p, E, k, ne, he, ye, Le;
                if (!t || t.length === 0)
                    throw new Error("latlngs not passed");
                Vt(t) || (console.warn("latlngs are not flat! Only the first ring will be used"),
                t = t[0]);
                var Ce = G([0, 0])
                  , je = me(t)
                  , Ve = je.getNorthWest().distanceTo(je.getSouthWest()) * je.getNorthEast().distanceTo(je.getNorthWest());
                Ve < 1700 && (Ce = xo(t));
                var At = t.length
                  , xt = [];
                for (c = 0; c < At; c++) {
                    var Gt = G(t[c]);
                    xt.push(s.project(G([Gt.lat - Ce.lat, Gt.lng - Ce.lng])))
                }
                for (c = 0,
                p = 0; c < At - 1; c++)
                    p += xt[c].distanceTo(xt[c + 1]) / 2;
                if (p === 0)
                    Le = xt[0];
                else
                    for (c = 0,
                    k = 0; c < At - 1; c++)
                        if (ne = xt[c],
                        he = xt[c + 1],
                        E = ne.distanceTo(he),
                        k += E,
                        k > p) {
                            ye = (k - p) / E,
                            Le = [he.x - ye * (he.x - ne.x), he.y - ye * (he.y - ne.y)];
                            break
                        }
                var Mt = s.unproject(I(Le));
                return G([Mt.lat + Ce.lat, Mt.lng + Ce.lng])
            }
            var Fp = {
                __proto__: null,
                simplify: Eu,
                pointToSegmentDistance: Su,
                closestPointOnSegment: Pp,
                clipSegment: Lu,
                _getEdgeIntersection: es,
                _getBitCode: ti,
                _sqClosestPointOnSegment: rr,
                isFlat: Vt,
                _flat: Iu,
                polylineCenter: Nu
            }
              , So = {
                project: function(t) {
                    return new j(t.lng,t.lat)
                },
                unproject: function(t) {
                    return new W(t.y,t.x)
                },
                bounds: new Z([-180, -90],[180, 90])
            }
              , To = {
                R: 6378137,
                R_MINOR: 6356752314245179e-9,
                bounds: new Z([-2003750834279e-5, -1549657073972e-5],[2003750834279e-5, 1876465623138e-5]),
                project: function(t) {
                    var s = Math.PI / 180
                      , c = this.R
                      , p = t.lat * s
                      , E = this.R_MINOR / c
                      , k = Math.sqrt(1 - E * E)
                      , ne = k * Math.sin(p)
                      , he = Math.tan(Math.PI / 4 - p / 2) / Math.pow((1 - ne) / (1 + ne), k / 2);
                    return p = -c * Math.log(Math.max(he, 1e-10)),
                    new j(t.lng * s * c,p)
                },
                unproject: function(t) {
                    for (var s = 180 / Math.PI, c = this.R, p = this.R_MINOR / c, E = Math.sqrt(1 - p * p), k = Math.exp(-t.y / c), ne = Math.PI / 2 - 2 * Math.atan(k), he = 0, ye = .1, Le; he < 15 && Math.abs(ye) > 1e-7; he++)
                        Le = E * Math.sin(ne),
                        Le = Math.pow((1 - Le) / (1 + Le), E / 2),
                        ye = Math.PI / 2 - 2 * Math.atan(k * Le) - ne,
                        ne += ye;
                    return new W(ne * s,t.x * s / c)
                }
            }
              , jp = {
                __proto__: null,
                LonLat: So,
                Mercator: To,
                SphericalMercator: ce
            }
              , Bp = o({}, K, {
                code: "EPSG:3395",
                projection: To,
                transformation: (function() {
                    var t = .5 / (Math.PI * To.R);
                    return Te(t, .5, -t, .5)
                }
                )()
            })
              , Au = o({}, K, {
                code: "EPSG:4326",
                projection: So,
                transformation: Te(1 / 180, 1, -1 / 180, .5)
            })
              , $p = o({}, Y, {
                projection: So,
                transformation: Te(1, 0, -1, 0),
                scale: function(t) {
                    return Math.pow(2, t)
                },
                zoom: function(t) {
                    return Math.log(t) / Math.LN2
                },
                distance: function(t, s) {
                    var c = s.lng - t.lng
                      , p = s.lat - t.lat;
                    return Math.sqrt(c * c + p * p)
                },
                infinite: !0
            });
            Y.Earth = K,
            Y.EPSG3395 = Bp,
            Y.EPSG3857 = q,
            Y.EPSG900913 = te,
            Y.EPSG4326 = Au,
            Y.Simple = $p;
            var nn = oe.extend({
                options: {
                    pane: "overlayPane",
                    attribution: null,
                    bubblingMouseEvents: !0
                },
                addTo: function(t) {
                    return t.addLayer(this),
                    this
                },
                remove: function() {
                    return this.removeFrom(this._map || this._mapToAdd)
                },
                removeFrom: function(t) {
                    return t && t.removeLayer(this),
                    this
                },
                getPane: function(t) {
                    return this._map.getPane(t ? this.options[t] || t : this.options.pane)
                },
                addInteractiveTarget: function(t) {
                    return this._map._targets[f(t)] = this,
                    this
                },
                removeInteractiveTarget: function(t) {
                    return delete this._map._targets[f(t)],
                    this
                },
                getAttribution: function() {
                    return this.options.attribution
                },
                _layerAdd: function(t) {
                    var s = t.target;
                    if (s.hasLayer(this)) {
                        if (this._map = s,
                        this._zoomAnimated = s._zoomAnimated,
                        this.getEvents) {
                            var c = this.getEvents();
                            s.on(c, this),
                            this.once("remove", function() {
                                s.off(c, this)
                            }, this)
                        }
                        this.onAdd(s),
                        this.fire("add"),
                        s.fire("layeradd", {
                            layer: this
                        })
                    }
                }
            });
            Xe.include({
                addLayer: function(t) {
                    if (!t._layerAdd)
                        throw new Error("The provided object is not a Layer.");
                    var s = f(t);
                    return this._layers[s] ? this : (this._layers[s] = t,
                    t._mapToAdd = this,
                    t.beforeAdd && t.beforeAdd(this),
                    this.whenReady(t._layerAdd, t),
                    this)
                },
                removeLayer: function(t) {
                    var s = f(t);
                    return this._layers[s] ? (this._loaded && t.onRemove(this),
                    delete this._layers[s],
                    this._loaded && (this.fire("layerremove", {
                        layer: t
                    }),
                    t.fire("remove")),
                    t._map = t._mapToAdd = null,
                    this) : this
                },
                hasLayer: function(t) {
                    return f(t)in this._layers
                },
                eachLayer: function(t, s) {
                    for (var c in this._layers)
                        t.call(s, this._layers[c]);
                    return this
                },
                _addLayers: function(t) {
                    t = t ? S(t) ? t : [t] : [];
                    for (var s = 0, c = t.length; s < c; s++)
                        this.addLayer(t[s])
                },
                _addZoomLimit: function(t) {
                    (!isNaN(t.options.maxZoom) || !isNaN(t.options.minZoom)) && (this._zoomBoundLayers[f(t)] = t,
                    this._updateZoomLevels())
                },
                _removeZoomLimit: function(t) {
                    var s = f(t);
                    this._zoomBoundLayers[s] && (delete this._zoomBoundLayers[s],
                    this._updateZoomLevels())
                },
                _updateZoomLevels: function() {
                    var t = 1 / 0
                      , s = -1 / 0
                      , c = this._getZoomSpan();
                    for (var p in this._zoomBoundLayers) {
                        var E = this._zoomBoundLayers[p].options;
                        t = E.minZoom === void 0 ? t : Math.min(t, E.minZoom),
                        s = E.maxZoom === void 0 ? s : Math.max(s, E.maxZoom)
                    }
                    this._layersMaxZoom = s === -1 / 0 ? void 0 : s,
                    this._layersMinZoom = t === 1 / 0 ? void 0 : t,
                    c !== this._getZoomSpan() && this.fire("zoomlevelschange"),
                    this.options.maxZoom === void 0 && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom),
                    this.options.minZoom === void 0 && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom)
                }
            });
            var Ii = nn.extend({
                initialize: function(t, s) {
                    T(this, s),
                    this._layers = {};
                    var c, p;
                    if (t)
                        for (c = 0,
                        p = t.length; c < p; c++)
                            this.addLayer(t[c])
                },
                addLayer: function(t) {
                    var s = this.getLayerId(t);
                    return this._layers[s] = t,
                    this._map && this._map.addLayer(t),
                    this
                },
                removeLayer: function(t) {
                    var s = t in this._layers ? t : this.getLayerId(t);
                    return this._map && this._layers[s] && this._map.removeLayer(this._layers[s]),
                    delete this._layers[s],
                    this
                },
                hasLayer: function(t) {
                    var s = typeof t == "number" ? t : this.getLayerId(t);
                    return s in this._layers
                },
                clearLayers: function() {
                    return this.eachLayer(this.removeLayer, this)
                },
                invoke: function(t) {
                    var s = Array.prototype.slice.call(arguments, 1), c, p;
                    for (c in this._layers)
                        p = this._layers[c],
                        p[t] && p[t].apply(p, s);
                    return this
                },
                onAdd: function(t) {
                    this.eachLayer(t.addLayer, t)
                },
                onRemove: function(t) {
                    this.eachLayer(t.removeLayer, t)
                },
                eachLayer: function(t, s) {
                    for (var c in this._layers)
                        t.call(s, this._layers[c]);
                    return this
                },
                getLayer: function(t) {
                    return this._layers[t]
                },
                getLayers: function() {
                    var t = [];
                    return this.eachLayer(t.push, t),
                    t
                },
                setZIndex: function(t) {
                    return this.invoke("setZIndex", t)
                },
                getLayerId: function(t) {
                    return f(t)
                }
            })
              , qp = function(t, s) {
                return new Ii(t,s)
            }
              , wn = Ii.extend({
                addLayer: function(t) {
                    return this.hasLayer(t) ? this : (t.addEventParent(this),
                    Ii.prototype.addLayer.call(this, t),
                    this.fire("layeradd", {
                        layer: t
                    }))
                },
                removeLayer: function(t) {
                    return this.hasLayer(t) ? (t in this._layers && (t = this._layers[t]),
                    t.removeEventParent(this),
                    Ii.prototype.removeLayer.call(this, t),
                    this.fire("layerremove", {
                        layer: t
                    })) : this
                },
                setStyle: function(t) {
                    return this.invoke("setStyle", t)
                },
                bringToFront: function() {
                    return this.invoke("bringToFront")
                },
                bringToBack: function() {
                    return this.invoke("bringToBack")
                },
                getBounds: function() {
                    var t = new ee;
                    for (var s in this._layers) {
                        var c = this._layers[s];
                        t.extend(c.getBounds ? c.getBounds() : c.getLatLng())
                    }
                    return t
                }
            })
              , zp = function(t, s) {
                return new wn(t,s)
            }
              , Ni = B.extend({
                options: {
                    popupAnchor: [0, 0],
                    tooltipAnchor: [0, 0],
                    crossOrigin: !1
                },
                initialize: function(t) {
                    T(this, t)
                },
                createIcon: function(t) {
                    return this._createIcon("icon", t)
                },
                createShadow: function(t) {
                    return this._createIcon("shadow", t)
                },
                _createIcon: function(t, s) {
                    var c = this._getIconUrl(t);
                    if (!c) {
                        if (t === "icon")
                            throw new Error("iconUrl not set in Icon options (see the docs).");
                        return null
                    }
                    var p = this._createImg(c, s && s.tagName === "IMG" ? s : null);
                    return this._setIconStyles(p, t),
                    (this.options.crossOrigin || this.options.crossOrigin === "") && (p.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin),
                    p
                },
                _setIconStyles: function(t, s) {
                    var c = this.options
                      , p = c[s + "Size"];
                    typeof p == "number" && (p = [p, p]);
                    var E = I(p)
                      , k = I(s === "shadow" && c.shadowAnchor || c.iconAnchor || E && E.divideBy(2, !0));
                    t.className = "leaflet-marker-" + s + " " + (c.className || ""),
                    k && (t.style.marginLeft = -k.x + "px",
                    t.style.marginTop = -k.y + "px"),
                    E && (t.style.width = E.x + "px",
                    t.style.height = E.y + "px")
                },
                _createImg: function(t, s) {
                    return s = s || document.createElement("img"),
                    s.src = t,
                    s
                },
                _getIconUrl: function(t) {
                    return Pe.retina && this.options[t + "RetinaUrl"] || this.options[t + "Url"]
                }
            });
            function Up(t) {
                return new Ni(t)
            }
            var sr = Ni.extend({
                options: {
                    iconUrl: "marker-icon.png",
                    iconRetinaUrl: "marker-icon-2x.png",
                    shadowUrl: "marker-shadow.png",
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    tooltipAnchor: [16, -28],
                    shadowSize: [41, 41]
                },
                _getIconUrl: function(t) {
                    return typeof sr.imagePath != "string" && (sr.imagePath = this._detectIconPath()),
                    (this.options.imagePath || sr.imagePath) + Ni.prototype._getIconUrl.call(this, t)
                },
                _stripUrl: function(t) {
                    var s = function(c, p, E) {
                        var k = p.exec(c);
                        return k && k[E]
                    };
                    return t = s(t, /^url\((['"])?(.+)\1\)$/, 2),
                    t && s(t, /^(.*)marker-icon\.png$/, 1)
                },
                _detectIconPath: function() {
                    var t = Ke("div", "leaflet-default-icon-path", document.body)
                      , s = Ki(t, "background-image") || Ki(t, "backgroundImage");
                    if (document.body.removeChild(t),
                    s = this._stripUrl(s),
                    s)
                        return s;
                    var c = document.querySelector('link[href$="leaflet.css"]');
                    return c ? c.href.substring(0, c.href.length - 11 - 1) : ""
                }
            })
              , Ru = fn.extend({
                initialize: function(t) {
                    this._marker = t
                },
                addHooks: function() {
                    var t = this._marker._icon;
                    this._draggable || (this._draggable = new Fn(t,t,!0)),
                    this._draggable.on({
                        dragstart: this._onDragStart,
                        predrag: this._onPreDrag,
                        drag: this._onDrag,
                        dragend: this._onDragEnd
                    }, this).enable(),
                    Ue(t, "leaflet-marker-draggable")
                },
                removeHooks: function() {
                    this._draggable.off({
                        dragstart: this._onDragStart,
                        predrag: this._onPreDrag,
                        drag: this._onDrag,
                        dragend: this._onDragEnd
                    }, this).disable(),
                    this._marker._icon && pt(this._marker._icon, "leaflet-marker-draggable")
                },
                moved: function() {
                    return this._draggable && this._draggable._moved
                },
                _adjustPan: function(t) {
                    var s = this._marker
                      , c = s._map
                      , p = this._marker.options.autoPanSpeed
                      , E = this._marker.options.autoPanPadding
                      , k = Kn(s._icon)
                      , ne = c.getPixelBounds()
                      , he = c.getPixelOrigin()
                      , ye = ie(ne.min._subtract(he).add(E), ne.max._subtract(he).subtract(E));
                    if (!ye.contains(k)) {
                        var Le = I((Math.max(ye.max.x, k.x) - ye.max.x) / (ne.max.x - ye.max.x) - (Math.min(ye.min.x, k.x) - ye.min.x) / (ne.min.x - ye.min.x), (Math.max(ye.max.y, k.y) - ye.max.y) / (ne.max.y - ye.max.y) - (Math.min(ye.min.y, k.y) - ye.min.y) / (ne.min.y - ye.min.y)).multiplyBy(p);
                        c.panBy(Le, {
                            animate: !1
                        }),
                        this._draggable._newPos._add(Le),
                        this._draggable._startPos._add(Le),
                        yt(s._icon, this._draggable._newPos),
                        this._onDrag(t),
                        this._panRequest = $(this._adjustPan.bind(this, t))
                    }
                },
                _onDragStart: function() {
                    this._oldLatLng = this._marker.getLatLng(),
                    this._marker.closePopup && this._marker.closePopup(),
                    this._marker.fire("movestart").fire("dragstart")
                },
                _onPreDrag: function(t) {
                    this._marker.options.autoPan && (X(this._panRequest),
                    this._panRequest = $(this._adjustPan.bind(this, t)))
                },
                _onDrag: function(t) {
                    var s = this._marker
                      , c = s._shadow
                      , p = Kn(s._icon)
                      , E = s._map.layerPointToLatLng(p);
                    c && yt(c, p),
                    s._latlng = E,
                    t.latlng = E,
                    t.oldLatLng = this._oldLatLng,
                    s.fire("move", t).fire("drag", t)
                },
                _onDragEnd: function(t) {
                    X(this._panRequest),
                    delete this._oldLatLng,
                    this._marker.fire("moveend").fire("dragend", t)
                }
            })
              , ts = nn.extend({
                options: {
                    icon: new sr,
                    interactive: !0,
                    keyboard: !0,
                    title: "",
                    alt: "Marker",
                    zIndexOffset: 0,
                    opacity: 1,
                    riseOnHover: !1,
                    riseOffset: 250,
                    pane: "markerPane",
                    shadowPane: "shadowPane",
                    bubblingMouseEvents: !1,
                    autoPanOnFocus: !0,
                    draggable: !1,
                    autoPan: !1,
                    autoPanPadding: [50, 50],
                    autoPanSpeed: 10
                },
                initialize: function(t, s) {
                    T(this, s),
                    this._latlng = G(t)
                },
                onAdd: function(t) {
                    this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation,
                    this._zoomAnimated && t.on("zoomanim", this._animateZoom, this),
                    this._initIcon(),
                    this.update()
                },
                onRemove: function(t) {
                    this.dragging && this.dragging.enabled() && (this.options.draggable = !0,
                    this.dragging.removeHooks()),
                    delete this.dragging,
                    this._zoomAnimated && t.off("zoomanim", this._animateZoom, this),
                    this._removeIcon(),
                    this._removeShadow()
                },
                getEvents: function() {
                    return {
                        zoom: this.update,
                        viewreset: this.update
                    }
                },
                getLatLng: function() {
                    return this._latlng
                },
                setLatLng: function(t) {
                    var s = this._latlng;
                    return this._latlng = G(t),
                    this.update(),
                    this.fire("move", {
                        oldLatLng: s,
                        latlng: this._latlng
                    })
                },
                setZIndexOffset: function(t) {
                    return this.options.zIndexOffset = t,
                    this.update()
                },
                getIcon: function() {
                    return this.options.icon
                },
                setIcon: function(t) {
                    return this.options.icon = t,
                    this._map && (this._initIcon(),
                    this.update()),
                    this._popup && this.bindPopup(this._popup, this._popup.options),
                    this
                },
                getElement: function() {
                    return this._icon
                },
                update: function() {
                    if (this._icon && this._map) {
                        var t = this._map.latLngToLayerPoint(this._latlng).round();
                        this._setPos(t)
                    }
                    return this
                },
                _initIcon: function() {
                    var t = this.options
                      , s = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide")
                      , c = t.icon.createIcon(this._icon)
                      , p = !1;
                    c !== this._icon && (this._icon && this._removeIcon(),
                    p = !0,
                    t.title && (c.title = t.title),
                    c.tagName === "IMG" && (c.alt = t.alt || "")),
                    Ue(c, s),
                    t.keyboard && (c.tabIndex = "0",
                    c.setAttribute("role", "button")),
                    this._icon = c,
                    t.riseOnHover && this.on({
                        mouseover: this._bringToFront,
                        mouseout: this._resetZIndex
                    }),
                    this.options.autoPanOnFocus && qe(c, "focus", this._panOnFocus, this);
                    var E = t.icon.createShadow(this._shadow)
                      , k = !1;
                    E !== this._shadow && (this._removeShadow(),
                    k = !0),
                    E && (Ue(E, s),
                    E.alt = ""),
                    this._shadow = E,
                    t.opacity < 1 && this._updateOpacity(),
                    p && this.getPane().appendChild(this._icon),
                    this._initInteraction(),
                    E && k && this.getPane(t.shadowPane).appendChild(this._shadow)
                },
                _removeIcon: function() {
                    this.options.riseOnHover && this.off({
                        mouseover: this._bringToFront,
                        mouseout: this._resetZIndex
                    }),
                    this.options.autoPanOnFocus && rt(this._icon, "focus", this._panOnFocus, this),
                    ut(this._icon),
                    this.removeInteractiveTarget(this._icon),
                    this._icon = null
                },
                _removeShadow: function() {
                    this._shadow && ut(this._shadow),
                    this._shadow = null
                },
                _setPos: function(t) {
                    this._icon && yt(this._icon, t),
                    this._shadow && yt(this._shadow, t),
                    this._zIndex = t.y + this.options.zIndexOffset,
                    this._resetZIndex()
                },
                _updateZIndex: function(t) {
                    this._icon && (this._icon.style.zIndex = this._zIndex + t)
                },
                _animateZoom: function(t) {
                    var s = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();
                    this._setPos(s)
                },
                _initInteraction: function() {
                    if (this.options.interactive && (Ue(this._icon, "leaflet-interactive"),
                    this.addInteractiveTarget(this._icon),
                    Ru)) {
                        var t = this.options.draggable;
                        this.dragging && (t = this.dragging.enabled(),
                        this.dragging.disable()),
                        this.dragging = new Ru(this),
                        t && this.dragging.enable()
                    }
                },
                setOpacity: function(t) {
                    return this.options.opacity = t,
                    this._map && this._updateOpacity(),
                    this
                },
                _updateOpacity: function() {
                    var t = this.options.opacity;
                    this._icon && Ht(this._icon, t),
                    this._shadow && Ht(this._shadow, t)
                },
                _bringToFront: function() {
                    this._updateZIndex(this.options.riseOffset)
                },
                _resetZIndex: function() {
                    this._updateZIndex(0)
                },
                _panOnFocus: function() {
                    var t = this._map;
                    if (t) {
                        var s = this.options.icon.options
                          , c = s.iconSize ? I(s.iconSize) : I(0, 0)
                          , p = s.iconAnchor ? I(s.iconAnchor) : I(0, 0);
                        t.panInside(this._latlng, {
                            paddingTopLeft: p,
                            paddingBottomRight: c.subtract(p)
                        })
                    }
                },
                _getPopupAnchor: function() {
                    return this.options.icon.options.popupAnchor
                },
                _getTooltipAnchor: function() {
                    return this.options.icon.options.tooltipAnchor
                }
            });
            function Hp(t, s) {
                return new ts(t,s)
            }
            var jn = nn.extend({
                options: {
                    stroke: !0,
                    color: "#3388ff",
                    weight: 3,
                    opacity: 1,
                    lineCap: "round",
                    lineJoin: "round",
                    dashArray: null,
                    dashOffset: null,
                    fill: !1,
                    fillColor: null,
                    fillOpacity: .2,
                    fillRule: "evenodd",
                    interactive: !0,
                    bubblingMouseEvents: !0
                },
                beforeAdd: function(t) {
                    this._renderer = t.getRenderer(this)
                },
                onAdd: function() {
                    this._renderer._initPath(this),
                    this._reset(),
                    this._renderer._addPath(this)
                },
                onRemove: function() {
                    this._renderer._removePath(this)
                },
                redraw: function() {
                    return this._map && this._renderer._updatePath(this),
                    this
                },
                setStyle: function(t) {
                    return T(this, t),
                    this._renderer && (this._renderer._updateStyle(this),
                    this.options.stroke && t && Object.prototype.hasOwnProperty.call(t, "weight") && this._updateBounds()),
                    this
                },
                bringToFront: function() {
                    return this._renderer && this._renderer._bringToFront(this),
                    this
                },
                bringToBack: function() {
                    return this._renderer && this._renderer._bringToBack(this),
                    this
                },
                getElement: function() {
                    return this._path
                },
                _reset: function() {
                    this._project(),
                    this._update()
                },
                _clickTolerance: function() {
                    return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0)
                }
            })
              , ns = jn.extend({
                options: {
                    fill: !0,
                    radius: 10
                },
                initialize: function(t, s) {
                    T(this, s),
                    this._latlng = G(t),
                    this._radius = this.options.radius
                },
                setLatLng: function(t) {
                    var s = this._latlng;
                    return this._latlng = G(t),
                    this.redraw(),
                    this.fire("move", {
                        oldLatLng: s,
                        latlng: this._latlng
                    })
                },
                getLatLng: function() {
                    return this._latlng
                },
                setRadius: function(t) {
                    return this.options.radius = this._radius = t,
                    this.redraw()
                },
                getRadius: function() {
                    return this._radius
                },
                setStyle: function(t) {
                    var s = t && t.radius || this._radius;
                    return jn.prototype.setStyle.call(this, t),
                    this.setRadius(s),
                    this
                },
                _project: function() {
                    this._point = this._map.latLngToLayerPoint(this._latlng),
                    this._updateBounds()
                },
                _updateBounds: function() {
                    var t = this._radius
                      , s = this._radiusY || t
                      , c = this._clickTolerance()
                      , p = [t + c, s + c];
                    this._pxBounds = new Z(this._point.subtract(p),this._point.add(p))
                },
                _update: function() {
                    this._map && this._updatePath()
                },
                _updatePath: function() {
                    this._renderer._updateCircle(this)
                },
                _empty: function() {
                    return this._radius && !this._renderer._bounds.intersects(this._pxBounds)
                },
                _containsPoint: function(t) {
                    return t.distanceTo(this._point) <= this._radius + this._clickTolerance()
                }
            });
            function Vp(t, s) {
                return new ns(t,s)
            }
            var Lo = ns.extend({
                initialize: function(t, s, c) {
                    if (typeof s == "number" && (s = o({}, c, {
                        radius: s
                    })),
                    T(this, s),
                    this._latlng = G(t),
                    isNaN(this.options.radius))
                        throw new Error("Circle radius cannot be NaN");
                    this._mRadius = this.options.radius
                },
                setRadius: function(t) {
                    return this._mRadius = t,
                    this.redraw()
                },
                getRadius: function() {
                    return this._mRadius
                },
                getBounds: function() {
                    var t = [this._radius, this._radiusY || this._radius];
                    return new ee(this._map.layerPointToLatLng(this._point.subtract(t)),this._map.layerPointToLatLng(this._point.add(t)))
                },
                setStyle: jn.prototype.setStyle,
                _project: function() {
                    var t = this._latlng.lng
                      , s = this._latlng.lat
                      , c = this._map
                      , p = c.options.crs;
                    if (p.distance === K.distance) {
                        var E = Math.PI / 180
                          , k = this._mRadius / K.R / E
                          , ne = c.project([s + k, t])
                          , he = c.project([s - k, t])
                          , ye = ne.add(he).divideBy(2)
                          , Le = c.unproject(ye).lat
                          , Ce = Math.acos((Math.cos(k * E) - Math.sin(s * E) * Math.sin(Le * E)) / (Math.cos(s * E) * Math.cos(Le * E))) / E;
                        (isNaN(Ce) || Ce === 0) && (Ce = k / Math.cos(Math.PI / 180 * s)),
                        this._point = ye.subtract(c.getPixelOrigin()),
                        this._radius = isNaN(Ce) ? 0 : ye.x - c.project([Le, t - Ce]).x,
                        this._radiusY = ye.y - ne.y
                    } else {
                        var je = p.unproject(p.project(this._latlng).subtract([this._mRadius, 0]));
                        this._point = c.latLngToLayerPoint(this._latlng),
                        this._radius = this._point.x - c.latLngToLayerPoint(je).x
                    }
                    this._updateBounds()
                }
            });
            function Gp(t, s, c) {
                return new Lo(t,s,c)
            }
            var xn = jn.extend({
                options: {
                    smoothFactor: 1,
                    noClip: !1
                },
                initialize: function(t, s) {
                    T(this, s),
                    this._setLatLngs(t)
                },
                getLatLngs: function() {
                    return this._latlngs
                },
                setLatLngs: function(t) {
                    return this._setLatLngs(t),
                    this.redraw()
                },
                isEmpty: function() {
                    return !this._latlngs.length
                },
                closestLayerPoint: function(t) {
                    for (var s = 1 / 0, c = null, p = rr, E, k, ne = 0, he = this._parts.length; ne < he; ne++)
                        for (var ye = this._parts[ne], Le = 1, Ce = ye.length; Le < Ce; Le++) {
                            E = ye[Le - 1],
                            k = ye[Le];
                            var je = p(t, E, k, !0);
                            je < s && (s = je,
                            c = p(t, E, k))
                        }
                    return c && (c.distance = Math.sqrt(s)),
                    c
                },
                getCenter: function() {
                    if (!this._map)
                        throw new Error("Must add layer to map before using getCenter()");
                    return Nu(this._defaultShape(), this._map.options.crs)
                },
                getBounds: function() {
                    return this._bounds
                },
                addLatLng: function(t, s) {
                    return s = s || this._defaultShape(),
                    t = G(t),
                    s.push(t),
                    this._bounds.extend(t),
                    this.redraw()
                },
                _setLatLngs: function(t) {
                    this._bounds = new ee,
                    this._latlngs = this._convertLatLngs(t)
                },
                _defaultShape: function() {
                    return Vt(this._latlngs) ? this._latlngs : this._latlngs[0]
                },
                _convertLatLngs: function(t) {
                    for (var s = [], c = Vt(t), p = 0, E = t.length; p < E; p++)
                        c ? (s[p] = G(t[p]),
                        this._bounds.extend(s[p])) : s[p] = this._convertLatLngs(t[p]);
                    return s
                },
                _project: function() {
                    var t = new Z;
                    this._rings = [],
                    this._projectLatlngs(this._latlngs, this._rings, t),
                    this._bounds.isValid() && t.isValid() && (this._rawPxBounds = t,
                    this._updateBounds())
                },
                _updateBounds: function() {
                    var t = this._clickTolerance()
                      , s = new j(t,t);
                    this._rawPxBounds && (this._pxBounds = new Z([this._rawPxBounds.min.subtract(s), this._rawPxBounds.max.add(s)]))
                },
                _projectLatlngs: function(t, s, c) {
                    var p = t[0]instanceof W, E = t.length, k, ne;
                    if (p) {
                        for (ne = [],
                        k = 0; k < E; k++)
                            ne[k] = this._map.latLngToLayerPoint(t[k]),
                            c.extend(ne[k]);
                        s.push(ne)
                    } else
                        for (k = 0; k < E; k++)
                            this._projectLatlngs(t[k], s, c)
                },
                _clipPoints: function() {
                    var t = this._renderer._bounds;
                    if (this._parts = [],
                    !(!this._pxBounds || !this._pxBounds.intersects(t))) {
                        if (this.options.noClip) {
                            this._parts = this._rings;
                            return
                        }
                        var s = this._parts, c, p, E, k, ne, he, ye;
                        for (c = 0,
                        E = 0,
                        k = this._rings.length; c < k; c++)
                            for (ye = this._rings[c],
                            p = 0,
                            ne = ye.length; p < ne - 1; p++)
                                he = Lu(ye[p], ye[p + 1], t, p, !0),
                                he && (s[E] = s[E] || [],
                                s[E].push(he[0]),
                                (he[1] !== ye[p + 1] || p === ne - 2) && (s[E].push(he[1]),
                                E++))
                    }
                },
                _simplifyPoints: function() {
                    for (var t = this._parts, s = this.options.smoothFactor, c = 0, p = t.length; c < p; c++)
                        t[c] = Eu(t[c], s)
                },
                _update: function() {
                    this._map && (this._clipPoints(),
                    this._simplifyPoints(),
                    this._updatePath())
                },
                _updatePath: function() {
                    this._renderer._updatePoly(this)
                },
                _containsPoint: function(t, s) {
                    var c, p, E, k, ne, he, ye = this._clickTolerance();
                    if (!this._pxBounds || !this._pxBounds.contains(t))
                        return !1;
                    for (c = 0,
                    k = this._parts.length; c < k; c++)
                        for (he = this._parts[c],
                        p = 0,
                        ne = he.length,
                        E = ne - 1; p < ne; E = p++)
                            if (!(!s && p === 0) && Su(t, he[E], he[p]) <= ye)
                                return !0;
                    return !1
                }
            });
            function Wp(t, s) {
                return new xn(t,s)
            }
            xn._flat = Iu;
            var Ai = xn.extend({
                options: {
                    fill: !0
                },
                isEmpty: function() {
                    return !this._latlngs.length || !this._latlngs[0].length
                },
                getCenter: function() {
                    if (!this._map)
                        throw new Error("Must add layer to map before using getCenter()");
                    return xu(this._defaultShape(), this._map.options.crs)
                },
                _convertLatLngs: function(t) {
                    var s = xn.prototype._convertLatLngs.call(this, t)
                      , c = s.length;
                    return c >= 2 && s[0]instanceof W && s[0].equals(s[c - 1]) && s.pop(),
                    s
                },
                _setLatLngs: function(t) {
                    xn.prototype._setLatLngs.call(this, t),
                    Vt(this._latlngs) && (this._latlngs = [this._latlngs])
                },
                _defaultShape: function() {
                    return Vt(this._latlngs[0]) ? this._latlngs[0] : this._latlngs[0][0]
                },
                _clipPoints: function() {
                    var t = this._renderer._bounds
                      , s = this.options.weight
                      , c = new j(s,s);
                    if (t = new Z(t.min.subtract(c),t.max.add(c)),
                    this._parts = [],
                    !(!this._pxBounds || !this._pxBounds.intersects(t))) {
                        if (this.options.noClip) {
                            this._parts = this._rings;
                            return
                        }
                        for (var p = 0, E = this._rings.length, k; p < E; p++)
                            k = wu(this._rings[p], t, !0),
                            k.length && this._parts.push(k)
                    }
                },
                _updatePath: function() {
                    this._renderer._updatePoly(this, !0)
                },
                _containsPoint: function(t) {
                    var s = !1, c, p, E, k, ne, he, ye, Le;
                    if (!this._pxBounds || !this._pxBounds.contains(t))
                        return !1;
                    for (k = 0,
                    ye = this._parts.length; k < ye; k++)
                        for (c = this._parts[k],
                        ne = 0,
                        Le = c.length,
                        he = Le - 1; ne < Le; he = ne++)
                            p = c[ne],
                            E = c[he],
                            p.y > t.y != E.y > t.y && t.x < (E.x - p.x) * (t.y - p.y) / (E.y - p.y) + p.x && (s = !s);
                    return s || xn.prototype._containsPoint.call(this, t, !0)
                }
            });
            function Zp(t, s) {
                return new Ai(t,s)
            }
            var En = wn.extend({
                initialize: function(t, s) {
                    T(this, s),
                    this._layers = {},
                    t && this.addData(t)
                },
                addData: function(t) {
                    var s = S(t) ? t : t.features, c, p, E;
                    if (s) {
                        for (c = 0,
                        p = s.length; c < p; c++)
                            E = s[c],
                            (E.geometries || E.geometry || E.features || E.coordinates) && this.addData(E);
                        return this
                    }
                    var k = this.options;
                    if (k.filter && !k.filter(t))
                        return this;
                    var ne = is(t, k);
                    return ne ? (ne.feature = os(t),
                    ne.defaultOptions = ne.options,
                    this.resetStyle(ne),
                    k.onEachFeature && k.onEachFeature(t, ne),
                    this.addLayer(ne)) : this
                },
                resetStyle: function(t) {
                    return t === void 0 ? this.eachLayer(this.resetStyle, this) : (t.options = o({}, t.defaultOptions),
                    this._setLayerStyle(t, this.options.style),
                    this)
                },
                setStyle: function(t) {
                    return this.eachLayer(function(s) {
                        this._setLayerStyle(s, t)
                    }, this)
                },
                _setLayerStyle: function(t, s) {
                    t.setStyle && (typeof s == "function" && (s = s(t.feature)),
                    t.setStyle(s))
                }
            });
            function is(t, s) {
                var c = t.type === "Feature" ? t.geometry : t, p = c ? c.coordinates : null, E = [], k = s && s.pointToLayer, ne = s && s.coordsToLatLng || Io, he, ye, Le, Ce;
                if (!p && !c)
                    return null;
                switch (c.type) {
                case "Point":
                    return he = ne(p),
                    Cu(k, t, he, s);
                case "MultiPoint":
                    for (Le = 0,
                    Ce = p.length; Le < Ce; Le++)
                        he = ne(p[Le]),
                        E.push(Cu(k, t, he, s));
                    return new wn(E);
                case "LineString":
                case "MultiLineString":
                    return ye = rs(p, c.type === "LineString" ? 0 : 1, ne),
                    new xn(ye,s);
                case "Polygon":
                case "MultiPolygon":
                    return ye = rs(p, c.type === "Polygon" ? 1 : 2, ne),
                    new Ai(ye,s);
                case "GeometryCollection":
                    for (Le = 0,
                    Ce = c.geometries.length; Le < Ce; Le++) {
                        var je = is({
                            geometry: c.geometries[Le],
                            type: "Feature",
                            properties: t.properties
                        }, s);
                        je && E.push(je)
                    }
                    return new wn(E);
                case "FeatureCollection":
                    for (Le = 0,
                    Ce = c.features.length; Le < Ce; Le++) {
                        var Ve = is(c.features[Le], s);
                        Ve && E.push(Ve)
                    }
                    return new wn(E);
                default:
                    throw new Error("Invalid GeoJSON object.")
                }
            }
            function Cu(t, s, c, p) {
                return t ? t(s, c) : new ts(c,p && p.markersInheritOptions && p)
            }
            function Io(t) {
                return new W(t[1],t[0],t[2])
            }
            function rs(t, s, c) {
                for (var p = [], E = 0, k = t.length, ne; E < k; E++)
                    ne = s ? rs(t[E], s - 1, c) : (c || Io)(t[E]),
                    p.push(ne);
                return p
            }
            function No(t, s) {
                return t = G(t),
                t.alt !== void 0 ? [d(t.lng, s), d(t.lat, s), d(t.alt, s)] : [d(t.lng, s), d(t.lat, s)]
            }
            function ss(t, s, c, p) {
                for (var E = [], k = 0, ne = t.length; k < ne; k++)
                    E.push(s ? ss(t[k], Vt(t[k]) ? 0 : s - 1, c, p) : No(t[k], p));
                return !s && c && E.length > 0 && E.push(E[0].slice()),
                E
            }
            function Ri(t, s) {
                return t.feature ? o({}, t.feature, {
                    geometry: s
                }) : os(s)
            }
            function os(t) {
                return t.type === "Feature" || t.type === "FeatureCollection" ? t : {
                    type: "Feature",
                    properties: {},
                    geometry: t
                }
            }
            var Ao = {
                toGeoJSON: function(t) {
                    return Ri(this, {
                        type: "Point",
                        coordinates: No(this.getLatLng(), t)
                    })
                }
            };
            ts.include(Ao),
            Lo.include(Ao),
            ns.include(Ao),
            xn.include({
                toGeoJSON: function(t) {
                    var s = !Vt(this._latlngs)
                      , c = ss(this._latlngs, s ? 1 : 0, !1, t);
                    return Ri(this, {
                        type: (s ? "Multi" : "") + "LineString",
                        coordinates: c
                    })
                }
            }),
            Ai.include({
                toGeoJSON: function(t) {
                    var s = !Vt(this._latlngs)
                      , c = s && !Vt(this._latlngs[0])
                      , p = ss(this._latlngs, c ? 2 : s ? 1 : 0, !0, t);
                    return s || (p = [p]),
                    Ri(this, {
                        type: (c ? "Multi" : "") + "Polygon",
                        coordinates: p
                    })
                }
            }),
            Ii.include({
                toMultiPoint: function(t) {
                    var s = [];
                    return this.eachLayer(function(c) {
                        s.push(c.toGeoJSON(t).geometry.coordinates)
                    }),
                    Ri(this, {
                        type: "MultiPoint",
                        coordinates: s
                    })
                },
                toGeoJSON: function(t) {
                    var s = this.feature && this.feature.geometry && this.feature.geometry.type;
                    if (s === "MultiPoint")
                        return this.toMultiPoint(t);
                    var c = s === "GeometryCollection"
                      , p = [];
                    return this.eachLayer(function(E) {
                        if (E.toGeoJSON) {
                            var k = E.toGeoJSON(t);
                            if (c)
                                p.push(k.geometry);
                            else {
                                var ne = os(k);
                                ne.type === "FeatureCollection" ? p.push.apply(p, ne.features) : p.push(ne)
                            }
                        }
                    }),
                    c ? Ri(this, {
                        geometries: p,
                        type: "GeometryCollection"
                    }) : {
                        type: "FeatureCollection",
                        features: p
                    }
                }
            });
            function ku(t, s) {
                return new En(t,s)
            }
            var Xp = ku
              , as = nn.extend({
                options: {
                    opacity: 1,
                    alt: "",
                    interactive: !1,
                    crossOrigin: !1,
                    errorOverlayUrl: "",
                    zIndex: 1,
                    className: ""
                },
                initialize: function(t, s, c) {
                    this._url = t,
                    this._bounds = me(s),
                    T(this, c)
                },
                onAdd: function() {
                    this._image || (this._initImage(),
                    this.options.opacity < 1 && this._updateOpacity()),
                    this.options.interactive && (Ue(this._image, "leaflet-interactive"),
                    this.addInteractiveTarget(this._image)),
                    this.getPane().appendChild(this._image),
                    this._reset()
                },
                onRemove: function() {
                    ut(this._image),
                    this.options.interactive && this.removeInteractiveTarget(this._image)
                },
                setOpacity: function(t) {
                    return this.options.opacity = t,
                    this._image && this._updateOpacity(),
                    this
                },
                setStyle: function(t) {
                    return t.opacity && this.setOpacity(t.opacity),
                    this
                },
                bringToFront: function() {
                    return this._map && Ti(this._image),
                    this
                },
                bringToBack: function() {
                    return this._map && Li(this._image),
                    this
                },
                setUrl: function(t) {
                    return this._url = t,
                    this._image && (this._image.src = t),
                    this
                },
                setBounds: function(t) {
                    return this._bounds = me(t),
                    this._map && this._reset(),
                    this
                },
                getEvents: function() {
                    var t = {
                        zoom: this._reset,
                        viewreset: this._reset
                    };
                    return this._zoomAnimated && (t.zoomanim = this._animateZoom),
                    t
                },
                setZIndex: function(t) {
                    return this.options.zIndex = t,
                    this._updateZIndex(),
                    this
                },
                getBounds: function() {
                    return this._bounds
                },
                getElement: function() {
                    return this._image
                },
                _initImage: function() {
                    var t = this._url.tagName === "IMG"
                      , s = this._image = t ? this._url : Ke("img");
                    if (Ue(s, "leaflet-image-layer"),
                    this._zoomAnimated && Ue(s, "leaflet-zoom-animated"),
                    this.options.className && Ue(s, this.options.className),
                    s.onselectstart = _,
                    s.onmousemove = _,
                    s.onload = l(this.fire, this, "load"),
                    s.onerror = l(this._overlayOnError, this, "error"),
                    (this.options.crossOrigin || this.options.crossOrigin === "") && (s.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin),
                    this.options.zIndex && this._updateZIndex(),
                    t) {
                        this._url = s.src;
                        return
                    }
                    s.src = this._url,
                    s.alt = this.options.alt
                },
                _animateZoom: function(t) {
                    var s = this._map.getZoomScale(t.zoom)
                      , c = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min;
                    Jn(this._image, c, s)
                },
                _reset: function() {
                    var t = this._image
                      , s = new Z(this._map.latLngToLayerPoint(this._bounds.getNorthWest()),this._map.latLngToLayerPoint(this._bounds.getSouthEast()))
                      , c = s.getSize();
                    yt(t, s.min),
                    t.style.width = c.x + "px",
                    t.style.height = c.y + "px"
                },
                _updateOpacity: function() {
                    Ht(this._image, this.options.opacity)
                },
                _updateZIndex: function() {
                    this._image && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._image.style.zIndex = this.options.zIndex)
                },
                _overlayOnError: function() {
                    this.fire("error");
                    var t = this.options.errorOverlayUrl;
                    t && this._url !== t && (this._url = t,
                    this._image.src = t)
                },
                getCenter: function() {
                    return this._bounds.getCenter()
                }
            })
              , Qp = function(t, s, c) {
                return new as(t,s,c)
            }
              , Pu = as.extend({
                options: {
                    autoplay: !0,
                    loop: !0,
                    keepAspectRatio: !0,
                    muted: !1,
                    playsInline: !0
                },
                _initImage: function() {
                    var t = this._url.tagName === "VIDEO"
                      , s = this._image = t ? this._url : Ke("video");
                    if (Ue(s, "leaflet-image-layer"),
                    this._zoomAnimated && Ue(s, "leaflet-zoom-animated"),
                    this.options.className && Ue(s, this.options.className),
                    s.onselectstart = _,
                    s.onmousemove = _,
                    s.onloadeddata = l(this.fire, this, "load"),
                    t) {
                        for (var c = s.getElementsByTagName("source"), p = [], E = 0; E < c.length; E++)
                            p.push(c[E].src);
                        this._url = c.length > 0 ? p : [s.src];
                        return
                    }
                    S(this._url) || (this._url = [this._url]),
                    !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(s.style, "objectFit") && (s.style.objectFit = "fill"),
                    s.autoplay = !!this.options.autoplay,
                    s.loop = !!this.options.loop,
                    s.muted = !!this.options.muted,
                    s.playsInline = !!this.options.playsInline;
                    for (var k = 0; k < this._url.length; k++) {
                        var ne = Ke("source");
                        ne.src = this._url[k],
                        s.appendChild(ne)
                    }
                }
            });
            function Jp(t, s, c) {
                return new Pu(t,s,c)
            }
            var Mu = as.extend({
                _initImage: function() {
                    var t = this._image = this._url;
                    Ue(t, "leaflet-image-layer"),
                    this._zoomAnimated && Ue(t, "leaflet-zoom-animated"),
                    this.options.className && Ue(t, this.options.className),
                    t.onselectstart = _,
                    t.onmousemove = _
                }
            });
            function Kp(t, s, c) {
                return new Mu(t,s,c)
            }
            var pn = nn.extend({
                options: {
                    interactive: !1,
                    offset: [0, 0],
                    className: "",
                    pane: void 0,
                    content: ""
                },
                initialize: function(t, s) {
                    t && (t instanceof W || S(t)) ? (this._latlng = G(t),
                    T(this, s)) : (T(this, t),
                    this._source = s),
                    this.options.content && (this._content = this.options.content)
                },
                openOn: function(t) {
                    return t = arguments.length ? t : this._source._map,
                    t.hasLayer(this) || t.addLayer(this),
                    this
                },
                close: function() {
                    return this._map && this._map.removeLayer(this),
                    this
                },
                toggle: function(t) {
                    return this._map ? this.close() : (arguments.length ? this._source = t : t = this._source,
                    this._prepareOpen(),
                    this.openOn(t._map)),
                    this
                },
                onAdd: function(t) {
                    this._zoomAnimated = t._zoomAnimated,
                    this._container || this._initLayout(),
                    t._fadeAnimated && Ht(this._container, 0),
                    clearTimeout(this._removeTimeout),
                    this.getPane().appendChild(this._container),
                    this.update(),
                    t._fadeAnimated && Ht(this._container, 1),
                    this.bringToFront(),
                    this.options.interactive && (Ue(this._container, "leaflet-interactive"),
                    this.addInteractiveTarget(this._container))
                },
                onRemove: function(t) {
                    t._fadeAnimated ? (Ht(this._container, 0),
                    this._removeTimeout = setTimeout(l(ut, void 0, this._container), 200)) : ut(this._container),
                    this.options.interactive && (pt(this._container, "leaflet-interactive"),
                    this.removeInteractiveTarget(this._container))
                },
                getLatLng: function() {
                    return this._latlng
                },
                setLatLng: function(t) {
                    return this._latlng = G(t),
                    this._map && (this._updatePosition(),
                    this._adjustPan()),
                    this
                },
                getContent: function() {
                    return this._content
                },
                setContent: function(t) {
                    return this._content = t,
                    this.update(),
                    this
                },
                getElement: function() {
                    return this._container
                },
                update: function() {
                    this._map && (this._container.style.visibility = "hidden",
                    this._updateContent(),
                    this._updateLayout(),
                    this._updatePosition(),
                    this._container.style.visibility = "",
                    this._adjustPan())
                },
                getEvents: function() {
                    var t = {
                        zoom: this._updatePosition,
                        viewreset: this._updatePosition
                    };
                    return this._zoomAnimated && (t.zoomanim = this._animateZoom),
                    t
                },
                isOpen: function() {
                    return !!this._map && this._map.hasLayer(this)
                },
                bringToFront: function() {
                    return this._map && Ti(this._container),
                    this
                },
                bringToBack: function() {
                    return this._map && Li(this._container),
                    this
                },
                _prepareOpen: function(t) {
                    var s = this._source;
                    if (!s._map)
                        return !1;
                    if (s instanceof wn) {
                        s = null;
                        var c = this._source._layers;
                        for (var p in c)
                            if (c[p]._map) {
                                s = c[p];
                                break
                            }
                        if (!s)
                            return !1;
                        this._source = s
                    }
                    if (!t)
                        if (s.getCenter)
                            t = s.getCenter();
                        else if (s.getLatLng)
                            t = s.getLatLng();
                        else if (s.getBounds)
                            t = s.getBounds().getCenter();
                        else
                            throw new Error("Unable to get source layer LatLng.");
                    return this.setLatLng(t),
                    this._map && this.update(),
                    !0
                },
                _updateContent: function() {
                    if (this._content) {
                        var t = this._contentNode
                          , s = typeof this._content == "function" ? this._content(this._source || this) : this._content;
                        if (typeof s == "string")
                            t.innerHTML = s;
                        else {
                            for (; t.hasChildNodes(); )
                                t.removeChild(t.firstChild);
                            t.appendChild(s)
                        }
                        this.fire("contentupdate")
                    }
                },
                _updatePosition: function() {
                    if (this._map) {
                        var t = this._map.latLngToLayerPoint(this._latlng)
                          , s = I(this.options.offset)
                          , c = this._getAnchor();
                        this._zoomAnimated ? yt(this._container, t.add(c)) : s = s.add(t).add(c);
                        var p = this._containerBottom = -s.y
                          , E = this._containerLeft = -Math.round(this._containerWidth / 2) + s.x;
                        this._container.style.bottom = p + "px",
                        this._container.style.left = E + "px"
                    }
                },
                _getAnchor: function() {
                    return [0, 0]
                }
            });
            Xe.include({
                _initOverlay: function(t, s, c, p) {
                    var E = s;
                    return E instanceof t || (E = new t(p).setContent(s)),
                    c && E.setLatLng(c),
                    E
                }
            }),
            nn.include({
                _initOverlay: function(t, s, c, p) {
                    var E = c;
                    return E instanceof t ? (T(E, p),
                    E._source = this) : (E = s && !p ? s : new t(p,this),
                    E.setContent(c)),
                    E
                }
            });
            var ls = pn.extend({
                options: {
                    pane: "popupPane",
                    offset: [0, 7],
                    maxWidth: 300,
                    minWidth: 50,
                    maxHeight: null,
                    autoPan: !0,
                    autoPanPaddingTopLeft: null,
                    autoPanPaddingBottomRight: null,
                    autoPanPadding: [5, 5],
                    keepInView: !1,
                    closeButton: !0,
                    autoClose: !0,
                    closeOnEscapeKey: !0,
                    className: ""
                },
                openOn: function(t) {
                    return t = arguments.length ? t : this._source._map,
                    !t.hasLayer(this) && t._popup && t._popup.options.autoClose && t.removeLayer(t._popup),
                    t._popup = this,
                    pn.prototype.openOn.call(this, t)
                },
                onAdd: function(t) {
                    pn.prototype.onAdd.call(this, t),
                    t.fire("popupopen", {
                        popup: this
                    }),
                    this._source && (this._source.fire("popupopen", {
                        popup: this
                    }, !0),
                    this._source instanceof jn || this._source.on("preclick", Yn))
                },
                onRemove: function(t) {
                    pn.prototype.onRemove.call(this, t),
                    t.fire("popupclose", {
                        popup: this
                    }),
                    this._source && (this._source.fire("popupclose", {
                        popup: this
                    }, !0),
                    this._source instanceof jn || this._source.off("preclick", Yn))
                },
                getEvents: function() {
                    var t = pn.prototype.getEvents.call(this);
                    return (this.options.closeOnClick !== void 0 ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this.close),
                    this.options.keepInView && (t.moveend = this._adjustPan),
                    t
                },
                _initLayout: function() {
                    var t = "leaflet-popup"
                      , s = this._container = Ke("div", t + " " + (this.options.className || "") + " leaflet-zoom-animated")
                      , c = this._wrapper = Ke("div", t + "-content-wrapper", s);
                    if (this._contentNode = Ke("div", t + "-content", c),
                    nr(s),
                    yo(this._contentNode),
                    qe(s, "contextmenu", Yn),
                    this._tipContainer = Ke("div", t + "-tip-container", s),
                    this._tip = Ke("div", t + "-tip", this._tipContainer),
                    this.options.closeButton) {
                        var p = this._closeButton = Ke("a", t + "-close-button", s);
                        p.setAttribute("role", "button"),
                        p.setAttribute("aria-label", "Close popup"),
                        p.href = "#close",
                        p.innerHTML = '<span aria-hidden="true">&#215;</span>',
                        qe(p, "click", function(E) {
                            St(E),
                            this.close()
                        }, this)
                    }
                },
                _updateLayout: function() {
                    var t = this._contentNode
                      , s = t.style;
                    s.width = "",
                    s.whiteSpace = "nowrap";
                    var c = t.offsetWidth;
                    c = Math.min(c, this.options.maxWidth),
                    c = Math.max(c, this.options.minWidth),
                    s.width = c + 1 + "px",
                    s.whiteSpace = "",
                    s.height = "";
                    var p = t.offsetHeight
                      , E = this.options.maxHeight
                      , k = "leaflet-popup-scrolled";
                    E && p > E ? (s.height = E + "px",
                    Ue(t, k)) : pt(t, k),
                    this._containerWidth = this._container.offsetWidth
                },
                _animateZoom: function(t) {
                    var s = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center)
                      , c = this._getAnchor();
                    yt(this._container, s.add(c))
                },
                _adjustPan: function() {
                    if (this.options.autoPan) {
                        if (this._map._panAnim && this._map._panAnim.stop(),
                        this._autopanning) {
                            this._autopanning = !1;
                            return
                        }
                        var t = this._map
                          , s = parseInt(Ki(this._container, "marginBottom"), 10) || 0
                          , c = this._container.offsetHeight + s
                          , p = this._containerWidth
                          , E = new j(this._containerLeft,-c - this._containerBottom);
                        E._add(Kn(this._container));
                        var k = t.layerPointToContainerPoint(E)
                          , ne = I(this.options.autoPanPadding)
                          , he = I(this.options.autoPanPaddingTopLeft || ne)
                          , ye = I(this.options.autoPanPaddingBottomRight || ne)
                          , Le = t.getSize()
                          , Ce = 0
                          , je = 0;
                        k.x + p + ye.x > Le.x && (Ce = k.x + p - Le.x + ye.x),
                        k.x - Ce - he.x < 0 && (Ce = k.x - he.x),
                        k.y + c + ye.y > Le.y && (je = k.y + c - Le.y + ye.y),
                        k.y - je - he.y < 0 && (je = k.y - he.y),
                        (Ce || je) && (this.options.keepInView && (this._autopanning = !0),
                        t.fire("autopanstart").panBy([Ce, je]))
                    }
                },
                _getAnchor: function() {
                    return I(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0])
                }
            })
              , Yp = function(t, s) {
                return new ls(t,s)
            };
            Xe.mergeOptions({
                closePopupOnClick: !0
            }),
            Xe.include({
                openPopup: function(t, s, c) {
                    return this._initOverlay(ls, t, s, c).openOn(this),
                    this
                },
                closePopup: function(t) {
                    return t = arguments.length ? t : this._popup,
                    t && t.close(),
                    this
                }
            }),
            nn.include({
                bindPopup: function(t, s) {
                    return this._popup = this._initOverlay(ls, this._popup, t, s),
                    this._popupHandlersAdded || (this.on({
                        click: this._openPopup,
                        keypress: this._onKeyPress,
                        remove: this.closePopup,
                        move: this._movePopup
                    }),
                    this._popupHandlersAdded = !0),
                    this
                },
                unbindPopup: function() {
                    return this._popup && (this.off({
                        click: this._openPopup,
                        keypress: this._onKeyPress,
                        remove: this.closePopup,
                        move: this._movePopup
                    }),
                    this._popupHandlersAdded = !1,
                    this._popup = null),
                    this
                },
                openPopup: function(t) {
                    return this._popup && (this instanceof wn || (this._popup._source = this),
                    this._popup._prepareOpen(t || this._latlng) && this._popup.openOn(this._map)),
                    this
                },
                closePopup: function() {
                    return this._popup && this._popup.close(),
                    this
                },
                togglePopup: function() {
                    return this._popup && this._popup.toggle(this),
                    this
                },
                isPopupOpen: function() {
                    return this._popup ? this._popup.isOpen() : !1
                },
                setPopupContent: function(t) {
                    return this._popup && this._popup.setContent(t),
                    this
                },
                getPopup: function() {
                    return this._popup
                },
                _openPopup: function(t) {
                    if (!(!this._popup || !this._map)) {
                        ei(t);
                        var s = t.layer || t.target;
                        if (this._popup._source === s && !(s instanceof jn)) {
                            this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(t.latlng);
                            return
                        }
                        this._popup._source = s,
                        this.openPopup(t.latlng)
                    }
                },
                _movePopup: function(t) {
                    this._popup.setLatLng(t.latlng)
                },
                _onKeyPress: function(t) {
                    t.originalEvent.keyCode === 13 && this._openPopup(t)
                }
            });
            var us = pn.extend({
                options: {
                    pane: "tooltipPane",
                    offset: [0, 0],
                    direction: "auto",
                    permanent: !1,
                    sticky: !1,
                    opacity: .9
                },
                onAdd: function(t) {
                    pn.prototype.onAdd.call(this, t),
                    this.setOpacity(this.options.opacity),
                    t.fire("tooltipopen", {
                        tooltip: this
                    }),
                    this._source && (this.addEventParent(this._source),
                    this._source.fire("tooltipopen", {
                        tooltip: this
                    }, !0))
                },
                onRemove: function(t) {
                    pn.prototype.onRemove.call(this, t),
                    t.fire("tooltipclose", {
                        tooltip: this
                    }),
                    this._source && (this.removeEventParent(this._source),
                    this._source.fire("tooltipclose", {
                        tooltip: this
                    }, !0))
                },
                getEvents: function() {
                    var t = pn.prototype.getEvents.call(this);
                    return this.options.permanent || (t.preclick = this.close),
                    t
                },
                _initLayout: function() {
                    var t = "leaflet-tooltip"
                      , s = t + " " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
                    this._contentNode = this._container = Ke("div", s),
                    this._container.setAttribute("role", "tooltip"),
                    this._container.setAttribute("id", "leaflet-tooltip-" + f(this))
                },
                _updateLayout: function() {},
                _adjustPan: function() {},
                _setPosition: function(t) {
                    var s, c, p = this._map, E = this._container, k = p.latLngToContainerPoint(p.getCenter()), ne = p.layerPointToContainerPoint(t), he = this.options.direction, ye = E.offsetWidth, Le = E.offsetHeight, Ce = I(this.options.offset), je = this._getAnchor();
                    he === "top" ? (s = ye / 2,
                    c = Le) : he === "bottom" ? (s = ye / 2,
                    c = 0) : he === "center" ? (s = ye / 2,
                    c = Le / 2) : he === "right" ? (s = 0,
                    c = Le / 2) : he === "left" ? (s = ye,
                    c = Le / 2) : ne.x < k.x ? (he = "right",
                    s = 0,
                    c = Le / 2) : (he = "left",
                    s = ye + (Ce.x + je.x) * 2,
                    c = Le / 2),
                    t = t.subtract(I(s, c, !0)).add(Ce).add(je),
                    pt(E, "leaflet-tooltip-right"),
                    pt(E, "leaflet-tooltip-left"),
                    pt(E, "leaflet-tooltip-top"),
                    pt(E, "leaflet-tooltip-bottom"),
                    Ue(E, "leaflet-tooltip-" + he),
                    yt(E, t)
                },
                _updatePosition: function() {
                    var t = this._map.latLngToLayerPoint(this._latlng);
                    this._setPosition(t)
                },
                setOpacity: function(t) {
                    this.options.opacity = t,
                    this._container && Ht(this._container, t)
                },
                _animateZoom: function(t) {
                    var s = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
                    this._setPosition(s)
                },
                _getAnchor: function() {
                    return I(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0])
                }
            })
              , eg = function(t, s) {
                return new us(t,s)
            };
            Xe.include({
                openTooltip: function(t, s, c) {
                    return this._initOverlay(us, t, s, c).openOn(this),
                    this
                },
                closeTooltip: function(t) {
                    return t.close(),
                    this
                }
            }),
            nn.include({
                bindTooltip: function(t, s) {
                    return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(),
                    this._tooltip = this._initOverlay(us, this._tooltip, t, s),
                    this._initTooltipInteractions(),
                    this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(),
                    this
                },
                unbindTooltip: function() {
                    return this._tooltip && (this._initTooltipInteractions(!0),
                    this.closeTooltip(),
                    this._tooltip = null),
                    this
                },
                _initTooltipInteractions: function(t) {
                    if (!(!t && this._tooltipHandlersAdded)) {
                        var s = t ? "off" : "on"
                          , c = {
                            remove: this.closeTooltip,
                            move: this._moveTooltip
                        };
                        this._tooltip.options.permanent ? c.add = this._openTooltip : (c.mouseover = this._openTooltip,
                        c.mouseout = this.closeTooltip,
                        c.click = this._openTooltip,
                        this._map ? this._addFocusListeners() : c.add = this._addFocusListeners),
                        this._tooltip.options.sticky && (c.mousemove = this._moveTooltip),
                        this[s](c),
                        this._tooltipHandlersAdded = !t
                    }
                },
                openTooltip: function(t) {
                    return this._tooltip && (this instanceof wn || (this._tooltip._source = this),
                    this._tooltip._prepareOpen(t) && (this._tooltip.openOn(this._map),
                    this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))),
                    this
                },
                closeTooltip: function() {
                    if (this._tooltip)
                        return this._tooltip.close()
                },
                toggleTooltip: function() {
                    return this._tooltip && this._tooltip.toggle(this),
                    this
                },
                isTooltipOpen: function() {
                    return this._tooltip.isOpen()
                },
                setTooltipContent: function(t) {
                    return this._tooltip && this._tooltip.setContent(t),
                    this
                },
                getTooltip: function() {
                    return this._tooltip
                },
                _addFocusListeners: function() {
                    this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this)
                },
                _addFocusListenersOnLayer: function(t) {
                    var s = typeof t.getElement == "function" && t.getElement();
                    s && (qe(s, "focus", function() {
                        this._tooltip._source = t,
                        this.openTooltip()
                    }, this),
                    qe(s, "blur", this.closeTooltip, this))
                },
                _setAriaDescribedByOnLayer: function(t) {
                    var s = typeof t.getElement == "function" && t.getElement();
                    s && s.setAttribute("aria-describedby", this._tooltip._container.id)
                },
                _openTooltip: function(t) {
                    if (!(!this._tooltip || !this._map)) {
                        if (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag) {
                            this._openOnceFlag = !0;
                            var s = this;
                            this._map.once("moveend", function() {
                                s._openOnceFlag = !1,
                                s._openTooltip(t)
                            });
                            return
                        }
                        this._tooltip._source = t.layer || t.target,
                        this.openTooltip(this._tooltip.options.sticky ? t.latlng : void 0)
                    }
                },
                _moveTooltip: function(t) {
                    var s = t.latlng, c, p;
                    this._tooltip.options.sticky && t.originalEvent && (c = this._map.mouseEventToContainerPoint(t.originalEvent),
                    p = this._map.containerPointToLayerPoint(c),
                    s = this._map.layerPointToLatLng(p)),
                    this._tooltip.setLatLng(s)
                }
            });
            var Du = Ni.extend({
                options: {
                    iconSize: [12, 12],
                    html: !1,
                    bgPos: null,
                    className: "leaflet-div-icon"
                },
                createIcon: function(t) {
                    var s = t && t.tagName === "DIV" ? t : document.createElement("div")
                      , c = this.options;
                    if (c.html instanceof Element ? (Xr(s),
                    s.appendChild(c.html)) : s.innerHTML = c.html !== !1 ? c.html : "",
                    c.bgPos) {
                        var p = I(c.bgPos);
                        s.style.backgroundPosition = -p.x + "px " + -p.y + "px"
                    }
                    return this._setIconStyles(s, "icon"),
                    s
                },
                createShadow: function() {
                    return null
                }
            });
            function tg(t) {
                return new Du(t)
            }
            Ni.Default = sr;
            var or = nn.extend({
                options: {
                    tileSize: 256,
                    opacity: 1,
                    updateWhenIdle: Pe.mobile,
                    updateWhenZooming: !0,
                    updateInterval: 200,
                    zIndex: 1,
                    bounds: null,
                    minZoom: 0,
                    maxZoom: void 0,
                    maxNativeZoom: void 0,
                    minNativeZoom: void 0,
                    noWrap: !1,
                    pane: "tilePane",
                    className: "",
                    keepBuffer: 2
                },
                initialize: function(t) {
                    T(this, t)
                },
                onAdd: function() {
                    this._initContainer(),
                    this._levels = {},
                    this._tiles = {},
                    this._resetView()
                },
                beforeAdd: function(t) {
                    t._addZoomLimit(this)
                },
                onRemove: function(t) {
                    this._removeAllTiles(),
                    ut(this._container),
                    t._removeZoomLimit(this),
                    this._container = null,
                    this._tileZoom = void 0
                },
                bringToFront: function() {
                    return this._map && (Ti(this._container),
                    this._setAutoZIndex(Math.max)),
                    this
                },
                bringToBack: function() {
                    return this._map && (Li(this._container),
                    this._setAutoZIndex(Math.min)),
                    this
                },
                getContainer: function() {
                    return this._container
                },
                setOpacity: function(t) {
                    return this.options.opacity = t,
                    this._updateOpacity(),
                    this
                },
                setZIndex: function(t) {
                    return this.options.zIndex = t,
                    this._updateZIndex(),
                    this
                },
                isLoading: function() {
                    return this._loading
                },
                redraw: function() {
                    if (this._map) {
                        this._removeAllTiles();
                        var t = this._clampZoom(this._map.getZoom());
                        t !== this._tileZoom && (this._tileZoom = t,
                        this._updateLevels()),
                        this._update()
                    }
                    return this
                },
                getEvents: function() {
                    var t = {
                        viewprereset: this._invalidateAll,
                        viewreset: this._resetView,
                        zoom: this._resetView,
                        moveend: this._onMoveEnd
                    };
                    return this.options.updateWhenIdle || (this._onMove || (this._onMove = h(this._onMoveEnd, this.options.updateInterval, this)),
                    t.move = this._onMove),
                    this._zoomAnimated && (t.zoomanim = this._animateZoom),
                    t
                },
                createTile: function() {
                    return document.createElement("div")
                },
                getTileSize: function() {
                    var t = this.options.tileSize;
                    return t instanceof j ? t : new j(t,t)
                },
                _updateZIndex: function() {
                    this._container && this.options.zIndex !== void 0 && this.options.zIndex !== null && (this._container.style.zIndex = this.options.zIndex)
                },
                _setAutoZIndex: function(t) {
                    for (var s = this.getPane().children, c = -t(-1 / 0, 1 / 0), p = 0, E = s.length, k; p < E; p++)
                        k = s[p].style.zIndex,
                        s[p] !== this._container && k && (c = t(c, +k));
                    isFinite(c) && (this.options.zIndex = c + t(-1, 1),
                    this._updateZIndex())
                },
                _updateOpacity: function() {
                    if (this._map && !Pe.ielt9) {
                        Ht(this._container, this.options.opacity);
                        var t = +new Date
                          , s = !1
                          , c = !1;
                        for (var p in this._tiles) {
                            var E = this._tiles[p];
                            if (!(!E.current || !E.loaded)) {
                                var k = Math.min(1, (t - E.loaded) / 200);
                                Ht(E.el, k),
                                k < 1 ? s = !0 : (E.active ? c = !0 : this._onOpaqueTile(E),
                                E.active = !0)
                            }
                        }
                        c && !this._noPrune && this._pruneTiles(),
                        s && (X(this._fadeFrame),
                        this._fadeFrame = $(this._updateOpacity, this))
                    }
                },
                _onOpaqueTile: _,
                _initContainer: function() {
                    this._container || (this._container = Ke("div", "leaflet-layer " + (this.options.className || "")),
                    this._updateZIndex(),
                    this.options.opacity < 1 && this._updateOpacity(),
                    this.getPane().appendChild(this._container))
                },
                _updateLevels: function() {
                    var t = this._tileZoom
                      , s = this.options.maxZoom;
                    if (t !== void 0) {
                        for (var c in this._levels)
                            c = Number(c),
                            this._levels[c].el.children.length || c === t ? (this._levels[c].el.style.zIndex = s - Math.abs(t - c),
                            this._onUpdateLevel(c)) : (ut(this._levels[c].el),
                            this._removeTilesAtZoom(c),
                            this._onRemoveLevel(c),
                            delete this._levels[c]);
                        var p = this._levels[t]
                          , E = this._map;
                        return p || (p = this._levels[t] = {},
                        p.el = Ke("div", "leaflet-tile-container leaflet-zoom-animated", this._container),
                        p.el.style.zIndex = s,
                        p.origin = E.project(E.unproject(E.getPixelOrigin()), t).round(),
                        p.zoom = t,
                        this._setZoomTransform(p, E.getCenter(), E.getZoom()),
                        _(p.el.offsetWidth),
                        this._onCreateLevel(p)),
                        this._level = p,
                        p
                    }
                },
                _onUpdateLevel: _,
                _onRemoveLevel: _,
                _onCreateLevel: _,
                _pruneTiles: function() {
                    if (this._map) {
                        var t, s, c = this._map.getZoom();
                        if (c > this.options.maxZoom || c < this.options.minZoom) {
                            this._removeAllTiles();
                            return
                        }
                        for (t in this._tiles)
                            s = this._tiles[t],
                            s.retain = s.current;
                        for (t in this._tiles)
                            if (s = this._tiles[t],
                            s.current && !s.active) {
                                var p = s.coords;
                                this._retainParent(p.x, p.y, p.z, p.z - 5) || this._retainChildren(p.x, p.y, p.z, p.z + 2)
                            }
                        for (t in this._tiles)
                            this._tiles[t].retain || this._removeTile(t)
                    }
                },
                _removeTilesAtZoom: function(t) {
                    for (var s in this._tiles)
                        this._tiles[s].coords.z === t && this._removeTile(s)
                },
                _removeAllTiles: function() {
                    for (var t in this._tiles)
                        this._removeTile(t)
                },
                _invalidateAll: function() {
                    for (var t in this._levels)
                        ut(this._levels[t].el),
                        this._onRemoveLevel(Number(t)),
                        delete this._levels[t];
                    this._removeAllTiles(),
                    this._tileZoom = void 0
                },
                _retainParent: function(t, s, c, p) {
                    var E = Math.floor(t / 2)
                      , k = Math.floor(s / 2)
                      , ne = c - 1
                      , he = new j(+E,+k);
                    he.z = +ne;
                    var ye = this._tileCoordsToKey(he)
                      , Le = this._tiles[ye];
                    return Le && Le.active ? (Le.retain = !0,
                    !0) : (Le && Le.loaded && (Le.retain = !0),
                    ne > p ? this._retainParent(E, k, ne, p) : !1)
                },
                _retainChildren: function(t, s, c, p) {
                    for (var E = 2 * t; E < 2 * t + 2; E++)
                        for (var k = 2 * s; k < 2 * s + 2; k++) {
                            var ne = new j(E,k);
                            ne.z = c + 1;
                            var he = this._tileCoordsToKey(ne)
                              , ye = this._tiles[he];
                            if (ye && ye.active) {
                                ye.retain = !0;
                                continue
                            } else
                                ye && ye.loaded && (ye.retain = !0);
                            c + 1 < p && this._retainChildren(E, k, c + 1, p)
                        }
                },
                _resetView: function(t) {
                    var s = t && (t.pinch || t.flyTo);
                    this._setView(this._map.getCenter(), this._map.getZoom(), s, s)
                },
                _animateZoom: function(t) {
                    this._setView(t.center, t.zoom, !0, t.noUpdate)
                },
                _clampZoom: function(t) {
                    var s = this.options;
                    return s.minNativeZoom !== void 0 && t < s.minNativeZoom ? s.minNativeZoom : s.maxNativeZoom !== void 0 && s.maxNativeZoom < t ? s.maxNativeZoom : t
                },
                _setView: function(t, s, c, p) {
                    var E = Math.round(s);
                    this.options.maxZoom !== void 0 && E > this.options.maxZoom || this.options.minZoom !== void 0 && E < this.options.minZoom ? E = void 0 : E = this._clampZoom(E);
                    var k = this.options.updateWhenZooming && E !== this._tileZoom;
                    (!p || k) && (this._tileZoom = E,
                    this._abortLoading && this._abortLoading(),
                    this._updateLevels(),
                    this._resetGrid(),
                    E !== void 0 && this._update(t),
                    c || this._pruneTiles(),
                    this._noPrune = !!c),
                    this._setZoomTransforms(t, s)
                },
                _setZoomTransforms: function(t, s) {
                    for (var c in this._levels)
                        this._setZoomTransform(this._levels[c], t, s)
                },
                _setZoomTransform: function(t, s, c) {
                    var p = this._map.getZoomScale(c, t.zoom)
                      , E = t.origin.multiplyBy(p).subtract(this._map._getNewPixelOrigin(s, c)).round();
                    Pe.any3d ? Jn(t.el, E, p) : yt(t.el, E)
                },
                _resetGrid: function() {
                    var t = this._map
                      , s = t.options.crs
                      , c = this._tileSize = this.getTileSize()
                      , p = this._tileZoom
                      , E = this._map.getPixelWorldBounds(this._tileZoom);
                    E && (this._globalTileRange = this._pxBoundsToTileRange(E)),
                    this._wrapX = s.wrapLng && !this.options.noWrap && [Math.floor(t.project([0, s.wrapLng[0]], p).x / c.x), Math.ceil(t.project([0, s.wrapLng[1]], p).x / c.y)],
                    this._wrapY = s.wrapLat && !this.options.noWrap && [Math.floor(t.project([s.wrapLat[0], 0], p).y / c.x), Math.ceil(t.project([s.wrapLat[1], 0], p).y / c.y)]
                },
                _onMoveEnd: function() {
                    !this._map || this._map._animatingZoom || this._update()
                },
                _getTiledPixelBounds: function(t) {
                    var s = this._map
                      , c = s._animatingZoom ? Math.max(s._animateToZoom, s.getZoom()) : s.getZoom()
                      , p = s.getZoomScale(c, this._tileZoom)
                      , E = s.project(t, this._tileZoom).floor()
                      , k = s.getSize().divideBy(p * 2);
                    return new Z(E.subtract(k),E.add(k))
                },
                _update: function(t) {
                    var s = this._map;
                    if (s) {
                        var c = this._clampZoom(s.getZoom());
                        if (t === void 0 && (t = s.getCenter()),
                        this._tileZoom !== void 0) {
                            var p = this._getTiledPixelBounds(t)
                              , E = this._pxBoundsToTileRange(p)
                              , k = E.getCenter()
                              , ne = []
                              , he = this.options.keepBuffer
                              , ye = new Z(E.getBottomLeft().subtract([he, -he]),E.getTopRight().add([he, -he]));
                            if (!(isFinite(E.min.x) && isFinite(E.min.y) && isFinite(E.max.x) && isFinite(E.max.y)))
                                throw new Error("Attempted to load an infinite number of tiles");
                            for (var Le in this._tiles) {
                                var Ce = this._tiles[Le].coords;
                                (Ce.z !== this._tileZoom || !ye.contains(new j(Ce.x,Ce.y))) && (this._tiles[Le].current = !1)
                            }
                            if (Math.abs(c - this._tileZoom) > 1) {
                                this._setView(t, c);
                                return
                            }
                            for (var je = E.min.y; je <= E.max.y; je++)
                                for (var Ve = E.min.x; Ve <= E.max.x; Ve++) {
                                    var At = new j(Ve,je);
                                    if (At.z = this._tileZoom,
                                    !!this._isValidTile(At)) {
                                        var xt = this._tiles[this._tileCoordsToKey(At)];
                                        xt ? xt.current = !0 : ne.push(At)
                                    }
                                }
                            if (ne.sort(function(Mt, ki) {
                                return Mt.distanceTo(k) - ki.distanceTo(k)
                            }),
                            ne.length !== 0) {
                                this._loading || (this._loading = !0,
                                this.fire("loading"));
                                var Gt = document.createDocumentFragment();
                                for (Ve = 0; Ve < ne.length; Ve++)
                                    this._addTile(ne[Ve], Gt);
                                this._level.el.appendChild(Gt)
                            }
                        }
                    }
                },
                _isValidTile: function(t) {
                    var s = this._map.options.crs;
                    if (!s.infinite) {
                        var c = this._globalTileRange;
                        if (!s.wrapLng && (t.x < c.min.x || t.x > c.max.x) || !s.wrapLat && (t.y < c.min.y || t.y > c.max.y))
                            return !1
                    }
                    if (!this.options.bounds)
                        return !0;
                    var p = this._tileCoordsToBounds(t);
                    return me(this.options.bounds).overlaps(p)
                },
                _keyToBounds: function(t) {
                    return this._tileCoordsToBounds(this._keyToTileCoords(t))
                },
                _tileCoordsToNwSe: function(t) {
                    var s = this._map
                      , c = this.getTileSize()
                      , p = t.scaleBy(c)
                      , E = p.add(c)
                      , k = s.unproject(p, t.z)
                      , ne = s.unproject(E, t.z);
                    return [k, ne]
                },
                _tileCoordsToBounds: function(t) {
                    var s = this._tileCoordsToNwSe(t)
                      , c = new ee(s[0],s[1]);
                    return this.options.noWrap || (c = this._map.wrapLatLngBounds(c)),
                    c
                },
                _tileCoordsToKey: function(t) {
                    return t.x + ":" + t.y + ":" + t.z
                },
                _keyToTileCoords: function(t) {
                    var s = t.split(":")
                      , c = new j(+s[0],+s[1]);
                    return c.z = +s[2],
                    c
                },
                _removeTile: function(t) {
                    var s = this._tiles[t];
                    s && (ut(s.el),
                    delete this._tiles[t],
                    this.fire("tileunload", {
                        tile: s.el,
                        coords: this._keyToTileCoords(t)
                    }))
                },
                _initTile: function(t) {
                    Ue(t, "leaflet-tile");
                    var s = this.getTileSize();
                    t.style.width = s.x + "px",
                    t.style.height = s.y + "px",
                    t.onselectstart = _,
                    t.onmousemove = _,
                    Pe.ielt9 && this.options.opacity < 1 && Ht(t, this.options.opacity)
                },
                _addTile: function(t, s) {
                    var c = this._getTilePos(t)
                      , p = this._tileCoordsToKey(t)
                      , E = this.createTile(this._wrapCoords(t), l(this._tileReady, this, t));
                    this._initTile(E),
                    this.createTile.length < 2 && $(l(this._tileReady, this, t, null, E)),
                    yt(E, c),
                    this._tiles[p] = {
                        el: E,
                        coords: t,
                        current: !0
                    },
                    s.appendChild(E),
                    this.fire("tileloadstart", {
                        tile: E,
                        coords: t
                    })
                },
                _tileReady: function(t, s, c) {
                    s && this.fire("tileerror", {
                        error: s,
                        tile: c,
                        coords: t
                    });
                    var p = this._tileCoordsToKey(t);
                    c = this._tiles[p],
                    c && (c.loaded = +new Date,
                    this._map._fadeAnimated ? (Ht(c.el, 0),
                    X(this._fadeFrame),
                    this._fadeFrame = $(this._updateOpacity, this)) : (c.active = !0,
                    this._pruneTiles()),
                    s || (Ue(c.el, "leaflet-tile-loaded"),
                    this.fire("tileload", {
                        tile: c.el,
                        coords: t
                    })),
                    this._noTilesToLoad() && (this._loading = !1,
                    this.fire("load"),
                    Pe.ielt9 || !this._map._fadeAnimated ? $(this._pruneTiles, this) : setTimeout(l(this._pruneTiles, this), 250)))
                },
                _getTilePos: function(t) {
                    return t.scaleBy(this.getTileSize()).subtract(this._level.origin)
                },
                _wrapCoords: function(t) {
                    var s = new j(this._wrapX ? m(t.x, this._wrapX) : t.x,this._wrapY ? m(t.y, this._wrapY) : t.y);
                    return s.z = t.z,
                    s
                },
                _pxBoundsToTileRange: function(t) {
                    var s = this.getTileSize();
                    return new Z(t.min.unscaleBy(s).floor(),t.max.unscaleBy(s).ceil().subtract([1, 1]))
                },
                _noTilesToLoad: function() {
                    for (var t in this._tiles)
                        if (!this._tiles[t].loaded)
                            return !1;
                    return !0
                }
            });
            function ng(t) {
                return new or(t)
            }
            var Ci = or.extend({
                options: {
                    minZoom: 0,
                    maxZoom: 18,
                    subdomains: "abc",
                    errorTileUrl: "",
                    zoomOffset: 0,
                    tms: !1,
                    zoomReverse: !1,
                    detectRetina: !1,
                    crossOrigin: !1,
                    referrerPolicy: !1
                },
                initialize: function(t, s) {
                    this._url = t,
                    s = T(this, s),
                    s.detectRetina && Pe.retina && s.maxZoom > 0 ? (s.tileSize = Math.floor(s.tileSize / 2),
                    s.zoomReverse ? (s.zoomOffset--,
                    s.minZoom = Math.min(s.maxZoom, s.minZoom + 1)) : (s.zoomOffset++,
                    s.maxZoom = Math.max(s.minZoom, s.maxZoom - 1)),
                    s.minZoom = Math.max(0, s.minZoom)) : s.zoomReverse ? s.minZoom = Math.min(s.maxZoom, s.minZoom) : s.maxZoom = Math.max(s.minZoom, s.maxZoom),
                    typeof s.subdomains == "string" && (s.subdomains = s.subdomains.split("")),
                    this.on("tileunload", this._onTileRemove)
                },
                setUrl: function(t, s) {
                    return this._url === t && s === void 0 && (s = !0),
                    this._url = t,
                    s || this.redraw(),
                    this
                },
                createTile: function(t, s) {
                    var c = document.createElement("img");
                    return qe(c, "load", l(this._tileOnLoad, this, s, c)),
                    qe(c, "error", l(this._tileOnError, this, s, c)),
                    (this.options.crossOrigin || this.options.crossOrigin === "") && (c.crossOrigin = this.options.crossOrigin === !0 ? "" : this.options.crossOrigin),
                    typeof this.options.referrerPolicy == "string" && (c.referrerPolicy = this.options.referrerPolicy),
                    c.alt = "",
                    c.src = this.getTileUrl(t),
                    c
                },
                getTileUrl: function(t) {
                    var s = {
                        r: Pe.retina ? "@2x" : "",
                        s: this._getSubdomain(t),
                        x: t.x,
                        y: t.y,
                        z: this._getZoomForUrl()
                    };
                    if (this._map && !this._map.options.crs.infinite) {
                        var c = this._globalTileRange.max.y - t.y;
                        this.options.tms && (s.y = c),
                        s["-y"] = c
                    }
                    return R(this._url, o(s, this.options))
                },
                _tileOnLoad: function(t, s) {
                    Pe.ielt9 ? setTimeout(l(t, this, null, s), 0) : t(null, s)
                },
                _tileOnError: function(t, s, c) {
                    var p = this.options.errorTileUrl;
                    p && s.getAttribute("src") !== p && (s.src = p),
                    t(c, s)
                },
                _onTileRemove: function(t) {
                    t.tile.onload = null
                },
                _getZoomForUrl: function() {
                    var t = this._tileZoom
                      , s = this.options.maxZoom
                      , c = this.options.zoomReverse
                      , p = this.options.zoomOffset;
                    return c && (t = s - t),
                    t + p
                },
                _getSubdomain: function(t) {
                    var s = Math.abs(t.x + t.y) % this.options.subdomains.length;
                    return this.options.subdomains[s]
                },
                _abortLoading: function() {
                    var t, s;
                    for (t in this._tiles)
                        if (this._tiles[t].coords.z !== this._tileZoom && (s = this._tiles[t].el,
                        s.onload = _,
                        s.onerror = _,
                        !s.complete)) {
                            s.src = x;
                            var c = this._tiles[t].coords;
                            ut(s),
                            delete this._tiles[t],
                            this.fire("tileabort", {
                                tile: s,
                                coords: c
                            })
                        }
                },
                _removeTile: function(t) {
                    var s = this._tiles[t];
                    if (s)
                        return s.el.setAttribute("src", x),
                        or.prototype._removeTile.call(this, t)
                },
                _tileReady: function(t, s, c) {
                    if (!(!this._map || c && c.getAttribute("src") === x))
                        return or.prototype._tileReady.call(this, t, s, c)
                }
            });
            function Ou(t, s) {
                return new Ci(t,s)
            }
            var Fu = Ci.extend({
                defaultWmsParams: {
                    service: "WMS",
                    request: "GetMap",
                    layers: "",
                    styles: "",
                    format: "image/jpeg",
                    transparent: !1,
                    version: "1.1.1"
                },
                options: {
                    crs: null,
                    uppercase: !1
                },
                initialize: function(t, s) {
                    this._url = t;
                    var c = o({}, this.defaultWmsParams);
                    for (var p in s)
                        p in this.options || (c[p] = s[p]);
                    s = T(this, s);
                    var E = s.detectRetina && Pe.retina ? 2 : 1
                      , k = this.getTileSize();
                    c.width = k.x * E,
                    c.height = k.y * E,
                    this.wmsParams = c
                },
                onAdd: function(t) {
                    this._crs = this.options.crs || t.options.crs,
                    this._wmsVersion = parseFloat(this.wmsParams.version);
                    var s = this._wmsVersion >= 1.3 ? "crs" : "srs";
                    this.wmsParams[s] = this._crs.code,
                    Ci.prototype.onAdd.call(this, t)
                },
                getTileUrl: function(t) {
                    var s = this._tileCoordsToNwSe(t)
                      , c = this._crs
                      , p = ie(c.project(s[0]), c.project(s[1]))
                      , E = p.min
                      , k = p.max
                      , ne = (this._wmsVersion >= 1.3 && this._crs === Au ? [E.y, E.x, k.y, k.x] : [E.x, E.y, k.x, k.y]).join(",")
                      , he = Ci.prototype.getTileUrl.call(this, t);
                    return he + N(this.wmsParams, he, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + ne
                },
                setParams: function(t, s) {
                    return o(this.wmsParams, t),
                    s || this.redraw(),
                    this
                }
            });
            function ig(t, s) {
                return new Fu(t,s)
            }
            Ci.WMS = Fu,
            Ou.wms = ig;
            var Sn = nn.extend({
                options: {
                    padding: .1
                },
                initialize: function(t) {
                    T(this, t),
                    f(this),
                    this._layers = this._layers || {}
                },
                onAdd: function() {
                    this._container || (this._initContainer(),
                    Ue(this._container, "leaflet-zoom-animated")),
                    this.getPane().appendChild(this._container),
                    this._update(),
                    this.on("update", this._updatePaths, this)
                },
                onRemove: function() {
                    this.off("update", this._updatePaths, this),
                    this._destroyContainer()
                },
                getEvents: function() {
                    var t = {
                        viewreset: this._reset,
                        zoom: this._onZoom,
                        moveend: this._update,
                        zoomend: this._onZoomEnd
                    };
                    return this._zoomAnimated && (t.zoomanim = this._onAnimZoom),
                    t
                },
                _onAnimZoom: function(t) {
                    this._updateTransform(t.center, t.zoom)
                },
                _onZoom: function() {
                    this._updateTransform(this._map.getCenter(), this._map.getZoom())
                },
                _updateTransform: function(t, s) {
                    var c = this._map.getZoomScale(s, this._zoom)
                      , p = this._map.getSize().multiplyBy(.5 + this.options.padding)
                      , E = this._map.project(this._center, s)
                      , k = p.multiplyBy(-c).add(E).subtract(this._map._getNewPixelOrigin(t, s));
                    Pe.any3d ? Jn(this._container, k, c) : yt(this._container, k)
                },
                _reset: function() {
                    this._update(),
                    this._updateTransform(this._center, this._zoom);
                    for (var t in this._layers)
                        this._layers[t]._reset()
                },
                _onZoomEnd: function() {
                    for (var t in this._layers)
                        this._layers[t]._project()
                },
                _updatePaths: function() {
                    for (var t in this._layers)
                        this._layers[t]._update()
                },
                _update: function() {
                    var t = this.options.padding
                      , s = this._map.getSize()
                      , c = this._map.containerPointToLayerPoint(s.multiplyBy(-t)).round();
                    this._bounds = new Z(c,c.add(s.multiplyBy(1 + t * 2)).round()),
                    this._center = this._map.getCenter(),
                    this._zoom = this._map.getZoom()
                }
            })
              , ju = Sn.extend({
                options: {
                    tolerance: 0
                },
                getEvents: function() {
                    var t = Sn.prototype.getEvents.call(this);
                    return t.viewprereset = this._onViewPreReset,
                    t
                },
                _onViewPreReset: function() {
                    this._postponeUpdatePaths = !0
                },
                onAdd: function() {
                    Sn.prototype.onAdd.call(this),
                    this._draw()
                },
                _initContainer: function() {
                    var t = this._container = document.createElement("canvas");
                    qe(t, "mousemove", this._onMouseMove, this),
                    qe(t, "click dblclick mousedown mouseup contextmenu", this._onClick, this),
                    qe(t, "mouseout", this._handleMouseOut, this),
                    t._leaflet_disable_events = !0,
                    this._ctx = t.getContext("2d")
                },
                _destroyContainer: function() {
                    X(this._redrawRequest),
                    delete this._ctx,
                    ut(this._container),
                    rt(this._container),
                    delete this._container
                },
                _updatePaths: function() {
                    if (!this._postponeUpdatePaths) {
                        var t;
                        this._redrawBounds = null;
                        for (var s in this._layers)
                            t = this._layers[s],
                            t._update();
                        this._redraw()
                    }
                },
                _update: function() {
                    if (!(this._map._animatingZoom && this._bounds)) {
                        Sn.prototype._update.call(this);
                        var t = this._bounds
                          , s = this._container
                          , c = t.getSize()
                          , p = Pe.retina ? 2 : 1;
                        yt(s, t.min),
                        s.width = p * c.x,
                        s.height = p * c.y,
                        s.style.width = c.x + "px",
                        s.style.height = c.y + "px",
                        Pe.retina && this._ctx.scale(2, 2),
                        this._ctx.translate(-t.min.x, -t.min.y),
                        this.fire("update")
                    }
                },
                _reset: function() {
                    Sn.prototype._reset.call(this),
                    this._postponeUpdatePaths && (this._postponeUpdatePaths = !1,
                    this._updatePaths())
                },
                _initPath: function(t) {
                    this._updateDashArray(t),
                    this._layers[f(t)] = t;
                    var s = t._order = {
                        layer: t,
                        prev: this._drawLast,
                        next: null
                    };
                    this._drawLast && (this._drawLast.next = s),
                    this._drawLast = s,
                    this._drawFirst = this._drawFirst || this._drawLast
                },
                _addPath: function(t) {
                    this._requestRedraw(t)
                },
                _removePath: function(t) {
                    var s = t._order
                      , c = s.next
                      , p = s.prev;
                    c ? c.prev = p : this._drawLast = p,
                    p ? p.next = c : this._drawFirst = c,
                    delete t._order,
                    delete this._layers[f(t)],
                    this._requestRedraw(t)
                },
                _updatePath: function(t) {
                    this._extendRedrawBounds(t),
                    t._project(),
                    t._update(),
                    this._requestRedraw(t)
                },
                _updateStyle: function(t) {
                    this._updateDashArray(t),
                    this._requestRedraw(t)
                },
                _updateDashArray: function(t) {
                    if (typeof t.options.dashArray == "string") {
                        var s = t.options.dashArray.split(/[, ]+/), c = [], p, E;
                        for (E = 0; E < s.length; E++) {
                            if (p = Number(s[E]),
                            isNaN(p))
                                return;
                            c.push(p)
                        }
                        t.options._dashArray = c
                    } else
                        t.options._dashArray = t.options.dashArray
                },
                _requestRedraw: function(t) {
                    this._map && (this._extendRedrawBounds(t),
                    this._redrawRequest = this._redrawRequest || $(this._redraw, this))
                },
                _extendRedrawBounds: function(t) {
                    if (t._pxBounds) {
                        var s = (t.options.weight || 0) + 1;
                        this._redrawBounds = this._redrawBounds || new Z,
                        this._redrawBounds.extend(t._pxBounds.min.subtract([s, s])),
                        this._redrawBounds.extend(t._pxBounds.max.add([s, s]))
                    }
                },
                _redraw: function() {
                    this._redrawRequest = null,
                    this._redrawBounds && (this._redrawBounds.min._floor(),
                    this._redrawBounds.max._ceil()),
                    this._clear(),
                    this._draw(),
                    this._redrawBounds = null
                },
                _clear: function() {
                    var t = this._redrawBounds;
                    if (t) {
                        var s = t.getSize();
                        this._ctx.clearRect(t.min.x, t.min.y, s.x, s.y)
                    } else
                        this._ctx.save(),
                        this._ctx.setTransform(1, 0, 0, 1, 0, 0),
                        this._ctx.clearRect(0, 0, this._container.width, this._container.height),
                        this._ctx.restore()
                },
                _draw: function() {
                    var t, s = this._redrawBounds;
                    if (this._ctx.save(),
                    s) {
                        var c = s.getSize();
                        this._ctx.beginPath(),
                        this._ctx.rect(s.min.x, s.min.y, c.x, c.y),
                        this._ctx.clip()
                    }
                    this._drawing = !0;
                    for (var p = this._drawFirst; p; p = p.next)
                        t = p.layer,
                        (!s || t._pxBounds && t._pxBounds.intersects(s)) && t._updatePath();
                    this._drawing = !1,
                    this._ctx.restore()
                },
                _updatePoly: function(t, s) {
                    if (this._drawing) {
                        var c, p, E, k, ne = t._parts, he = ne.length, ye = this._ctx;
                        if (he) {
                            for (ye.beginPath(),
                            c = 0; c < he; c++) {
                                for (p = 0,
                                E = ne[c].length; p < E; p++)
                                    k = ne[c][p],
                                    ye[p ? "lineTo" : "moveTo"](k.x, k.y);
                                s && ye.closePath()
                            }
                            this._fillStroke(ye, t)
                        }
                    }
                },
                _updateCircle: function(t) {
                    if (!(!this._drawing || t._empty())) {
                        var s = t._point
                          , c = this._ctx
                          , p = Math.max(Math.round(t._radius), 1)
                          , E = (Math.max(Math.round(t._radiusY), 1) || p) / p;
                        E !== 1 && (c.save(),
                        c.scale(1, E)),
                        c.beginPath(),
                        c.arc(s.x, s.y / E, p, 0, Math.PI * 2, !1),
                        E !== 1 && c.restore(),
                        this._fillStroke(c, t)
                    }
                },
                _fillStroke: function(t, s) {
                    var c = s.options;
                    c.fill && (t.globalAlpha = c.fillOpacity,
                    t.fillStyle = c.fillColor || c.color,
                    t.fill(c.fillRule || "evenodd")),
                    c.stroke && c.weight !== 0 && (t.setLineDash && t.setLineDash(s.options && s.options._dashArray || []),
                    t.globalAlpha = c.opacity,
                    t.lineWidth = c.weight,
                    t.strokeStyle = c.color,
                    t.lineCap = c.lineCap,
                    t.lineJoin = c.lineJoin,
                    t.stroke())
                },
                _onClick: function(t) {
                    for (var s = this._map.mouseEventToLayerPoint(t), c, p, E = this._drawFirst; E; E = E.next)
                        c = E.layer,
                        c.options.interactive && c._containsPoint(s) && (!(t.type === "click" || t.type === "preclick") || !this._map._draggableMoved(c)) && (p = c);
                    this._fireEvent(p ? [p] : !1, t)
                },
                _onMouseMove: function(t) {
                    if (!(!this._map || this._map.dragging.moving() || this._map._animatingZoom)) {
                        var s = this._map.mouseEventToLayerPoint(t);
                        this._handleMouseHover(t, s)
                    }
                },
                _handleMouseOut: function(t) {
                    var s = this._hoveredLayer;
                    s && (pt(this._container, "leaflet-interactive"),
                    this._fireEvent([s], t, "mouseout"),
                    this._hoveredLayer = null,
                    this._mouseHoverThrottled = !1)
                },
                _handleMouseHover: function(t, s) {
                    if (!this._mouseHoverThrottled) {
                        for (var c, p, E = this._drawFirst; E; E = E.next)
                            c = E.layer,
                            c.options.interactive && c._containsPoint(s) && (p = c);
                        p !== this._hoveredLayer && (this._handleMouseOut(t),
                        p && (Ue(this._container, "leaflet-interactive"),
                        this._fireEvent([p], t, "mouseover"),
                        this._hoveredLayer = p)),
                        this._fireEvent(this._hoveredLayer ? [this._hoveredLayer] : !1, t),
                        this._mouseHoverThrottled = !0,
                        setTimeout(l(function() {
                            this._mouseHoverThrottled = !1
                        }, this), 32)
                    }
                },
                _fireEvent: function(t, s, c) {
                    this._map._fireDOMEvent(s, c || s.type, t)
                },
                _bringToFront: function(t) {
                    var s = t._order;
                    if (s) {
                        var c = s.next
                          , p = s.prev;
                        if (c)
                            c.prev = p;
                        else
                            return;
                        p ? p.next = c : c && (this._drawFirst = c),
                        s.prev = this._drawLast,
                        this._drawLast.next = s,
                        s.next = null,
                        this._drawLast = s,
                        this._requestRedraw(t)
                    }
                },
                _bringToBack: function(t) {
                    var s = t._order;
                    if (s) {
                        var c = s.next
                          , p = s.prev;
                        if (p)
                            p.next = c;
                        else
                            return;
                        c ? c.prev = p : p && (this._drawLast = p),
                        s.prev = null,
                        s.next = this._drawFirst,
                        this._drawFirst.prev = s,
                        this._drawFirst = s,
                        this._requestRedraw(t)
                    }
                }
            });
            function Bu(t) {
                return Pe.canvas ? new ju(t) : null
            }
            var ar = (function() {
                try {
                    return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"),
                    function(t) {
                        return document.createElement("<lvml:" + t + ' class="lvml">')
                    }
                } catch {}
                return function(t) {
                    return document.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
                }
            }
            )()
              , rg = {
                _initContainer: function() {
                    this._container = Ke("div", "leaflet-vml-container")
                },
                _update: function() {
                    this._map._animatingZoom || (Sn.prototype._update.call(this),
                    this.fire("update"))
                },
                _initPath: function(t) {
                    var s = t._container = ar("shape");
                    Ue(s, "leaflet-vml-shape " + (this.options.className || "")),
                    s.coordsize = "1 1",
                    t._path = ar("path"),
                    s.appendChild(t._path),
                    this._updateStyle(t),
                    this._layers[f(t)] = t
                },
                _addPath: function(t) {
                    var s = t._container;
                    this._container.appendChild(s),
                    t.options.interactive && t.addInteractiveTarget(s)
                },
                _removePath: function(t) {
                    var s = t._container;
                    ut(s),
                    t.removeInteractiveTarget(s),
                    delete this._layers[f(t)]
                },
                _updateStyle: function(t) {
                    var s = t._stroke
                      , c = t._fill
                      , p = t.options
                      , E = t._container;
                    E.stroked = !!p.stroke,
                    E.filled = !!p.fill,
                    p.stroke ? (s || (s = t._stroke = ar("stroke")),
                    E.appendChild(s),
                    s.weight = p.weight + "px",
                    s.color = p.color,
                    s.opacity = p.opacity,
                    p.dashArray ? s.dashStyle = S(p.dashArray) ? p.dashArray.join(" ") : p.dashArray.replace(/( *, *)/g, " ") : s.dashStyle = "",
                    s.endcap = p.lineCap.replace("butt", "flat"),
                    s.joinstyle = p.lineJoin) : s && (E.removeChild(s),
                    t._stroke = null),
                    p.fill ? (c || (c = t._fill = ar("fill")),
                    E.appendChild(c),
                    c.color = p.fillColor || p.color,
                    c.opacity = p.fillOpacity) : c && (E.removeChild(c),
                    t._fill = null)
                },
                _updateCircle: function(t) {
                    var s = t._point.round()
                      , c = Math.round(t._radius)
                      , p = Math.round(t._radiusY || c);
                    this._setPath(t, t._empty() ? "M0 0" : "AL " + s.x + "," + s.y + " " + c + "," + p + " 0," + 65535 * 360)
                },
                _setPath: function(t, s) {
                    t._path.v = s
                },
                _bringToFront: function(t) {
                    Ti(t._container)
                },
                _bringToBack: function(t) {
                    Li(t._container)
                }
            }
              , cs = Pe.vml ? ar : fe
              , lr = Sn.extend({
                _initContainer: function() {
                    this._container = cs("svg"),
                    this._container.setAttribute("pointer-events", "none"),
                    this._rootGroup = cs("g"),
                    this._container.appendChild(this._rootGroup)
                },
                _destroyContainer: function() {
                    ut(this._container),
                    rt(this._container),
                    delete this._container,
                    delete this._rootGroup,
                    delete this._svgSize
                },
                _update: function() {
                    if (!(this._map._animatingZoom && this._bounds)) {
                        Sn.prototype._update.call(this);
                        var t = this._bounds
                          , s = t.getSize()
                          , c = this._container;
                        (!this._svgSize || !this._svgSize.equals(s)) && (this._svgSize = s,
                        c.setAttribute("width", s.x),
                        c.setAttribute("height", s.y)),
                        yt(c, t.min),
                        c.setAttribute("viewBox", [t.min.x, t.min.y, s.x, s.y].join(" ")),
                        this.fire("update")
                    }
                },
                _initPath: function(t) {
                    var s = t._path = cs("path");
                    t.options.className && Ue(s, t.options.className),
                    t.options.interactive && Ue(s, "leaflet-interactive"),
                    this._updateStyle(t),
                    this._layers[f(t)] = t
                },
                _addPath: function(t) {
                    this._rootGroup || this._initContainer(),
                    this._rootGroup.appendChild(t._path),
                    t.addInteractiveTarget(t._path)
                },
                _removePath: function(t) {
                    ut(t._path),
                    t.removeInteractiveTarget(t._path),
                    delete this._layers[f(t)]
                },
                _updatePath: function(t) {
                    t._project(),
                    t._update()
                },
                _updateStyle: function(t) {
                    var s = t._path
                      , c = t.options;
                    s && (c.stroke ? (s.setAttribute("stroke", c.color),
                    s.setAttribute("stroke-opacity", c.opacity),
                    s.setAttribute("stroke-width", c.weight),
                    s.setAttribute("stroke-linecap", c.lineCap),
                    s.setAttribute("stroke-linejoin", c.lineJoin),
                    c.dashArray ? s.setAttribute("stroke-dasharray", c.dashArray) : s.removeAttribute("stroke-dasharray"),
                    c.dashOffset ? s.setAttribute("stroke-dashoffset", c.dashOffset) : s.removeAttribute("stroke-dashoffset")) : s.setAttribute("stroke", "none"),
                    c.fill ? (s.setAttribute("fill", c.fillColor || c.color),
                    s.setAttribute("fill-opacity", c.fillOpacity),
                    s.setAttribute("fill-rule", c.fillRule || "evenodd")) : s.setAttribute("fill", "none"))
                },
                _updatePoly: function(t, s) {
                    this._setPath(t, xe(t._parts, s))
                },
                _updateCircle: function(t) {
                    var s = t._point
                      , c = Math.max(Math.round(t._radius), 1)
                      , p = Math.max(Math.round(t._radiusY), 1) || c
                      , E = "a" + c + "," + p + " 0 1,0 "
                      , k = t._empty() ? "M0 0" : "M" + (s.x - c) + "," + s.y + E + c * 2 + ",0 " + E + -c * 2 + ",0 ";
                    this._setPath(t, k)
                },
                _setPath: function(t, s) {
                    t._path.setAttribute("d", s)
                },
                _bringToFront: function(t) {
                    Ti(t._path)
                },
                _bringToBack: function(t) {
                    Li(t._path)
                }
            });
            Pe.vml && lr.include(rg);
            function $u(t) {
                return Pe.svg || Pe.vml ? new lr(t) : null
            }
            Xe.include({
                getRenderer: function(t) {
                    var s = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer;
                    return s || (s = this._renderer = this._createRenderer()),
                    this.hasLayer(s) || this.addLayer(s),
                    s
                },
                _getPaneRenderer: function(t) {
                    if (t === "overlayPane" || t === void 0)
                        return !1;
                    var s = this._paneRenderers[t];
                    return s === void 0 && (s = this._createRenderer({
                        pane: t
                    }),
                    this._paneRenderers[t] = s),
                    s
                },
                _createRenderer: function(t) {
                    return this.options.preferCanvas && Bu(t) || $u(t)
                }
            });
            var qu = Ai.extend({
                initialize: function(t, s) {
                    Ai.prototype.initialize.call(this, this._boundsToLatLngs(t), s)
                },
                setBounds: function(t) {
                    return this.setLatLngs(this._boundsToLatLngs(t))
                },
                _boundsToLatLngs: function(t) {
                    return t = me(t),
                    [t.getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()]
                }
            });
            function sg(t, s) {
                return new qu(t,s)
            }
            lr.create = cs,
            lr.pointsToPath = xe,
            En.geometryToLayer = is,
            En.coordsToLatLng = Io,
            En.coordsToLatLngs = rs,
            En.latLngToCoords = No,
            En.latLngsToCoords = ss,
            En.getFeature = Ri,
            En.asFeature = os,
            Xe.mergeOptions({
                boxZoom: !0
            });
            var zu = fn.extend({
                initialize: function(t) {
                    this._map = t,
                    this._container = t._container,
                    this._pane = t._panes.overlayPane,
                    this._resetStateTimeout = 0,
                    t.on("unload", this._destroy, this)
                },
                addHooks: function() {
                    qe(this._container, "mousedown", this._onMouseDown, this)
                },
                removeHooks: function() {
                    rt(this._container, "mousedown", this._onMouseDown, this)
                },
                moved: function() {
                    return this._moved
                },
                _destroy: function() {
                    ut(this._pane),
                    delete this._pane
                },
                _resetState: function() {
                    this._resetStateTimeout = 0,
                    this._moved = !1
                },
                _clearDeferredResetState: function() {
                    this._resetStateTimeout !== 0 && (clearTimeout(this._resetStateTimeout),
                    this._resetStateTimeout = 0)
                },
                _onMouseDown: function(t) {
                    if (!t.shiftKey || t.which !== 1 && t.button !== 1)
                        return !1;
                    this._clearDeferredResetState(),
                    this._resetState(),
                    Yi(),
                    uo(),
                    this._startPoint = this._map.mouseEventToContainerPoint(t),
                    qe(document, {
                        contextmenu: ei,
                        mousemove: this._onMouseMove,
                        mouseup: this._onMouseUp,
                        keydown: this._onKeyDown
                    }, this)
                },
                _onMouseMove: function(t) {
                    this._moved || (this._moved = !0,
                    this._box = Ke("div", "leaflet-zoom-box", this._container),
                    Ue(this._container, "leaflet-crosshair"),
                    this._map.fire("boxzoomstart")),
                    this._point = this._map.mouseEventToContainerPoint(t);
                    var s = new Z(this._point,this._startPoint)
                      , c = s.getSize();
                    yt(this._box, s.min),
                    this._box.style.width = c.x + "px",
                    this._box.style.height = c.y + "px"
                },
                _finish: function() {
                    this._moved && (ut(this._box),
                    pt(this._container, "leaflet-crosshair")),
                    er(),
                    co(),
                    rt(document, {
                        contextmenu: ei,
                        mousemove: this._onMouseMove,
                        mouseup: this._onMouseUp,
                        keydown: this._onKeyDown
                    }, this)
                },
                _onMouseUp: function(t) {
                    if (!(t.which !== 1 && t.button !== 1) && (this._finish(),
                    !!this._moved)) {
                        this._clearDeferredResetState(),
                        this._resetStateTimeout = setTimeout(l(this._resetState, this), 0);
                        var s = new ee(this._map.containerPointToLatLng(this._startPoint),this._map.containerPointToLatLng(this._point));
                        this._map.fitBounds(s).fire("boxzoomend", {
                            boxZoomBounds: s
                        })
                    }
                },
                _onKeyDown: function(t) {
                    t.keyCode === 27 && (this._finish(),
                    this._clearDeferredResetState(),
                    this._resetState())
                }
            });
            Xe.addInitHook("addHandler", "boxZoom", zu),
            Xe.mergeOptions({
                doubleClickZoom: !0
            });
            var Uu = fn.extend({
                addHooks: function() {
                    this._map.on("dblclick", this._onDoubleClick, this)
                },
                removeHooks: function() {
                    this._map.off("dblclick", this._onDoubleClick, this)
                },
                _onDoubleClick: function(t) {
                    var s = this._map
                      , c = s.getZoom()
                      , p = s.options.zoomDelta
                      , E = t.originalEvent.shiftKey ? c - p : c + p;
                    s.options.doubleClickZoom === "center" ? s.setZoom(E) : s.setZoomAround(t.containerPoint, E)
                }
            });
            Xe.addInitHook("addHandler", "doubleClickZoom", Uu),
            Xe.mergeOptions({
                dragging: !0,
                inertia: !0,
                inertiaDeceleration: 3400,
                inertiaMaxSpeed: 1 / 0,
                easeLinearity: .2,
                worldCopyJump: !1,
                maxBoundsViscosity: 0
            });
            var Hu = fn.extend({
                addHooks: function() {
                    if (!this._draggable) {
                        var t = this._map;
                        this._draggable = new Fn(t._mapPane,t._container),
                        this._draggable.on({
                            dragstart: this._onDragStart,
                            drag: this._onDrag,
                            dragend: this._onDragEnd
                        }, this),
                        this._draggable.on("predrag", this._onPreDragLimit, this),
                        t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this),
                        t.on("zoomend", this._onZoomEnd, this),
                        t.whenReady(this._onZoomEnd, this))
                    }
                    Ue(this._map._container, "leaflet-grab leaflet-touch-drag"),
                    this._draggable.enable(),
                    this._positions = [],
                    this._times = []
                },
                removeHooks: function() {
                    pt(this._map._container, "leaflet-grab"),
                    pt(this._map._container, "leaflet-touch-drag"),
                    this._draggable.disable()
                },
                moved: function() {
                    return this._draggable && this._draggable._moved
                },
                moving: function() {
                    return this._draggable && this._draggable._moving
                },
                _onDragStart: function() {
                    var t = this._map;
                    if (t._stop(),
                    this._map.options.maxBounds && this._map.options.maxBoundsViscosity) {
                        var s = me(this._map.options.maxBounds);
                        this._offsetLimit = ie(this._map.latLngToContainerPoint(s.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(s.getSouthEast()).multiplyBy(-1).add(this._map.getSize())),
                        this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity))
                    } else
                        this._offsetLimit = null;
                    t.fire("movestart").fire("dragstart"),
                    t.options.inertia && (this._positions = [],
                    this._times = [])
                },
                _onDrag: function(t) {
                    if (this._map.options.inertia) {
                        var s = this._lastTime = +new Date
                          , c = this._lastPos = this._draggable._absPos || this._draggable._newPos;
                        this._positions.push(c),
                        this._times.push(s),
                        this._prunePositions(s)
                    }
                    this._map.fire("move", t).fire("drag", t)
                },
                _prunePositions: function(t) {
                    for (; this._positions.length > 1 && t - this._times[0] > 50; )
                        this._positions.shift(),
                        this._times.shift()
                },
                _onZoomEnd: function() {
                    var t = this._map.getSize().divideBy(2)
                      , s = this._map.latLngToLayerPoint([0, 0]);
                    this._initialWorldOffset = s.subtract(t).x,
                    this._worldWidth = this._map.getPixelWorldBounds().getSize().x
                },
                _viscousLimit: function(t, s) {
                    return t - (t - s) * this._viscosity
                },
                _onPreDragLimit: function() {
                    if (!(!this._viscosity || !this._offsetLimit)) {
                        var t = this._draggable._newPos.subtract(this._draggable._startPos)
                          , s = this._offsetLimit;
                        t.x < s.min.x && (t.x = this._viscousLimit(t.x, s.min.x)),
                        t.y < s.min.y && (t.y = this._viscousLimit(t.y, s.min.y)),
                        t.x > s.max.x && (t.x = this._viscousLimit(t.x, s.max.x)),
                        t.y > s.max.y && (t.y = this._viscousLimit(t.y, s.max.y)),
                        this._draggable._newPos = this._draggable._startPos.add(t)
                    }
                },
                _onPreDragWrap: function() {
                    var t = this._worldWidth
                      , s = Math.round(t / 2)
                      , c = this._initialWorldOffset
                      , p = this._draggable._newPos.x
                      , E = (p - s + c) % t + s - c
                      , k = (p + s + c) % t - s - c
                      , ne = Math.abs(E + c) < Math.abs(k + c) ? E : k;
                    this._draggable._absPos = this._draggable._newPos.clone(),
                    this._draggable._newPos.x = ne
                },
                _onDragEnd: function(t) {
                    var s = this._map
                      , c = s.options
                      , p = !c.inertia || t.noInertia || this._times.length < 2;
                    if (s.fire("dragend", t),
                    p)
                        s.fire("moveend");
                    else {
                        this._prunePositions(+new Date);
                        var E = this._lastPos.subtract(this._positions[0])
                          , k = (this._lastTime - this._times[0]) / 1e3
                          , ne = c.easeLinearity
                          , he = E.multiplyBy(ne / k)
                          , ye = he.distanceTo([0, 0])
                          , Le = Math.min(c.inertiaMaxSpeed, ye)
                          , Ce = he.multiplyBy(Le / ye)
                          , je = Le / (c.inertiaDeceleration * ne)
                          , Ve = Ce.multiplyBy(-je / 2).round();
                        !Ve.x && !Ve.y ? s.fire("moveend") : (Ve = s._limitOffset(Ve, s.options.maxBounds),
                        $(function() {
                            s.panBy(Ve, {
                                duration: je,
                                easeLinearity: ne,
                                noMoveStart: !0,
                                animate: !0
                            })
                        }))
                    }
                }
            });
            Xe.addInitHook("addHandler", "dragging", Hu),
            Xe.mergeOptions({
                keyboard: !0,
                keyboardPanDelta: 80
            });
            var Vu = fn.extend({
                keyCodes: {
                    left: [37],
                    right: [39],
                    down: [40],
                    up: [38],
                    zoomIn: [187, 107, 61, 171],
                    zoomOut: [189, 109, 54, 173]
                },
                initialize: function(t) {
                    this._map = t,
                    this._setPanDelta(t.options.keyboardPanDelta),
                    this._setZoomDelta(t.options.zoomDelta)
                },
                addHooks: function() {
                    var t = this._map._container;
                    t.tabIndex <= 0 && (t.tabIndex = "0"),
                    qe(t, {
                        focus: this._onFocus,
                        blur: this._onBlur,
                        mousedown: this._onMouseDown
                    }, this),
                    this._map.on({
                        focus: this._addHooks,
                        blur: this._removeHooks
                    }, this)
                },
                removeHooks: function() {
                    this._removeHooks(),
                    rt(this._map._container, {
                        focus: this._onFocus,
                        blur: this._onBlur,
                        mousedown: this._onMouseDown
                    }, this),
                    this._map.off({
                        focus: this._addHooks,
                        blur: this._removeHooks
                    }, this)
                },
                _onMouseDown: function() {
                    if (!this._focused) {
                        var t = document.body
                          , s = document.documentElement
                          , c = t.scrollTop || s.scrollTop
                          , p = t.scrollLeft || s.scrollLeft;
                        this._map._container.focus(),
                        window.scrollTo(p, c)
                    }
                },
                _onFocus: function() {
                    this._focused = !0,
                    this._map.fire("focus")
                },
                _onBlur: function() {
                    this._focused = !1,
                    this._map.fire("blur")
                },
                _setPanDelta: function(t) {
                    var s = this._panKeys = {}, c = this.keyCodes, p, E;
                    for (p = 0,
                    E = c.left.length; p < E; p++)
                        s[c.left[p]] = [-1 * t, 0];
                    for (p = 0,
                    E = c.right.length; p < E; p++)
                        s[c.right[p]] = [t, 0];
                    for (p = 0,
                    E = c.down.length; p < E; p++)
                        s[c.down[p]] = [0, t];
                    for (p = 0,
                    E = c.up.length; p < E; p++)
                        s[c.up[p]] = [0, -1 * t]
                },
                _setZoomDelta: function(t) {
                    var s = this._zoomKeys = {}, c = this.keyCodes, p, E;
                    for (p = 0,
                    E = c.zoomIn.length; p < E; p++)
                        s[c.zoomIn[p]] = t;
                    for (p = 0,
                    E = c.zoomOut.length; p < E; p++)
                        s[c.zoomOut[p]] = -t
                },
                _addHooks: function() {
                    qe(document, "keydown", this._onKeyDown, this)
                },
                _removeHooks: function() {
                    rt(document, "keydown", this._onKeyDown, this)
                },
                _onKeyDown: function(t) {
                    if (!(t.altKey || t.ctrlKey || t.metaKey)) {
                        var s = t.keyCode, c = this._map, p;
                        if (s in this._panKeys) {
                            if (!c._panAnim || !c._panAnim._inProgress)
                                if (p = this._panKeys[s],
                                t.shiftKey && (p = I(p).multiplyBy(3)),
                                c.options.maxBounds && (p = c._limitOffset(I(p), c.options.maxBounds)),
                                c.options.worldCopyJump) {
                                    var E = c.wrapLatLng(c.unproject(c.project(c.getCenter()).add(p)));
                                    c.panTo(E)
                                } else
                                    c.panBy(p)
                        } else if (s in this._zoomKeys)
                            c.setZoom(c.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[s]);
                        else if (s === 27 && c._popup && c._popup.options.closeOnEscapeKey)
                            c.closePopup();
                        else
                            return;
                        ei(t)
                    }
                }
            });
            Xe.addInitHook("addHandler", "keyboard", Vu),
            Xe.mergeOptions({
                scrollWheelZoom: !0,
                wheelDebounceTime: 40,
                wheelPxPerZoomLevel: 60
            });
            var Gu = fn.extend({
                addHooks: function() {
                    qe(this._map._container, "wheel", this._onWheelScroll, this),
                    this._delta = 0
                },
                removeHooks: function() {
                    rt(this._map._container, "wheel", this._onWheelScroll, this)
                },
                _onWheelScroll: function(t) {
                    var s = mu(t)
                      , c = this._map.options.wheelDebounceTime;
                    this._delta += s,
                    this._lastMousePos = this._map.mouseEventToContainerPoint(t),
                    this._startTime || (this._startTime = +new Date);
                    var p = Math.max(c - (+new Date - this._startTime), 0);
                    clearTimeout(this._timer),
                    this._timer = setTimeout(l(this._performZoom, this), p),
                    ei(t)
                },
                _performZoom: function() {
                    var t = this._map
                      , s = t.getZoom()
                      , c = this._map.options.zoomSnap || 0;
                    t._stop();
                    var p = this._delta / (this._map.options.wheelPxPerZoomLevel * 4)
                      , E = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(p)))) / Math.LN2
                      , k = c ? Math.ceil(E / c) * c : E
                      , ne = t._limitZoom(s + (this._delta > 0 ? k : -k)) - s;
                    this._delta = 0,
                    this._startTime = null,
                    ne && (t.options.scrollWheelZoom === "center" ? t.setZoom(s + ne) : t.setZoomAround(this._lastMousePos, s + ne))
                }
            });
            Xe.addInitHook("addHandler", "scrollWheelZoom", Gu);
            var og = 600;
            Xe.mergeOptions({
                tapHold: Pe.touchNative && Pe.safari && Pe.mobile,
                tapTolerance: 15
            });
            var Wu = fn.extend({
                addHooks: function() {
                    qe(this._map._container, "touchstart", this._onDown, this)
                },
                removeHooks: function() {
                    rt(this._map._container, "touchstart", this._onDown, this)
                },
                _onDown: function(t) {
                    if (clearTimeout(this._holdTimeout),
                    t.touches.length === 1) {
                        var s = t.touches[0];
                        this._startPos = this._newPos = new j(s.clientX,s.clientY),
                        this._holdTimeout = setTimeout(l(function() {
                            this._cancel(),
                            this._isTapValid() && (qe(document, "touchend", St),
                            qe(document, "touchend touchcancel", this._cancelClickPrevent),
                            this._simulateEvent("contextmenu", s))
                        }, this), og),
                        qe(document, "touchend touchcancel contextmenu", this._cancel, this),
                        qe(document, "touchmove", this._onMove, this)
                    }
                },
                _cancelClickPrevent: function t() {
                    rt(document, "touchend", St),
                    rt(document, "touchend touchcancel", t)
                },
                _cancel: function() {
                    clearTimeout(this._holdTimeout),
                    rt(document, "touchend touchcancel contextmenu", this._cancel, this),
                    rt(document, "touchmove", this._onMove, this)
                },
                _onMove: function(t) {
                    var s = t.touches[0];
                    this._newPos = new j(s.clientX,s.clientY)
                },
                _isTapValid: function() {
                    return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
                },
                _simulateEvent: function(t, s) {
                    var c = new MouseEvent(t,{
                        bubbles: !0,
                        cancelable: !0,
                        view: window,
                        screenX: s.screenX,
                        screenY: s.screenY,
                        clientX: s.clientX,
                        clientY: s.clientY
                    });
                    c._simulated = !0,
                    s.target.dispatchEvent(c)
                }
            });
            Xe.addInitHook("addHandler", "tapHold", Wu),
            Xe.mergeOptions({
                touchZoom: Pe.touch,
                bounceAtZoomLimits: !0
            });
            var Zu = fn.extend({
                addHooks: function() {
                    Ue(this._map._container, "leaflet-touch-zoom"),
                    qe(this._map._container, "touchstart", this._onTouchStart, this)
                },
                removeHooks: function() {
                    pt(this._map._container, "leaflet-touch-zoom"),
                    rt(this._map._container, "touchstart", this._onTouchStart, this)
                },
                _onTouchStart: function(t) {
                    var s = this._map;
                    if (!(!t.touches || t.touches.length !== 2 || s._animatingZoom || this._zooming)) {
                        var c = s.mouseEventToContainerPoint(t.touches[0])
                          , p = s.mouseEventToContainerPoint(t.touches[1]);
                        this._centerPoint = s.getSize()._divideBy(2),
                        this._startLatLng = s.containerPointToLatLng(this._centerPoint),
                        s.options.touchZoom !== "center" && (this._pinchStartLatLng = s.containerPointToLatLng(c.add(p)._divideBy(2))),
                        this._startDist = c.distanceTo(p),
                        this._startZoom = s.getZoom(),
                        this._moved = !1,
                        this._zooming = !0,
                        s._stop(),
                        qe(document, "touchmove", this._onTouchMove, this),
                        qe(document, "touchend touchcancel", this._onTouchEnd, this),
                        St(t)
                    }
                },
                _onTouchMove: function(t) {
                    if (!(!t.touches || t.touches.length !== 2 || !this._zooming)) {
                        var s = this._map
                          , c = s.mouseEventToContainerPoint(t.touches[0])
                          , p = s.mouseEventToContainerPoint(t.touches[1])
                          , E = c.distanceTo(p) / this._startDist;
                        if (this._zoom = s.getScaleZoom(E, this._startZoom),
                        !s.options.bounceAtZoomLimits && (this._zoom < s.getMinZoom() && E < 1 || this._zoom > s.getMaxZoom() && E > 1) && (this._zoom = s._limitZoom(this._zoom)),
                        s.options.touchZoom === "center") {
                            if (this._center = this._startLatLng,
                            E === 1)
                                return
                        } else {
                            var k = c._add(p)._divideBy(2)._subtract(this._centerPoint);
                            if (E === 1 && k.x === 0 && k.y === 0)
                                return;
                            this._center = s.unproject(s.project(this._pinchStartLatLng, this._zoom).subtract(k), this._zoom)
                        }
                        this._moved || (s._moveStart(!0, !1),
                        this._moved = !0),
                        X(this._animRequest);
                        var ne = l(s._move, s, this._center, this._zoom, {
                            pinch: !0,
                            round: !1
                        }, void 0);
                        this._animRequest = $(ne, this, !0),
                        St(t)
                    }
                },
                _onTouchEnd: function() {
                    if (!this._moved || !this._zooming) {
                        this._zooming = !1;
                        return
                    }
                    this._zooming = !1,
                    X(this._animRequest),
                    rt(document, "touchmove", this._onTouchMove, this),
                    rt(document, "touchend touchcancel", this._onTouchEnd, this),
                    this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))
                }
            });
            Xe.addInitHook("addHandler", "touchZoom", Zu),
            Xe.BoxZoom = zu,
            Xe.DoubleClickZoom = Uu,
            Xe.Drag = Hu,
            Xe.Keyboard = Vu,
            Xe.ScrollWheelZoom = Gu,
            Xe.TapHold = Wu,
            Xe.TouchZoom = Zu,
            n.Bounds = Z,
            n.Browser = Pe,
            n.CRS = Y,
            n.Canvas = ju,
            n.Circle = Lo,
            n.CircleMarker = ns,
            n.Class = B,
            n.Control = tn,
            n.DivIcon = Du,
            n.DivOverlay = pn,
            n.DomEvent = Sp,
            n.DomUtil = xp,
            n.Draggable = Fn,
            n.Evented = oe,
            n.FeatureGroup = wn,
            n.GeoJSON = En,
            n.GridLayer = or,
            n.Handler = fn,
            n.Icon = Ni,
            n.ImageOverlay = as,
            n.LatLng = W,
            n.LatLngBounds = ee,
            n.Layer = nn,
            n.LayerGroup = Ii,
            n.LineUtil = Fp,
            n.Map = Xe,
            n.Marker = ts,
            n.Mixin = Cp,
            n.Path = jn,
            n.Point = j,
            n.PolyUtil = kp,
            n.Polygon = Ai,
            n.Polyline = xn,
            n.Popup = ls,
            n.PosAnimation = _u,
            n.Projection = jp,
            n.Rectangle = qu,
            n.Renderer = Sn,
            n.SVG = lr,
            n.SVGOverlay = Mu,
            n.TileLayer = Ci,
            n.Tooltip = us,
            n.Transformation = Ee,
            n.Util = F,
            n.VideoOverlay = Pu,
            n.bind = l,
            n.bounds = ie,
            n.canvas = Bu,
            n.circle = Gp,
            n.circleMarker = Vp,
            n.control = ir,
            n.divIcon = tg,
            n.extend = o,
            n.featureGroup = zp,
            n.geoJSON = ku,
            n.geoJson = Xp,
            n.gridLayer = ng,
            n.icon = Up,
            n.imageOverlay = Qp,
            n.latLng = G,
            n.latLngBounds = me,
            n.layerGroup = qp,
            n.map = Tp,
            n.marker = Hp,
            n.point = I,
            n.polygon = Zp,
            n.polyline = Wp,
            n.popup = Yp,
            n.rectangle = sg,
            n.setOptions = T,
            n.stamp = f,
            n.svg = $u,
            n.svgOverlay = Kp,
            n.tileLayer = Ou,
            n.tooltip = eg,
            n.transformation = Te,
            n.version = r,
            n.videoOverlay = Jp;
            var ag = window.L;
            n.noConflict = function() {
                return window.L = ag,
                this
            }
            ,
            window.L = n
        }
        ))
    }
    )(Mr, Mr.exports)),
    Mr.exports
}
var Dt = uu(), _l = {
    exports: {}
}, Gh;
function y0() {
    return Gh || (Gh = 1,
    (function(i, e) {
        ((n,r)=>{
            i.exports = n(uu()),
            typeof r < "u" && r.L && n(r.L)
        }
        )(n=>{
            n.Editable = n.Evented.extend({
                statics: {
                    FORWARD: 1,
                    BACKWARD: -1
                },
                options: {
                    zIndex: 1e3,
                    polygonClass: n.Polygon,
                    polylineClass: n.Polyline,
                    markerClass: n.Marker,
                    circleMarkerClass: n.CircleMarker,
                    rectangleClass: n.Rectangle,
                    circleClass: n.Circle,
                    drawingCSSClass: "leaflet-editable-drawing",
                    drawingCursor: "crosshair",
                    editLayer: void 0,
                    featuresLayer: void 0,
                    polylineEditorClass: void 0,
                    polygonEditorClass: void 0,
                    markerEditorClass: void 0,
                    circleMarkerEditorClass: void 0,
                    rectangleEditorClass: void 0,
                    circleEditorClass: void 0,
                    lineGuideOptions: {},
                    skipMiddleMarkers: !1
                },
                initialize: function(d, g) {
                    n.setOptions(this, g),
                    this._lastZIndex = this.options.zIndex,
                    this.map = d,
                    this.editLayer = this.createEditLayer(),
                    this.featuresLayer = this.createFeaturesLayer(),
                    this.forwardLineGuide = this.createLineGuide(),
                    this.backwardLineGuide = this.createLineGuide()
                },
                fireAndForward: function(d, g) {
                    g = g || {},
                    g.editTools = this,
                    this.fire(d, g),
                    this.map.fire(d, g)
                },
                createLineGuide: function() {
                    const d = n.extend({
                        dashArray: "5,10",
                        weight: 1,
                        interactive: !1
                    }, this.options.lineGuideOptions);
                    return n.polyline([], d)
                },
                createVertexIcon: d=>n.Browser.mobile && n.Browser.touch ? new n.Editable.TouchVertexIcon(d) : new n.Editable.VertexIcon(d),
                createEditLayer: function() {
                    return this.options.editLayer || new n.LayerGroup().addTo(this.map)
                },
                createFeaturesLayer: function() {
                    return this.options.featuresLayer || new n.LayerGroup().addTo(this.map)
                },
                moveForwardLineGuide: function(d) {
                    this.forwardLineGuide._latlngs.length && (this.forwardLineGuide._latlngs[1] = d,
                    this.forwardLineGuide._bounds.extend(d),
                    this.forwardLineGuide.redraw())
                },
                moveBackwardLineGuide: function(d) {
                    this.backwardLineGuide._latlngs.length && (this.backwardLineGuide._latlngs[1] = d,
                    this.backwardLineGuide._bounds.extend(d),
                    this.backwardLineGuide.redraw())
                },
                anchorForwardLineGuide: function(d) {
                    this.forwardLineGuide._latlngs[0] = d,
                    this.forwardLineGuide._bounds.extend(d),
                    this.forwardLineGuide.redraw()
                },
                anchorBackwardLineGuide: function(d) {
                    this.backwardLineGuide._latlngs[0] = d,
                    this.backwardLineGuide._bounds.extend(d),
                    this.backwardLineGuide.redraw()
                },
                attachForwardLineGuide: function() {
                    this.editLayer.addLayer(this.forwardLineGuide)
                },
                attachBackwardLineGuide: function() {
                    this.editLayer.addLayer(this.backwardLineGuide)
                },
                detachForwardLineGuide: function() {
                    this.forwardLineGuide.setLatLngs([]),
                    this.editLayer.removeLayer(this.forwardLineGuide)
                },
                detachBackwardLineGuide: function() {
                    this.backwardLineGuide.setLatLngs([]),
                    this.editLayer.removeLayer(this.backwardLineGuide)
                },
                blockEvents: function() {
                    this._oldTargets || (this._oldTargets = this.map._targets,
                    this.map._targets = {})
                },
                unblockEvents: function() {
                    this._oldTargets && (this.map._targets = n.extend(this.map._targets, this._oldTargets),
                    delete this._oldTargets)
                },
                registerForDrawing: function(d) {
                    this._drawingEditor && this.unregisterForDrawing(this._drawingEditor),
                    this.blockEvents(),
                    d.reset(),
                    this._drawingEditor = d,
                    this.map.on("mousemove touchmove", d.onDrawingMouseMove, d),
                    this.map.on("mousedown", this.onMousedown, this),
                    this.map.on("mouseup", this.onMouseup, this),
                    n.DomUtil.addClass(this.map._container, this.options.drawingCSSClass),
                    this.defaultMapCursor = this.map._container.style.cursor,
                    this.map._container.style.cursor = this.options.drawingCursor
                },
                unregisterForDrawing: function(d) {
                    this.unblockEvents(),
                    n.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass),
                    this.map._container.style.cursor = this.defaultMapCursor,
                    d = d || this._drawingEditor,
                    d && (this.map.off("mousemove touchmove", d.onDrawingMouseMove, d),
                    this.map.off("mousedown", this.onMousedown, this),
                    this.map.off("mouseup", this.onMouseup, this),
                    d === this._drawingEditor && (delete this._drawingEditor,
                    d._drawing && d.cancelDrawing()))
                },
                onMousedown: function(d) {
                    d.originalEvent.which == 1 && (this._mouseDown = d,
                    this._drawingEditor.onDrawingMouseDown(d))
                },
                onMouseup: function(d) {
                    if (this._mouseDown) {
                        const g = this._drawingEditor
                          , b = this._mouseDown;
                        if (this._mouseDown = null,
                        g.onDrawingMouseUp(d),
                        this._drawingEditor !== g)
                            return;
                        const T = n.point(b.originalEvent.clientX, b.originalEvent.clientY)
                          , N = n.point(d.originalEvent.clientX, d.originalEvent.clientY).distanceTo(T);
                        Math.abs(N) < 9 * (window.devicePixelRatio || 1) && this._drawingEditor.onDrawingClick(d)
                    }
                },
                drawing: function() {
                    return this._drawingEditor?.drawing()
                },
                stopDrawing: function() {
                    this.unregisterForDrawing()
                },
                commitDrawing: function(d) {
                    this._drawingEditor && this._drawingEditor.commitDrawing(d)
                },
                connectCreatedToMap: function(d) {
                    return this.featuresLayer.addLayer(d)
                },
                startPolyline: function(d, g) {
                    const b = this.createPolyline([], g);
                    return b.enableEdit(this.map).newShape(d),
                    b
                },
                startPolygon: function(d, g) {
                    const b = this.createPolygon([], g);
                    return b.enableEdit(this.map).newShape(d),
                    b
                },
                startMarker: function(d, g) {
                    d = d || this.map.getCenter().clone();
                    const b = this.createMarker(d, g);
                    return b.enableEdit(this.map).startDrawing(),
                    b
                },
                startCircleMarker: function(d, g) {
                    d = d || this.map.getCenter().clone();
                    const b = this.createCircleMarker(d, g);
                    return b.enableEdit(this.map).startDrawing(),
                    b
                },
                startRectangle: function(d, g) {
                    const b = d || n.latLng([0, 0])
                      , T = new n.LatLngBounds(b,b)
                      , N = this.createRectangle(T, g);
                    return N.enableEdit(this.map).startDrawing(),
                    N
                },
                startCircle: function(d, g) {
                    d = d || this.map.getCenter().clone();
                    const b = this.createCircle(d, g);
                    return b.enableEdit(this.map).startDrawing(),
                    b
                },
                startHole: (d,g)=>{
                    d.newHole(g)
                }
                ,
                createLayer: function(d, g, b) {
                    b = n.Util.extend({
                        editOptions: {
                            editTools: this
                        }
                    }, b);
                    const T = new d(g,b);
                    return this.fireAndForward("editable:created", {
                        layer: T
                    }),
                    T
                },
                createPolyline: function(d, g) {
                    return this.createLayer(g?.polylineClass || this.options.polylineClass, d, g)
                },
                createPolygon: function(d, g) {
                    return this.createLayer(g?.polygonClass || this.options.polygonClass, d, g)
                },
                createMarker: function(d, g) {
                    return this.createLayer(g?.markerClass || this.options.markerClass, d, g)
                },
                createCircleMarker: function(d, g) {
                    return this.createLayer(g?.circleMarkerClass || this.options.circleMarkerClass, d, g)
                },
                createRectangle: function(d, g) {
                    return this.createLayer(g?.rectangleClass || this.options.rectangleClass, d, g)
                },
                createCircle: function(d, g) {
                    return this.createLayer(g?.circleClass || this.options.circleClass, d, g)
                }
            }),
            n.extend(n.Editable, {
                makeCancellable: d=>{
                    d.cancel = ()=>{
                        d._cancelled = !0
                    }
                }
            }),
            n.Map.mergeOptions({
                editToolsClass: n.Editable,
                editable: !1,
                editOptions: {}
            }),
            n.Map.addInitHook(function() {
                this.whenReady(function() {
                    this.options.editable && (this.editTools = new this.options.editToolsClass(this,this.options.editOptions))
                })
            }),
            n.Editable.VertexIcon = n.DivIcon.extend({
                options: {
                    iconSize: new n.Point(8,8)
                }
            }),
            n.Editable.TouchVertexIcon = n.Editable.VertexIcon.extend({
                options: {
                    iconSize: new n.Point(20,20)
                }
            }),
            n.Editable.VertexMarker = n.Marker.extend({
                options: {
                    draggable: !0,
                    className: "leaflet-div-icon leaflet-vertex-icon"
                },
                initialize: function(d, g, b, T) {
                    this.latlng = d,
                    this.latlngs = g,
                    this.editor = b,
                    n.Marker.prototype.initialize.call(this, d, T),
                    this.options.icon = this.editor.tools.createVertexIcon({
                        className: this.options.className
                    }),
                    this.latlng.__vertex = this,
                    this.connect(),
                    this.setZIndexOffset(b.tools._lastZIndex + 1)
                },
                connect: function() {
                    this.editor.editLayer.addLayer(this)
                },
                onAdd: function(d) {
                    n.Marker.prototype.onAdd.call(this, d),
                    this.on("drag", this.onDrag),
                    this.on("dragstart", this.onDragStart),
                    this.on("dragend", this.onDragEnd),
                    this.on("mouseup", this.onMouseup),
                    this.on("click", this.onClick),
                    this.on("contextmenu", this.onContextMenu),
                    this.on("mousedown touchstart", this.onMouseDown),
                    this.on("mouseover", this.onMouseOver),
                    this.on("mouseout", this.onMouseOut),
                    this.addMiddleMarkers()
                },
                onRemove: function(d) {
                    this.middleMarker && this.middleMarker.delete(),
                    delete this.latlng.__vertex,
                    this.off("drag", this.onDrag),
                    this.off("dragstart", this.onDragStart),
                    this.off("dragend", this.onDragEnd),
                    this.off("mouseup", this.onMouseup),
                    this.off("click", this.onClick),
                    this.off("contextmenu", this.onContextMenu),
                    this.off("mousedown touchstart", this.onMouseDown),
                    this.off("mouseover", this.onMouseOver),
                    this.off("mouseout", this.onMouseOut),
                    n.Marker.prototype.onRemove.call(this, d)
                },
                onDrag: function(d) {
                    d.vertex = this,
                    this.editor.onVertexMarkerDrag(d);
                    const g = n.DomUtil.getPosition(this._icon)
                      , b = this._map.layerPointToLatLng(g);
                    this.latlng.update(b),
                    this._latlng = this.latlng,
                    this.editor.refresh(),
                    this.middleMarker && this.middleMarker.updateLatLng();
                    const T = this.getNext();
                    T?.middleMarker && T.middleMarker.updateLatLng()
                },
                onDragStart: function(d) {
                    d.vertex = this,
                    this.editor.onVertexMarkerDragStart(d)
                },
                onDragEnd: function(d) {
                    d.vertex = this,
                    this.editor.onVertexMarkerDragEnd(d)
                },
                onClick: function(d) {
                    d.vertex = this,
                    this.editor.onVertexMarkerClick(d)
                },
                onMouseup: function(d) {
                    n.DomEvent.stop(d),
                    d.vertex = this,
                    this.editor.map.fire("mouseup", d)
                },
                onContextMenu: function(d) {
                    d.vertex = this,
                    this.editor.onVertexMarkerContextMenu(d)
                },
                onMouseDown: function(d) {
                    d.vertex = this,
                    this.editor.onVertexMarkerMouseDown(d)
                },
                onMouseOver: function(d) {
                    d.vertex = this,
                    this.editor.onVertexMarkerMouseOver(d)
                },
                onMouseOut: function(d) {
                    d.vertex = this,
                    this.editor.onVertexMarkerMouseOut(d)
                },
                delete: function() {
                    const d = this.getNext();
                    this.latlngs.splice(this.getIndex(), 1),
                    this.editor.editLayer.removeLayer(this),
                    this.editor.onVertexDeleted({
                        latlng: this.latlng,
                        vertex: this
                    }),
                    this.latlngs.length || this.editor.deleteShape(this.latlngs),
                    d && d.resetMiddleMarker(),
                    this.editor.refresh()
                },
                getIndex: function() {
                    return this.latlngs.indexOf(this.latlng)
                },
                getLastIndex: function() {
                    return this.latlngs.length - 1
                },
                getPrevious: function() {
                    if (this.latlngs.length < 2)
                        return;
                    const d = this.getIndex();
                    let g = d - 1;
                    d === 0 && this.editor.CLOSED && (g = this.getLastIndex());
                    const b = this.latlngs[g];
                    if (b)
                        return b.__vertex
                },
                getNext: function() {
                    if (this.latlngs.length < 2)
                        return;
                    const d = this.getIndex();
                    let g = d + 1;
                    d === this.getLastIndex() && this.editor.CLOSED && (g = 0);
                    const b = this.latlngs[g];
                    if (b)
                        return b.__vertex
                },
                addMiddleMarker: function(d) {
                    this.editor.hasMiddleMarkers() && (d = d || this.getPrevious(),
                    d && !this.middleMarker && (this.middleMarker = this.editor.addMiddleMarker(d, this, this.latlngs, this.editor)))
                },
                addMiddleMarkers: function() {
                    if (!this.editor.hasMiddleMarkers())
                        return;
                    const d = this.getPrevious();
                    d && this.addMiddleMarker(d);
                    const g = this.getNext();
                    g && g.resetMiddleMarker()
                },
                resetMiddleMarker: function() {
                    this.middleMarker && this.middleMarker.delete(),
                    this.addMiddleMarker()
                },
                split: function() {
                    this.editor.splitShape && this.editor.splitShape(this.latlngs, this.getIndex())
                },
                continue: function() {
                    if (!this.editor.continueBackward)
                        return;
                    const d = this.getIndex();
                    d === 0 ? this.editor.continueBackward(this.latlngs) : d === this.getLastIndex() && this.editor.continueForward(this.latlngs)
                }
            }),
            n.Editable.mergeOptions({
                vertexMarkerClass: n.Editable.VertexMarker
            }),
            n.Editable.MiddleMarker = n.Marker.extend({
                options: {
                    opacity: .5,
                    className: "leaflet-div-icon leaflet-middle-icon",
                    draggable: !0
                },
                initialize: function(d, g, b, T, N) {
                    this.left = d,
                    this.right = g,
                    this.editor = T,
                    this.latlngs = b,
                    n.Marker.prototype.initialize.call(this, this.computeLatLng(), N),
                    this._opacity = this.options.opacity,
                    this.options.icon = this.editor.tools.createVertexIcon({
                        className: this.options.className
                    }),
                    this.editor.editLayer.addLayer(this),
                    this.setVisibility()
                },
                setVisibility: function() {
                    const d = this._map.latLngToContainerPoint(this.left.latlng)
                      , g = this._map.latLngToContainerPoint(this.right.latlng)
                      , b = n.point(this.options.icon.options.iconSize);
                    d.distanceTo(g) < b.x * 3 ? this.hide() : this.show()
                },
                show: function() {
                    this.setOpacity(this._opacity)
                },
                hide: function() {
                    this.setOpacity(0)
                },
                updateLatLng: function() {
                    this.setLatLng(this.computeLatLng()),
                    this.setVisibility()
                },
                computeLatLng: function() {
                    const d = this.editor.map.latLngToContainerPoint(this.left.latlng)
                      , g = this.editor.map.latLngToContainerPoint(this.right.latlng)
                      , b = (d.y + g.y) / 2
                      , T = (d.x + g.x) / 2;
                    return this.editor.map.containerPointToLatLng([T, b])
                },
                onAdd: function(d) {
                    n.Marker.prototype.onAdd.call(this, d),
                    n.DomEvent.on(this._icon, "mousedown touchstart", this.onMouseDown, this),
                    d.on("zoomend", this.setVisibility, this)
                },
                onRemove: function(d) {
                    delete this.right.middleMarker,
                    n.DomEvent.off(this._icon, "mousedown touchstart", this.onMouseDown, this),
                    d.off("zoomend", this.setVisibility, this),
                    n.Marker.prototype.onRemove.call(this, d)
                },
                onMouseDown: function(d) {
                    const g = n.DomUtil.getPosition(this._icon)
                      , b = this.editor.map.layerPointToLatLng(g);
                    if (d = {
                        originalEvent: d,
                        latlng: b
                    },
                    this.options.opacity === 0 || (n.Editable.makeCancellable(d),
                    this.editor.onMiddleMarkerMouseDown(d),
                    d._cancelled))
                        return;
                    this.latlngs.splice(this.index(), 0, d.latlng),
                    this.editor.refresh();
                    const T = this._icon
                      , N = this.editor.addVertexMarker(d.latlng, this.latlngs);
                    this.editor.onNewVertex(N);
                    const A = N._icon.parentNode;
                    A.removeChild(N._icon),
                    N._icon = T,
                    A.appendChild(N._icon),
                    N._initIcon(),
                    N._initInteraction(),
                    N.setOpacity(1),
                    n.Draggable._dragging = !1,
                    N.dragging._draggable._onDown(d.originalEvent),
                    this.delete()
                },
                delete: function() {
                    this.editor.editLayer.removeLayer(this)
                },
                index: function() {
                    return this.latlngs.indexOf(this.right.latlng)
                }
            }),
            n.Editable.mergeOptions({
                middleMarkerClass: n.Editable.MiddleMarker
            }),
            n.Editable.BaseEditor = n.Handler.extend({
                initialize: function(d, g, b) {
                    n.setOptions(this, b),
                    this.map = d,
                    this.feature = g,
                    this.feature.editor = this,
                    this.editLayer = new n.LayerGroup,
                    this.tools = this.options.editTools || d.editTools
                },
                addHooks: function() {
                    this.isConnected() ? this.onFeatureAdd() : this.feature.once("add", this.onFeatureAdd, this),
                    this.onEnable(),
                    this.feature.on(this._getEvents(), this)
                },
                removeHooks: function() {
                    this.feature.off(this._getEvents(), this),
                    this.feature.dragging && this.feature.dragging.disable(),
                    this.editLayer.clearLayers(),
                    this.tools.editLayer.removeLayer(this.editLayer),
                    this.onDisable(),
                    this._drawing && this.cancelDrawing()
                },
                drawing: function() {
                    return !!this._drawing
                },
                reset: ()=>{}
                ,
                onFeatureAdd: function() {
                    this.tools.editLayer.addLayer(this.editLayer),
                    this.feature.dragging && this.options.draggable != !1 && this.feature.dragging.enable()
                },
                hasMiddleMarkers: function() {
                    return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers
                },
                fireAndForward: function(d, g) {
                    g = g || {},
                    g.layer = this.feature,
                    this.feature.fire(d, g),
                    this.tools.fireAndForward(d, g)
                },
                onEnable: function() {
                    this.fireAndForward("editable:enable")
                },
                onDisable: function() {
                    this.fireAndForward("editable:disable")
                },
                onEditing: function() {
                    this.fireAndForward("editable:editing")
                },
                onEdited: function() {
                    this.fireAndForward("editable:edited")
                },
                onStartDrawing: function() {
                    this.fireAndForward("editable:drawing:start")
                },
                onEndDrawing: function() {
                    this.fireAndForward("editable:drawing:end")
                },
                onCancelDrawing: function() {
                    this.fireAndForward("editable:drawing:cancel")
                },
                onCommitDrawing: function(d) {
                    this.fireAndForward("editable:drawing:commit", d),
                    this.onEdited()
                },
                onDrawingMouseDown: function(d) {
                    this.fireAndForward("editable:drawing:mousedown", d)
                },
                onDrawingMouseUp: function(d) {
                    this.fireAndForward("editable:drawing:mouseup", d)
                },
                startDrawing: function() {
                    this._drawing || (this._drawing = n.Editable.FORWARD),
                    this.tools.registerForDrawing(this),
                    this.onStartDrawing()
                },
                commitDrawing: function(d) {
                    this.onCommitDrawing(d),
                    this.endDrawing()
                },
                cancelDrawing: function() {
                    n.Draggable._dragging = !1,
                    this.onCancelDrawing(),
                    this.endDrawing()
                },
                endDrawing: function() {
                    this._drawing = !1,
                    this.tools.unregisterForDrawing(this),
                    this.onEndDrawing()
                },
                onDrawingClick: function(d) {
                    this.drawing() && (n.Editable.makeCancellable(d),
                    this.fireAndForward("editable:drawing:click", d),
                    !d._cancelled && (this.isConnected() || this.connect(d),
                    this.processDrawingClick(d)))
                },
                isConnected: function() {
                    return this.map.hasLayer(this.feature)
                },
                connect: function() {
                    this.tools.connectCreatedToMap(this.feature),
                    this.tools.editLayer.addLayer(this.editLayer)
                },
                onMove: function(d) {
                    this.fireAndForward("editable:drawing:move", d)
                },
                onDrawingMouseMove: function(d) {
                    this.onMove(d)
                },
                _getEvents: function() {
                    return {
                        dragstart: this.onDragStart,
                        drag: this.onDrag,
                        dragend: this.onDragEnd,
                        remove: this.disable
                    }
                },
                onDragStart: function(d) {
                    this.onEditing(),
                    this.fireAndForward("editable:dragstart", d)
                },
                onDrag: function(d) {
                    this.onMove(d),
                    this.fireAndForward("editable:drag", d)
                },
                onDragEnd: function(d) {
                    this.fireAndForward("editable:dragend", d),
                    this.onEdited()
                }
            }),
            n.Editable.MarkerEditor = n.Editable.BaseEditor.extend({
                onDrawingMouseMove: function(d) {
                    n.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, d),
                    this._drawing && this.feature.setLatLng(d.latlng)
                },
                processDrawingClick: function(d) {
                    this.fireAndForward("editable:drawing:clicked", d),
                    this.commitDrawing(d)
                },
                connect: function(d) {
                    d && (this.feature._latlng = d.latlng),
                    n.Editable.BaseEditor.prototype.connect.call(this, d)
                }
            }),
            n.Editable.CircleMarkerEditor = n.Editable.BaseEditor.extend({
                onDrawingMouseMove: function(d) {
                    n.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, d),
                    this._drawing && this.feature.setLatLng(d.latlng)
                },
                processDrawingClick: function(d) {
                    this.fireAndForward("editable:drawing:clicked", d),
                    this.commitDrawing(d)
                },
                connect: function(d) {
                    d && (this.feature._latlng = d.latlng),
                    n.Editable.BaseEditor.prototype.connect.call(this, d)
                }
            }),
            n.Editable.PathEditor = n.Editable.BaseEditor.extend({
                CLOSED: !1,
                MIN_VERTEX: 2,
                addHooks: function() {
                    return n.Editable.BaseEditor.prototype.addHooks.call(this),
                    this.feature && (this.initVertexMarkers(),
                    this.map.on("moveend", this.onMoveEnd, this)),
                    this
                },
                removeHooks: function() {
                    n.Editable.BaseEditor.prototype.removeHooks.call(this),
                    this.feature && this.map.off("moveend", this.onMoveEnd, this)
                },
                onMoveEnd: function() {
                    this.initVertexMarkers()
                },
                initVertexMarkers: function(d) {
                    if (this.enabled())
                        if (d = d || this.getLatLngs(),
                        _(d))
                            this.addVertexMarkers(d);
                        else
                            for (const g of d)
                                this.initVertexMarkers(g)
                },
                getLatLngs: function() {
                    return this.feature.getLatLngs()
                },
                reset: function() {
                    this.editLayer.clearLayers(),
                    this.initVertexMarkers()
                },
                addVertexMarker: function(d, g) {
                    return d.__vertex ? (d.__vertex.connect(),
                    d.__vertex) : new this.tools.options.vertexMarkerClass(d,g,this)
                },
                onNewVertex: function(d) {
                    this.fireAndForward("editable:vertex:new", {
                        latlng: d.latlng,
                        vertex: d
                    })
                },
                addVertexMarkers: function(d) {
                    const g = this.map.getBounds();
                    for (const b of d)
                        g.contains(b) && this.addVertexMarker(b, d)
                },
                refreshVertexMarkers: function(d) {
                    d = d || this.getDefaultLatLngs();
                    for (const g of d)
                        g.__vertex.update()
                },
                addMiddleMarker: function(d, g, b) {
                    return new this.tools.options.middleMarkerClass(d,g,b,this)
                },
                onVertexMarkerClick: function(d) {
                    if (n.Editable.makeCancellable(d),
                    this.fireAndForward("editable:vertex:click", d),
                    d._cancelled || this.tools.drawing() && this.tools._drawingEditor !== this)
                        return;
                    const g = d.vertex.getIndex();
                    let b;
                    d.originalEvent.ctrlKey ? this.onVertexMarkerCtrlClick(d) : d.originalEvent.altKey ? this.onVertexMarkerAltClick(d) : d.originalEvent.shiftKey ? this.onVertexMarkerShiftClick(d) : d.originalEvent.metaKey ? this.onVertexMarkerMetaKeyClick(d) : g === d.vertex.getLastIndex() && this._drawing === n.Editable.FORWARD ? g >= this.MIN_VERTEX - 1 && (b = !0) : g === 0 && this._drawing === n.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX || g === 0 && this._drawing === n.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED ? b = !0 : this.onVertexRawMarkerClick(d),
                    this.fireAndForward("editable:vertex:clicked", d),
                    b && this.commitDrawing(d)
                },
                onVertexRawMarkerClick: function(d) {
                    this.fireAndForward("editable:vertex:rawclick", d),
                    !d._cancelled && this.vertexCanBeDeleted(d.vertex) && d.vertex.delete()
                },
                vertexCanBeDeleted: function(d) {
                    return d.latlngs.length > this.MIN_VERTEX
                },
                onVertexDeleted: function(d) {
                    this.fireAndForward("editable:vertex:deleted", d),
                    this.onEdited()
                },
                onVertexMarkerCtrlClick: function(d) {
                    this.fireAndForward("editable:vertex:ctrlclick", d)
                },
                onVertexMarkerShiftClick: function(d) {
                    this.fireAndForward("editable:vertex:shiftclick", d)
                },
                onVertexMarkerMetaKeyClick: function(d) {
                    this.fireAndForward("editable:vertex:metakeyclick", d)
                },
                onVertexMarkerAltClick: function(d) {
                    this.fireAndForward("editable:vertex:altclick", d)
                },
                onVertexMarkerContextMenu: function(d) {
                    this.fireAndForward("editable:vertex:contextmenu", d)
                },
                onVertexMarkerMouseDown: function(d) {
                    this.fireAndForward("editable:vertex:mousedown", d)
                },
                onVertexMarkerMouseOver: function(d) {
                    this.fireAndForward("editable:vertex:mouseover", d)
                },
                onVertexMarkerMouseOut: function(d) {
                    this.fireAndForward("editable:vertex:mouseout", d)
                },
                onMiddleMarkerMouseDown: function(d) {
                    this.fireAndForward("editable:middlemarker:mousedown", d)
                },
                onVertexMarkerDrag: function(d) {
                    this.onMove(d),
                    this.feature._bounds && this.extendBounds(d),
                    this.fireAndForward("editable:vertex:drag", d)
                },
                onVertexMarkerDragStart: function(d) {
                    this.fireAndForward("editable:vertex:dragstart", d)
                },
                onVertexMarkerDragEnd: function(d) {
                    this.fireAndForward("editable:vertex:dragend", d),
                    this.onEdited()
                },
                setDrawnLatLngs: function(d) {
                    this._drawnLatLngs = d || this.getDefaultLatLngs()
                },
                startDrawing: function() {
                    this._drawnLatLngs || this.setDrawnLatLngs(),
                    n.Editable.BaseEditor.prototype.startDrawing.call(this)
                },
                startDrawingForward: function() {
                    this.startDrawing()
                },
                endDrawing: function() {
                    this.tools.detachForwardLineGuide(),
                    this.tools.detachBackwardLineGuide(),
                    this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX && this.deleteShape(this._drawnLatLngs),
                    n.Editable.BaseEditor.prototype.endDrawing.call(this),
                    delete this._drawnLatLngs
                },
                addLatLng: function(d) {
                    this._drawing === n.Editable.FORWARD ? this._drawnLatLngs.push(d) : this._drawnLatLngs.unshift(d),
                    this.feature._bounds.extend(d);
                    const g = this.addVertexMarker(d, this._drawnLatLngs);
                    this.onNewVertex(g),
                    this.refresh()
                },
                newPointForward: function(d) {
                    this.addLatLng(d),
                    this.tools.attachForwardLineGuide(),
                    this.tools.anchorForwardLineGuide(d)
                },
                newPointBackward: function(d) {
                    this.addLatLng(d),
                    this.tools.anchorBackwardLineGuide(d)
                },
                push: function(d) {
                    if (!d)
                        return console.error("L.Editable.PathEditor.push expect a valid latlng as parameter");
                    this._drawing === n.Editable.FORWARD ? this.newPointForward(d) : this.newPointBackward(d)
                },
                removeLatLng: function(d) {
                    d.__vertex.delete(),
                    this.refresh()
                },
                pop: function() {
                    if (this._drawnLatLngs.length <= 1)
                        return;
                    let d;
                    return this._drawing === n.Editable.FORWARD ? d = this._drawnLatLngs[this._drawnLatLngs.length - 1] : d = this._drawnLatLngs[0],
                    this.removeLatLng(d),
                    this._drawing === n.Editable.FORWARD ? this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]) : this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]),
                    d
                },
                processDrawingClick: function(d) {
                    d.vertex && d.vertex.editor === this || (this._drawing === n.Editable.FORWARD ? this.newPointForward(d.latlng) : this.newPointBackward(d.latlng),
                    this.fireAndForward("editable:drawing:clicked", d))
                },
                onDrawingMouseMove: function(d) {
                    n.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, d),
                    this._drawing && (this.tools.moveForwardLineGuide(d.latlng),
                    this.tools.moveBackwardLineGuide(d.latlng))
                },
                refresh: function() {
                    this.feature.redraw(),
                    this.onEditing()
                },
                newShape: function(d) {
                    const g = this.addNewEmptyShape();
                    g && (this.setDrawnLatLngs(g[0] || g),
                    this.startDrawingForward(),
                    this.fireAndForward("editable:shape:new", {
                        shape: g
                    }),
                    d && this.newPointForward(d))
                },
                deleteShape: function(d, g) {
                    const b = {
                        shape: d
                    };
                    if (n.Editable.makeCancellable(b),
                    this.fireAndForward("editable:shape:delete", b),
                    !b._cancelled)
                        return d = this._deleteShape(d, g),
                        this.ensureNotFlat && this.ensureNotFlat(),
                        this.feature.setLatLngs(this.getLatLngs()),
                        this.refresh(),
                        this.reset(),
                        this.fireAndForward("editable:shape:deleted", {
                            shape: d
                        }),
                        this.onEdited(),
                        d
                },
                _deleteShape: function(d, g) {
                    if (g = g || this.getLatLngs(),
                    !g.length)
                        return;
                    const b = (N,A)=>N.splice(0, Number.MAX_VALUE)
                      , T = (N,A)=>(N.splice(N.indexOf(A), 1),
                    N.length || this._deleteShape(N),
                    A);
                    if (g === d)
                        return b(g);
                    for (const N of g) {
                        if (N === d)
                            return T(g, d);
                        if (N.indexOf(d) !== -1)
                            return T(N, d)
                    }
                },
                deleteShapeAt: function(d) {
                    const g = this.feature.shapeAt(d);
                    if (g)
                        return this.deleteShape(g)
                },
                appendShape: function(d) {
                    this.insertShape(d)
                },
                prependShape: function(d) {
                    this.insertShape(d, 0)
                },
                insertShape: function(d, g) {
                    this.ensureMulti(),
                    d = this.formatShape(d),
                    g === void 0 && (g = this.feature._latlngs.length),
                    this.feature._latlngs.splice(g, 0, d),
                    this.feature.redraw(),
                    this._enabled && this.reset()
                },
                extendBounds: function(d) {
                    this.feature._bounds.extend(d.vertex.latlng)
                },
                onDragStart: function(d) {
                    this.editLayer.clearLayers(),
                    n.Editable.BaseEditor.prototype.onDragStart.call(this, d)
                },
                onDragEnd: function(d) {
                    this.initVertexMarkers(),
                    n.Editable.BaseEditor.prototype.onDragEnd.call(this, d)
                }
            }),
            n.Editable.PolylineEditor = n.Editable.PathEditor.extend({
                startDrawingBackward: function() {
                    this._drawing = n.Editable.BACKWARD,
                    this.startDrawing()
                },
                continueBackward: function(d) {
                    this.drawing() || (d = d || this.getDefaultLatLngs(),
                    this.setDrawnLatLngs(d),
                    d.length > 0 && (this.tools.attachBackwardLineGuide(),
                    this.tools.anchorBackwardLineGuide(d[0])),
                    this.startDrawingBackward())
                },
                continueForward: function(d) {
                    this.drawing() || (d = d || this.getDefaultLatLngs(),
                    this.setDrawnLatLngs(d),
                    d.length > 0 && (this.tools.attachForwardLineGuide(),
                    this.tools.anchorForwardLineGuide(d[d.length - 1])),
                    this.startDrawingForward())
                },
                getDefaultLatLngs: function(d) {
                    return d = d || this.feature._latlngs,
                    !d.length || d[0]instanceof n.LatLng ? d : this.getDefaultLatLngs(d[0])
                },
                ensureMulti: function() {
                    this.feature._latlngs.length && _(this.feature._latlngs) && (this.feature._latlngs = [this.feature._latlngs])
                },
                addNewEmptyShape: function() {
                    if (this.feature._latlngs.length) {
                        const d = [];
                        return this.appendShape(d),
                        d
                    }
                    return this.feature._latlngs
                },
                formatShape: function(d) {
                    if (_(d))
                        return d;
                    if (d[0])
                        return this.formatShape(d[0])
                },
                splitShape: function(d, g) {
                    if (!g || g >= d.length - 1)
                        return;
                    this.ensureMulti();
                    const b = this.feature._latlngs.indexOf(d);
                    if (b === -1)
                        return;
                    const T = d.slice(0, g + 1)
                      , N = d.slice(g);
                    N[0] = n.latLng(N[0].lat, N[0].lng, N[0].alt),
                    this.feature._latlngs.splice(b, 1, T, N),
                    this.refresh(),
                    this.reset(),
                    this.onEdited()
                }
            }),
            n.Editable.PolygonEditor = n.Editable.PathEditor.extend({
                CLOSED: !0,
                MIN_VERTEX: 3,
                newPointForward: function(d) {
                    n.Editable.PathEditor.prototype.newPointForward.call(this, d),
                    this.tools.backwardLineGuide._latlngs.length || this.tools.anchorBackwardLineGuide(d),
                    this._drawnLatLngs.length === 2 && this.tools.attachBackwardLineGuide()
                },
                addNewEmptyHole: function(d) {
                    this.ensureNotFlat();
                    const g = this.feature.shapeAt(d);
                    if (!g)
                        return;
                    const b = [];
                    return g.push(b),
                    b
                },
                newHole: function(d) {
                    const g = this.addNewEmptyHole(d);
                    g && (this.setDrawnLatLngs(g),
                    this.startDrawingForward(),
                    d && this.newPointForward(d))
                },
                addNewEmptyShape: function() {
                    if (this.feature._latlngs.length && this.feature._latlngs[0].length) {
                        const d = [];
                        return this.appendShape(d),
                        d
                    }
                    return this.feature._latlngs
                },
                ensureMulti: function() {
                    this.feature._latlngs.length && _(this.feature._latlngs[0]) && (this.feature._latlngs = [this.feature._latlngs])
                },
                ensureNotFlat: function() {
                    (!this.feature._latlngs.length || _(this.feature._latlngs)) && (this.feature._latlngs = [this.feature._latlngs])
                },
                vertexCanBeDeleted: function(d) {
                    const g = this.feature.parentShape(d.latlngs);
                    return n.Util.indexOf(g, d.latlngs) > 0 ? !0 : n.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, d)
                },
                getDefaultLatLngs: function() {
                    return this.feature._latlngs.length || this.feature._latlngs.push([]),
                    this.feature._latlngs[0]
                },
                formatShape: d=>_(d) && (!d[0] || d[0].length !== 0) ? [d] : d
            }),
            n.Editable.RectangleEditor = n.Editable.PathEditor.extend({
                CLOSED: !0,
                MIN_VERTEX: 4,
                options: {
                    skipMiddleMarkers: !0
                },
                extendBounds: function(d) {
                    const g = d.vertex.getIndex()
                      , b = d.vertex.getNext()
                      , T = d.vertex.getPrevious()
                      , N = (g + 2) % 4
                      , A = d.vertex.latlngs[N]
                      , R = new n.LatLngBounds(d.latlng,A);
                    T.latlng.update([d.latlng.lat, A.lng]),
                    b.latlng.update([A.lat, d.latlng.lng]),
                    this.updateBounds(R),
                    this.refreshVertexMarkers()
                },
                onDrawingMouseDown: function(d) {
                    n.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, d),
                    this.connect();
                    const g = this.getDefaultLatLngs();
                    g.length === 3 && g.push(d.latlng);
                    const b = new n.LatLngBounds(d.latlng,d.latlng);
                    this.updateBounds(b),
                    this.updateLatLngs(b),
                    this.refresh(),
                    this.reset(),
                    d.originalEvent._simulated = !1,
                    this.map.dragging._draggable._onUp(d.originalEvent),
                    g[3].__vertex.dragging._draggable._onDown(d.originalEvent)
                },
                onDrawingMouseUp: function(d) {
                    this.commitDrawing(d),
                    d.originalEvent._simulated = !1,
                    n.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, d)
                },
                onDrawingMouseMove: function(d) {
                    d.originalEvent._simulated = !1,
                    n.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, d)
                },
                getDefaultLatLngs: function(d) {
                    return d || this.feature._latlngs[0]
                },
                updateBounds: function(d) {
                    this.feature._bounds = d
                },
                updateLatLngs: function(d) {
                    const g = this.getDefaultLatLngs()
                      , b = this.feature._boundsToLatLngs(d);
                    for (let T = 0; T < g.length; T++)
                        g[T].update(b[T])
                }
            }),
            n.Editable.CircleEditor = n.Editable.PathEditor.extend({
                MIN_VERTEX: 2,
                options: {
                    skipMiddleMarkers: !0
                },
                initialize: function(d, g, b) {
                    n.Editable.PathEditor.prototype.initialize.call(this, d, g, b),
                    this._resizeLatLng = this.computeResizeLatLng()
                },
                computeResizeLatLng: function() {
                    const d = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4)
                      , g = this.map.project(this.feature._latlng);
                    return this.map.unproject([g.x + d, g.y - d])
                },
                updateResizeLatLng: function() {
                    this._resizeLatLng.update(this.computeResizeLatLng()),
                    this._resizeLatLng.__vertex.update()
                },
                getLatLngs: function() {
                    return [this.feature._latlng, this._resizeLatLng]
                },
                getDefaultLatLngs: function() {
                    return this.getLatLngs()
                },
                onVertexMarkerDrag: function(d) {
                    d.vertex.getIndex() === 1 ? this.resize(d) : this.updateResizeLatLng(d),
                    n.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, d)
                },
                resize: function(d) {
                    let g;
                    this.map.options.crs ? g = this.map.options.crs.distance(this.feature._latlng, d.latlng) : g = this.feature._latlng.distanceTo(d.latlng),
                    this.feature.setRadius(g)
                },
                onDrawingMouseDown: function(d) {
                    n.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, d),
                    this._resizeLatLng.update(d.latlng),
                    this.feature._latlng.update(d.latlng),
                    this.connect(),
                    d.originalEvent._simulated = !1,
                    this.map.dragging._draggable._onUp(d.originalEvent),
                    this._resizeLatLng.__vertex.dragging._draggable._onDown(d.originalEvent)
                },
                onDrawingMouseUp: function(d) {
                    this.commitDrawing(d),
                    d.originalEvent._simulated = !1,
                    n.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, d)
                },
                onDrawingMouseMove: function(d) {
                    d.originalEvent._simulated = !1,
                    n.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, d)
                },
                onDrag: function(d) {
                    n.Editable.PathEditor.prototype.onDrag.call(this, d),
                    this.feature.dragging.updateLatLng(this._resizeLatLng)
                }
            });
            const r = {
                createEditor: function(d) {
                    d = d || this._map;
                    const g = this.options.editOptions?.editTools || d.editTools;
                    if (!g)
                        throw Error("Unable to detect Editable instance.");
                    const b = this.options.editorClass || this.getEditorClass(g);
                    return new b(d,this,this.options.editOptions)
                },
                enableEdit: function(d) {
                    return this.editor || this.createEditor(d),
                    this.editor.enable(),
                    this.editor
                },
                editEnabled: function() {
                    return this.editor?.enabled()
                },
                disableEdit: function() {
                    this.editor && (this.editor.disable(),
                    delete this.editor)
                },
                toggleEdit: function() {
                    this.editEnabled() ? this.disableEdit() : this.enableEdit()
                },
                _onEditableAdd: function() {
                    this.editor && this.enableEdit()
                }
            }
              , o = {
                getEditorClass: d=>d?.options?.polylineEditorClass || n.Editable.PolylineEditor,
                shapeAt: function(d, g) {
                    let b = null;
                    if (g = g || this._latlngs,
                    !g.length)
                        return b;
                    if (_(g) && this.isInLatLngs(d, g))
                        b = g;
                    else
                        for (const T of g)
                            if (this.isInLatLngs(d, T))
                                return T;
                    return b
                },
                isInLatLngs: function(d, g) {
                    if (!g)
                        return !1;
                    let b, T, N, A = [], R;
                    const S = this._clickTolerance();
                    if (this._projectLatlngs(g, A, this._pxBounds),
                    A = A[0],
                    R = this._map.latLngToLayerPoint(d),
                    !this._pxBounds.contains(R))
                        return !1;
                    for (b = 1,
                    N = A.length,
                    T = 0; b < N; T = b++)
                        if (n.LineUtil.pointToSegmentDistance(R, A[T], A[b]) <= S)
                            return !0;
                    return !1
                }
            }
              , a = {
                getEditorClass: d=>d?.options?.polygonEditorClass || n.Editable.PolygonEditor,
                shapeAt: function(d, g) {
                    let b = null;
                    if (g = g || this._latlngs,
                    !g.length)
                        return b;
                    if (_(g) && this.isInLatLngs(d, g) && (b = g),
                    _(g[0]) && this.isInLatLngs(d, g[0]))
                        b = g;
                    else
                        for (const T of g)
                            if (this.isInLatLngs(d, T[0]))
                                return T;
                    return b
                },
                isInLatLngs: (d,g)=>{
                    let b = !1, T, N, A, R, S;
                    for (A = 0,
                    S = g.length,
                    R = S - 1; A < S; R = A++)
                        T = g[A],
                        N = g[R],
                        T.lat > d.lat != N.lat > d.lat && d.lng < (N.lng - T.lng) * (d.lat - T.lat) / (N.lat - T.lat) + T.lng && (b = !b);
                    return b
                }
                ,
                parentShape: function(d, g) {
                    if (g = g || this._latlngs,
                    !g)
                        return;
                    let b = n.Util.indexOf(g, d);
                    if (b !== -1)
                        return g;
                    for (const T of g)
                        if (b = n.Util.indexOf(T, d),
                        b !== -1)
                            return T
                }
            }
              , l = {
                getEditorClass: d=>d?.options?.markerEditorClass || n.Editable.MarkerEditor
            }
              , u = {
                getEditorClass: d=>d?.options?.circleMarkerEditorClass || n.Editable.CircleMarkerEditor
            }
              , f = {
                getEditorClass: d=>d?.options?.rectangleEditorClass || n.Editable.RectangleEditor
            }
              , h = {
                getEditorClass: d=>d?.options?.circleEditorClass || n.Editable.CircleEditor
            }
              , m = function() {
                this.on("add", this._onEditableAdd)
            }
              , _ = n.LineUtil.isFlat || n.LineUtil._flat || n.Polyline._flat;
            n.Polyline && (n.Polyline.include(r),
            n.Polyline.include(o),
            n.Polyline.addInitHook(m)),
            n.Polygon && (n.Polygon.include(r),
            n.Polygon.include(a)),
            n.Marker && (n.Marker.include(r),
            n.Marker.include(l),
            n.Marker.addInitHook(m)),
            n.CircleMarker && (n.CircleMarker.include(r),
            n.CircleMarker.include(u),
            n.CircleMarker.addInitHook(m)),
            n.Rectangle && (n.Rectangle.include(r),
            n.Rectangle.include(f)),
            n.Circle && (n.Circle.include(r),
            n.Circle.include(h)),
            n.LatLng.prototype.update = function(d) {
                d = n.latLng(d),
                this.lat = d.lat,
                this.lng = d.lng
            }
        }
        , window)
    }
    )(_l)),
    _l.exports
}
y0();
const v0 = `/* required styles */\r
\r
.leaflet-pane,\r
.leaflet-tile,\r
.leaflet-marker-icon,\r
.leaflet-marker-shadow,\r
.leaflet-tile-container,\r
.leaflet-pane > svg,\r
.leaflet-pane > canvas,\r
.leaflet-zoom-box,\r
.leaflet-image-layer,\r
.leaflet-layer {\r
	position: absolute;\r
	left: 0;\r
	top: 0;\r
	}\r
.leaflet-container {\r
	overflow: hidden;\r
	}\r
.leaflet-tile,\r
.leaflet-marker-icon,\r
.leaflet-marker-shadow {\r
	-webkit-user-select: none;\r
	   -moz-user-select: none;\r
	        user-select: none;\r
	  -webkit-user-drag: none;\r
	}\r
/* Prevents IE11 from highlighting tiles in blue */\r
.leaflet-tile::selection {\r
	background: transparent;\r
}\r
/* Safari renders non-retina tile on retina better with this, but Chrome is worse */\r
.leaflet-safari .leaflet-tile {\r
	image-rendering: -webkit-optimize-contrast;\r
	}\r
/* hack that prevents hw layers "stretching" when loading new tiles */\r
.leaflet-safari .leaflet-tile-container {\r
	width: 1600px;\r
	height: 1600px;\r
	-webkit-transform-origin: 0 0;\r
	}\r
.leaflet-marker-icon,\r
.leaflet-marker-shadow {\r
	display: block;\r
	}\r
/* .leaflet-container svg: reset svg max-width decleration shipped in Joomla! (joomla.org) 3.x */\r
/* .leaflet-container img: map is broken in FF if you have max-width: 100% on tiles */\r
.leaflet-container .leaflet-overlay-pane svg {\r
	max-width: none !important;\r
	max-height: none !important;\r
	}\r
.leaflet-container .leaflet-marker-pane img,\r
.leaflet-container .leaflet-shadow-pane img,\r
.leaflet-container .leaflet-tile-pane img,\r
.leaflet-container img.leaflet-image-layer,\r
.leaflet-container .leaflet-tile {\r
	max-width: none !important;\r
	max-height: none !important;\r
	width: auto;\r
	padding: 0;\r
	}\r
\r
.leaflet-container img.leaflet-tile {\r
	/* See: https://bugs.chromium.org/p/chromium/issues/detail?id=600120 */\r
	mix-blend-mode: plus-lighter;\r
}\r
\r
.leaflet-container.leaflet-touch-zoom {\r
	-ms-touch-action: pan-x pan-y;\r
	touch-action: pan-x pan-y;\r
	}\r
.leaflet-container.leaflet-touch-drag {\r
	-ms-touch-action: pinch-zoom;\r
	/* Fallback for FF which doesn't support pinch-zoom */\r
	touch-action: none;\r
	touch-action: pinch-zoom;\r
}\r
.leaflet-container.leaflet-touch-drag.leaflet-touch-zoom {\r
	-ms-touch-action: none;\r
	touch-action: none;\r
}\r
.leaflet-container {\r
	-webkit-tap-highlight-color: transparent;\r
}\r
.leaflet-container a {\r
	-webkit-tap-highlight-color: rgba(51, 181, 229, 0.4);\r
}\r
.leaflet-tile {\r
	filter: inherit;\r
	visibility: hidden;\r
	}\r
.leaflet-tile-loaded {\r
	visibility: inherit;\r
	}\r
.leaflet-zoom-box {\r
	width: 0;\r
	height: 0;\r
	-moz-box-sizing: border-box;\r
	     box-sizing: border-box;\r
	z-index: 800;\r
	}\r
/* workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=888319 */\r
.leaflet-overlay-pane svg {\r
	-moz-user-select: none;\r
	}\r
\r
.leaflet-pane         { z-index: 400; }\r
\r
.leaflet-tile-pane    { z-index: 200; }\r
.leaflet-overlay-pane { z-index: 400; }\r
.leaflet-shadow-pane  { z-index: 500; }\r
.leaflet-marker-pane  { z-index: 600; }\r
.leaflet-tooltip-pane   { z-index: 650; }\r
.leaflet-popup-pane   { z-index: 700; }\r
\r
.leaflet-map-pane canvas { z-index: 100; }\r
.leaflet-map-pane svg    { z-index: 200; }\r
\r
.leaflet-vml-shape {\r
	width: 1px;\r
	height: 1px;\r
	}\r
.lvml {\r
	behavior: url(#default#VML);\r
	display: inline-block;\r
	position: absolute;\r
	}\r
\r
\r
/* control positioning */\r
\r
.leaflet-control {\r
	position: relative;\r
	z-index: 800;\r
	pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\r
	pointer-events: auto;\r
	}\r
.leaflet-top,\r
.leaflet-bottom {\r
	position: absolute;\r
	z-index: 1000;\r
	pointer-events: none;\r
	}\r
.leaflet-top {\r
	top: 0;\r
	}\r
.leaflet-right {\r
	right: 0;\r
	}\r
.leaflet-bottom {\r
	bottom: 0;\r
	}\r
.leaflet-left {\r
	left: 0;\r
	}\r
.leaflet-control {\r
	float: left;\r
	clear: both;\r
	}\r
.leaflet-right .leaflet-control {\r
	float: right;\r
	}\r
.leaflet-top .leaflet-control {\r
	margin-top: 10px;\r
	}\r
.leaflet-bottom .leaflet-control {\r
	margin-bottom: 10px;\r
	}\r
.leaflet-left .leaflet-control {\r
	margin-left: 10px;\r
	}\r
.leaflet-right .leaflet-control {\r
	margin-right: 10px;\r
	}\r
\r
\r
/* zoom and fade animations */\r
\r
.leaflet-fade-anim .leaflet-popup {\r
	opacity: 0;\r
	-webkit-transition: opacity 0.2s linear;\r
	   -moz-transition: opacity 0.2s linear;\r
	        transition: opacity 0.2s linear;\r
	}\r
.leaflet-fade-anim .leaflet-map-pane .leaflet-popup {\r
	opacity: 1;\r
	}\r
.leaflet-zoom-animated {\r
	-webkit-transform-origin: 0 0;\r
	    -ms-transform-origin: 0 0;\r
	        transform-origin: 0 0;\r
	}\r
svg.leaflet-zoom-animated {\r
	will-change: transform;\r
}\r
\r
.leaflet-zoom-anim .leaflet-zoom-animated {\r
	-webkit-transition: -webkit-transform 0.25s cubic-bezier(0,0,0.25,1);\r
	   -moz-transition:    -moz-transform 0.25s cubic-bezier(0,0,0.25,1);\r
	        transition:         transform 0.25s cubic-bezier(0,0,0.25,1);\r
	}\r
.leaflet-zoom-anim .leaflet-tile,\r
.leaflet-pan-anim .leaflet-tile {\r
	-webkit-transition: none;\r
	   -moz-transition: none;\r
	        transition: none;\r
	}\r
\r
.leaflet-zoom-anim .leaflet-zoom-hide {\r
	visibility: hidden;\r
	}\r
\r
\r
/* cursors */\r
\r
.leaflet-interactive {\r
	cursor: pointer;\r
	}\r
.leaflet-grab {\r
	cursor: -webkit-grab;\r
	cursor:    -moz-grab;\r
	cursor:         grab;\r
	}\r
.leaflet-crosshair,\r
.leaflet-crosshair .leaflet-interactive {\r
	cursor: crosshair;\r
	}\r
.leaflet-popup-pane,\r
.leaflet-control {\r
	cursor: auto;\r
	}\r
.leaflet-dragging .leaflet-grab,\r
.leaflet-dragging .leaflet-grab .leaflet-interactive,\r
.leaflet-dragging .leaflet-marker-draggable {\r
	cursor: move;\r
	cursor: -webkit-grabbing;\r
	cursor:    -moz-grabbing;\r
	cursor:         grabbing;\r
	}\r
\r
/* marker & overlays interactivity */\r
.leaflet-marker-icon,\r
.leaflet-marker-shadow,\r
.leaflet-image-layer,\r
.leaflet-pane > svg path,\r
.leaflet-tile-container {\r
	pointer-events: none;\r
	}\r
\r
.leaflet-marker-icon.leaflet-interactive,\r
.leaflet-image-layer.leaflet-interactive,\r
.leaflet-pane > svg path.leaflet-interactive,\r
svg.leaflet-image-layer.leaflet-interactive path {\r
	pointer-events: visiblePainted; /* IE 9-10 doesn't have auto */\r
	pointer-events: auto;\r
	}\r
\r
/* visual tweaks */\r
\r
.leaflet-container {\r
	background: #ddd;\r
	outline-offset: 1px;\r
	}\r
.leaflet-container a {\r
	color: #0078A8;\r
	}\r
.leaflet-zoom-box {\r
	border: 2px dotted #38f;\r
	background: rgba(255,255,255,0.5);\r
	}\r
\r
\r
/* general typography */\r
.leaflet-container {\r
	font-family: "Helvetica Neue", Arial, Helvetica, sans-serif;\r
	font-size: 12px;\r
	font-size: 0.75rem;\r
	line-height: 1.5;\r
	}\r
\r
\r
/* general toolbar styles */\r
\r
.leaflet-bar {\r
	box-shadow: 0 1px 5px rgba(0,0,0,0.65);\r
	border-radius: 4px;\r
	}\r
.leaflet-bar a {\r
	background-color: #fff;\r
	border-bottom: 1px solid #ccc;\r
	width: 26px;\r
	height: 26px;\r
	line-height: 26px;\r
	display: block;\r
	text-align: center;\r
	text-decoration: none;\r
	color: black;\r
	}\r
.leaflet-bar a,\r
.leaflet-control-layers-toggle {\r
	background-position: 50% 50%;\r
	background-repeat: no-repeat;\r
	display: block;\r
	}\r
.leaflet-bar a:hover,\r
.leaflet-bar a:focus {\r
	background-color: #f4f4f4;\r
	}\r
.leaflet-bar a:first-child {\r
	border-top-left-radius: 4px;\r
	border-top-right-radius: 4px;\r
	}\r
.leaflet-bar a:last-child {\r
	border-bottom-left-radius: 4px;\r
	border-bottom-right-radius: 4px;\r
	border-bottom: none;\r
	}\r
.leaflet-bar a.leaflet-disabled {\r
	cursor: default;\r
	background-color: #f4f4f4;\r
	color: #bbb;\r
	}\r
\r
.leaflet-touch .leaflet-bar a {\r
	width: 30px;\r
	height: 30px;\r
	line-height: 30px;\r
	}\r
.leaflet-touch .leaflet-bar a:first-child {\r
	border-top-left-radius: 2px;\r
	border-top-right-radius: 2px;\r
	}\r
.leaflet-touch .leaflet-bar a:last-child {\r
	border-bottom-left-radius: 2px;\r
	border-bottom-right-radius: 2px;\r
	}\r
\r
/* zoom control */\r
\r
.leaflet-control-zoom-in,\r
.leaflet-control-zoom-out {\r
	font: bold 18px 'Lucida Console', Monaco, monospace;\r
	text-indent: 1px;\r
	}\r
\r
.leaflet-touch .leaflet-control-zoom-in, .leaflet-touch .leaflet-control-zoom-out  {\r
	font-size: 22px;\r
	}\r
\r
\r
/* layers control */\r
\r
.leaflet-control-layers {\r
	box-shadow: 0 1px 5px rgba(0,0,0,0.4);\r
	background: #fff;\r
	border-radius: 5px;\r
	}\r
.leaflet-control-layers-toggle {\r
	background-image: url(images/layers.png);\r
	width: 36px;\r
	height: 36px;\r
	}\r
.leaflet-retina .leaflet-control-layers-toggle {\r
	background-image: url(images/layers-2x.png);\r
	background-size: 26px 26px;\r
	}\r
.leaflet-touch .leaflet-control-layers-toggle {\r
	width: 44px;\r
	height: 44px;\r
	}\r
.leaflet-control-layers .leaflet-control-layers-list,\r
.leaflet-control-layers-expanded .leaflet-control-layers-toggle {\r
	display: none;\r
	}\r
.leaflet-control-layers-expanded .leaflet-control-layers-list {\r
	display: block;\r
	position: relative;\r
	}\r
.leaflet-control-layers-expanded {\r
	padding: 6px 10px 6px 6px;\r
	color: #333;\r
	background: #fff;\r
	}\r
.leaflet-control-layers-scrollbar {\r
	overflow-y: scroll;\r
	overflow-x: hidden;\r
	padding-right: 5px;\r
	}\r
.leaflet-control-layers-selector {\r
	margin-top: 2px;\r
	position: relative;\r
	top: 1px;\r
	}\r
.leaflet-control-layers label {\r
	display: block;\r
	font-size: 13px;\r
	font-size: 1.08333em;\r
	}\r
.leaflet-control-layers-separator {\r
	height: 0;\r
	border-top: 1px solid #ddd;\r
	margin: 5px -10px 5px -6px;\r
	}\r
\r
/* Default icon URLs */\r
.leaflet-default-icon-path { /* used only in path-guessing heuristic, see L.Icon.Default */\r
	background-image: url(images/marker-icon.png);\r
	}\r
\r
\r
/* attribution and scale controls */\r
\r
.leaflet-container .leaflet-control-attribution {\r
	background: #fff;\r
	background: rgba(255, 255, 255, 0.8);\r
	margin: 0;\r
	}\r
.leaflet-control-attribution,\r
.leaflet-control-scale-line {\r
	padding: 0 5px;\r
	color: #333;\r
	line-height: 1.4;\r
	}\r
.leaflet-control-attribution a {\r
	text-decoration: none;\r
	}\r
.leaflet-control-attribution a:hover,\r
.leaflet-control-attribution a:focus {\r
	text-decoration: underline;\r
	}\r
.leaflet-attribution-flag {\r
	display: inline !important;\r
	vertical-align: baseline !important;\r
	width: 1em;\r
	height: 0.6669em;\r
	}\r
.leaflet-left .leaflet-control-scale {\r
	margin-left: 5px;\r
	}\r
.leaflet-bottom .leaflet-control-scale {\r
	margin-bottom: 5px;\r
	}\r
.leaflet-control-scale-line {\r
	border: 2px solid #777;\r
	border-top: none;\r
	line-height: 1.1;\r
	padding: 2px 5px 1px;\r
	white-space: nowrap;\r
	-moz-box-sizing: border-box;\r
	     box-sizing: border-box;\r
	background: rgba(255, 255, 255, 0.8);\r
	text-shadow: 1px 1px #fff;\r
	}\r
.leaflet-control-scale-line:not(:first-child) {\r
	border-top: 2px solid #777;\r
	border-bottom: none;\r
	margin-top: -2px;\r
	}\r
.leaflet-control-scale-line:not(:first-child):not(:last-child) {\r
	border-bottom: 2px solid #777;\r
	}\r
\r
.leaflet-touch .leaflet-control-attribution,\r
.leaflet-touch .leaflet-control-layers,\r
.leaflet-touch .leaflet-bar {\r
	box-shadow: none;\r
	}\r
.leaflet-touch .leaflet-control-layers,\r
.leaflet-touch .leaflet-bar {\r
	border: 2px solid rgba(0,0,0,0.2);\r
	background-clip: padding-box;\r
	}\r
\r
\r
/* popup */\r
\r
.leaflet-popup {\r
	position: absolute;\r
	text-align: center;\r
	margin-bottom: 20px;\r
	}\r
.leaflet-popup-content-wrapper {\r
	padding: 1px;\r
	text-align: left;\r
	border-radius: 12px;\r
	}\r
.leaflet-popup-content {\r
	margin: 13px 24px 13px 20px;\r
	line-height: 1.3;\r
	font-size: 13px;\r
	font-size: 1.08333em;\r
	min-height: 1px;\r
	}\r
.leaflet-popup-content p {\r
	margin: 17px 0;\r
	margin: 1.3em 0;\r
	}\r
.leaflet-popup-tip-container {\r
	width: 40px;\r
	height: 20px;\r
	position: absolute;\r
	left: 50%;\r
	margin-top: -1px;\r
	margin-left: -20px;\r
	overflow: hidden;\r
	pointer-events: none;\r
	}\r
.leaflet-popup-tip {\r
	width: 17px;\r
	height: 17px;\r
	padding: 1px;\r
\r
	margin: -10px auto 0;\r
	pointer-events: auto;\r
\r
	-webkit-transform: rotate(45deg);\r
	   -moz-transform: rotate(45deg);\r
	    -ms-transform: rotate(45deg);\r
	        transform: rotate(45deg);\r
	}\r
.leaflet-popup-content-wrapper,\r
.leaflet-popup-tip {\r
	background: white;\r
	color: #333;\r
	box-shadow: 0 3px 14px rgba(0,0,0,0.4);\r
	}\r
.leaflet-container a.leaflet-popup-close-button {\r
	position: absolute;\r
	top: 0;\r
	right: 0;\r
	border: none;\r
	text-align: center;\r
	width: 24px;\r
	height: 24px;\r
	font: 16px/24px Tahoma, Verdana, sans-serif;\r
	color: #757575;\r
	text-decoration: none;\r
	background: transparent;\r
	}\r
.leaflet-container a.leaflet-popup-close-button:hover,\r
.leaflet-container a.leaflet-popup-close-button:focus {\r
	color: #585858;\r
	}\r
.leaflet-popup-scrolled {\r
	overflow: auto;\r
	}\r
\r
.leaflet-oldie .leaflet-popup-content-wrapper {\r
	-ms-zoom: 1;\r
	}\r
.leaflet-oldie .leaflet-popup-tip {\r
	width: 24px;\r
	margin: 0 auto;\r
\r
	-ms-filter: "progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678)";\r
	filter: progid:DXImageTransform.Microsoft.Matrix(M11=0.70710678, M12=0.70710678, M21=-0.70710678, M22=0.70710678);\r
	}\r
\r
.leaflet-oldie .leaflet-control-zoom,\r
.leaflet-oldie .leaflet-control-layers,\r
.leaflet-oldie .leaflet-popup-content-wrapper,\r
.leaflet-oldie .leaflet-popup-tip {\r
	border: 1px solid #999;\r
	}\r
\r
\r
/* div icon */\r
\r
.leaflet-div-icon {\r
	background: #fff;\r
	border: 1px solid #666;\r
	}\r
\r
\r
/* Tooltip */\r
/* Base styles for the element that has a tooltip */\r
.leaflet-tooltip {\r
	position: absolute;\r
	padding: 6px;\r
	background-color: #fff;\r
	border: 1px solid #fff;\r
	border-radius: 3px;\r
	color: #222;\r
	white-space: nowrap;\r
	-webkit-user-select: none;\r
	-moz-user-select: none;\r
	-ms-user-select: none;\r
	user-select: none;\r
	pointer-events: none;\r
	box-shadow: 0 1px 3px rgba(0,0,0,0.4);\r
	}\r
.leaflet-tooltip.leaflet-interactive {\r
	cursor: pointer;\r
	pointer-events: auto;\r
	}\r
.leaflet-tooltip-top:before,\r
.leaflet-tooltip-bottom:before,\r
.leaflet-tooltip-left:before,\r
.leaflet-tooltip-right:before {\r
	position: absolute;\r
	pointer-events: none;\r
	border: 6px solid transparent;\r
	background: transparent;\r
	content: "";\r
	}\r
\r
/* Directions */\r
\r
.leaflet-tooltip-bottom {\r
	margin-top: 6px;\r
}\r
.leaflet-tooltip-top {\r
	margin-top: -6px;\r
}\r
.leaflet-tooltip-bottom:before,\r
.leaflet-tooltip-top:before {\r
	left: 50%;\r
	margin-left: -6px;\r
	}\r
.leaflet-tooltip-top:before {\r
	bottom: 0;\r
	margin-bottom: -12px;\r
	border-top-color: #fff;\r
	}\r
.leaflet-tooltip-bottom:before {\r
	top: 0;\r
	margin-top: -12px;\r
	margin-left: -6px;\r
	border-bottom-color: #fff;\r
	}\r
.leaflet-tooltip-left {\r
	margin-left: -6px;\r
}\r
.leaflet-tooltip-right {\r
	margin-left: 6px;\r
}\r
.leaflet-tooltip-left:before,\r
.leaflet-tooltip-right:before {\r
	top: 50%;\r
	margin-top: -6px;\r
	}\r
.leaflet-tooltip-left:before {\r
	right: 0;\r
	margin-right: -12px;\r
	border-left-color: #fff;\r
	}\r
.leaflet-tooltip-right:before {\r
	left: 0;\r
	margin-left: -12px;\r
	border-right-color: #fff;\r
	}\r
\r
/* Printing */\r
\r
@media print {\r
	/* Prevent printers from removing background-images of controls. */\r
	.leaflet-control {\r
		-webkit-print-color-adjust: exact;\r
		print-color-adjust: exact;\r
		}\r
	}\r
`
  , b0 = `.leaflet-fullscreen-icon {
	background-image: url('icon-fullscreen.svg');
	background-size: 26px 52px;
}

.leaflet-fullscreen-icon.leaflet-fullscreen-on {
	background-position: 0 -26px;
}

.leaflet-touch .leaflet-fullscreen-icon {
	background-position: 2px 2px;
}

.leaflet-touch .leaflet-fullscreen-icon.leaflet-fullscreen-on {
	background-position: 2px -24px;
}

/* Safari still needs this vendor-prefix: https://caniuse.com/mdn-css_selectors_fullscreen */
/* stylelint-disable-next-line selector-no-vendor-prefix */
.leaflet-container:-webkit-full-screen {
	width: 100% !important;
	height: 100% !important;
	z-index: 99999;
}

.leaflet-container:fullscreen {
	width: 100% !important;
	height: 100% !important;
	z-index: 99999;
}

.leaflet-pseudo-fullscreen {
	position: fixed !important;
	width: 100% !important;
	height: 100% !important;
	top: 0 !important;
	left: 0 !important;
	z-index: 99999;
}
`;
var Ms = {
    exports: {}
}, w0 = Ms.exports, Wh;
function x0() {
    return Wh || (Wh = 1,
    (function(i) {
        (function(e, n) {
            i.exports ? i.exports = n(uu()) : n(e.L)
        }
        )(typeof self < "u" ? self : w0, e=>{
            if (typeof document > "u")
                return console.warn('"window.document" is undefined; leaflet.fullscreen requires this object to access the DOM'),
                !1;
            const n = (()=>{
                const a = [["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"], ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"]]
                  , l = a[0]
                  , u = {};
                for (const f of a)
                    if (f[1]in document) {
                        for (let h = 0; h < f.length; h++)
                            u[l[h]] = f[h];
                        return u
                    }
                return !1
            }
            )()
              , r = {
                change: n.fullscreenchange,
                error: n.fullscreenerror
            }
              , o = {
                request(a, l) {
                    return new Promise((u,f)=>{
                        const h = (function() {
                            this.off("change", h),
                            u()
                        }
                        ).bind(this);
                        this.on("change", h),
                        a = a || document.documentElement;
                        const m = a[n.requestFullscreen](l);
                        m instanceof Promise && m.then(h).catch(f)
                    }
                    )
                },
                exit() {
                    return new Promise((a,l)=>{
                        if (!this.isFullscreen) {
                            a();
                            return
                        }
                        const u = (function() {
                            this.off("change", u),
                            a()
                        }
                        ).bind(this);
                        this.on("change", u);
                        const f = document[n.exitFullscreen]();
                        f instanceof Promise && f.then(u).catch(l)
                    }
                    )
                },
                on(a, l) {
                    const u = r[a];
                    u && document.addEventListener(u, l, !1)
                },
                off(a, l) {
                    const u = r[a];
                    u && document.removeEventListener(u, l, !1)
                },
                nativeAPI: n
            };
            return Object.defineProperties(o, {
                isFullscreen: {
                    get() {
                        return !!document[n.fullscreenElement]
                    }
                },
                isEnabled: {
                    enumerable: !0,
                    get() {
                        return !!document[n.fullscreenEnabled]
                    }
                }
            }),
            e.Control.FullScreen = e.Control.extend({
                options: {
                    position: "topleft",
                    title: "Full Screen",
                    titleCancel: "Exit Full Screen",
                    forceSeparateButton: !1,
                    forcePseudoFullscreen: !1,
                    fullscreenElement: !1
                },
                _screenfull: o,
                onAdd(a) {
                    let l = "leaflet-control-zoom-fullscreen", u, f = "";
                    return a.zoomControl && !this.options.forceSeparateButton ? u = a.zoomControl._container : u = e.DomUtil.create("div", "leaflet-bar"),
                    this.options.content ? f = this.options.content : l += " leaflet-fullscreen-icon",
                    this._createButton(this.options.title, l, f, u, this.toggleFullScreen, this),
                    this._map.fullscreenControl = this,
                    this._map.on("enterFullscreen exitFullscreen", this._toggleState, this),
                    u
                },
                onRemove() {
                    e.DomEvent.off(this.link, "click", e.DomEvent.stop).off(this.link, "click", this.toggleFullScreen, this),
                    this._screenfull.isEnabled && (e.DomEvent.off(this._container, this._screenfull.nativeAPI.fullscreenchange, e.DomEvent.stop).off(this._container, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, this),
                    e.DomEvent.off(document, this._screenfull.nativeAPI.fullscreenchange, e.DomEvent.stop).off(document, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, this))
                },
                _createButton(a, l, u, f, h, m) {
                    return this.link = e.DomUtil.create("a", l, f),
                    this.link.href = "#",
                    this.link.title = a,
                    this.link.innerHTML = u,
                    this.link.setAttribute("role", "button"),
                    this.link.setAttribute("aria-label", a),
                    L.DomEvent.disableClickPropagation(f),
                    e.DomEvent.on(this.link, "click", e.DomEvent.stop).on(this.link, "click", h, m),
                    this._screenfull.isEnabled && (e.DomEvent.on(f, this._screenfull.nativeAPI.fullscreenchange, e.DomEvent.stop).on(f, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, m),
                    e.DomEvent.on(document, this._screenfull.nativeAPI.fullscreenchange, e.DomEvent.stop).on(document, this._screenfull.nativeAPI.fullscreenchange, this._handleFullscreenChange, m)),
                    this.link
                },
                toggleFullScreen() {
                    const a = this._map;
                    a._exitFired = !1,
                    a._isFullscreen ? (this._screenfull.isEnabled && !this.options.forcePseudoFullscreen ? this._screenfull.exit().then(()=>a.invalidateSize()) : (e.DomUtil.removeClass(this.options.fullscreenElement ? this.options.fullscreenElement : a._container, "leaflet-pseudo-fullscreen"),
                    a.invalidateSize()),
                    a.fire("exitFullscreen"),
                    a._exitFired = !0,
                    a._isFullscreen = !1) : (this._screenfull.isEnabled && !this.options.forcePseudoFullscreen ? this._screenfull.request(this.options.fullscreenElement ? this.options.fullscreenElement : a._container).then(()=>a.invalidateSize()) : (e.DomUtil.addClass(this.options.fullscreenElement ? this.options.fullscreenElement : a._container, "leaflet-pseudo-fullscreen"),
                    a.invalidateSize()),
                    a.fire("enterFullscreen"),
                    a._isFullscreen = !0)
                },
                _toggleState() {
                    this.link.title = this._map._isFullscreen ? this.options.title : this.options.titleCancel,
                    this._map._isFullscreen ? L.DomUtil.removeClass(this.link, "leaflet-fullscreen-on") : L.DomUtil.addClass(this.link, "leaflet-fullscreen-on")
                },
                _handleFullscreenChange(a) {
                    const l = this._map;
                    a.target === l.getContainer() && !this._screenfull.isFullscreen && !l._exitFired && (this._screenfull.exit().then(()=>l.invalidateSize()),
                    l.fire("exitFullscreen"),
                    l._exitFired = !0,
                    l._isFullscreen = !1)
                }
            }),
            e.Map.include({
                toggleFullscreen() {
                    this.fullscreenControl.toggleFullScreen()
                }
            }),
            e.Map.addInitHook(function() {
                this.options.fullscreenControl && this.addControl(e.control.fullscreen(this.options.fullscreenControlOptions))
            }),
            e.control.fullscreen = function(a) {
                return new e.Control.FullScreen(a)
            }
            ,
            {
                leaflet: e
            }
        }
        )
    }
    )(Ms)),
    Ms.exports
}
x0();
const E0 = `
#shaclMapDialog .closeButton { position: absolute; right: 0; top: 0; z-index: 1; padding: 6px 8px; cursor: pointer; border: 0; background-color: #FFFA; font-size: 24px; z-index: 1000; }
#shaclMapDialog { padding: 0; width:90vw; height: 90vh; margin: auto; }
#shaclMapDialog::backdrop { background-color: #0007; }
#shaclMapDialog .closeButton:hover { background-color: #FFF }
#shaclMapDialog .hint { position: absolute; right: 60px; top: 3px; z-index: 1; padding: 4px 6px; background-color: #FFFA; border-radius: 4px; z-index: 1000; pointer-events: none; }
.leaflet-container { min-height: 300px; }
.fullscreen-icon { background-image: url(data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjYgNTIiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTIwLjYgMzYuN0gxNmEuOS45IDAgMCAxLS44LS44di00LjVjMC0uMi4yLS40LjQtLjRoMS40Yy4zIDAgLjUuMi41LjR2M2gzYy4yIDAgLjQuMi40LjV2MS40YzAgLjItLjIuNC0uNC40em0tOS45LS44di00LjVjMC0uMi0uMi0uNC0uNC0uNEg4LjljLS4zIDAtLjUuMi0uNS40djNoLTNjLS4yIDAtLjQuMi0uNC41djEuNGMwIC4yLjIuNC40LjRIMTBjLjQgMCAuOC0uNC44LS44em0wIDEwLjdWNDJjMC0uNC0uNC0uOC0uOC0uOEg1LjRjLS4yIDAtLjQuMi0uNC40djEuNGMwIC4zLjIuNS40LjVoM3YzYzAgLjIuMi40LjUuNGgxLjRjLjIgMCAuNC0uMi40LS40em02LjkgMHYtM2gzYy4yIDAgLjQtLjIuNC0uNXYtMS40YzAtLjItLjItLjQtLjQtLjRIMTZjLS40IDAtLjguNC0uOC44djQuNWMwIC4yLjIuNC40LjRoMS40Yy4zIDAgLjUtLjIuNS0uNHpNNSAxMC4zVjUuOWMwLS41LjQtLjkuOS0uOWg0LjRjLjIgMCAuNC4yLjQuNFY3YzAgLjItLjIuNC0uNC40aC0zdjNjMCAuMi0uMi40LS40LjRINS40YS40LjQgMCAwIDEtLjQtLjR6bTEwLjMtNC45VjdjMCAuMi4yLjQuNC40aDN2M2MwIC4yLjIuNC40LjRoMS41Yy4yIDAgLjQtLjIuNC0uNFY1LjljMC0uNS0uNC0uOS0uOS0uOWgtNC40Yy0uMiAwLS40LjItLjQuNHptNS4zIDkuOUgxOWMtLjIgMC0uNC4yLS40LjR2M2gtM2MtLjIgMC0uNC4yLS40LjR2MS41YzAgLjIuMi40LjQuNGg0LjRjLjUgMCAuOS0uNC45LS45di00LjRjMC0uMi0uMi0uNC0uNC0uNHptLTkuOSA1LjNWMTljMC0uMi0uMi0uNC0uNC0uNGgtM3YtM2MwLS4yLS4yLS40LS40LS40SDUuNGMtLjIgMC0uNC4yLS40LjR2NC40YzAgLjUuNC45LjkuOWg0LjRjLjIgMCAuNC0uMi40LS40eiIgZmlsbD0iY3VycmVudENvbG9yIi8+PC9zdmc+); }
#shaclMapDialogContainer { width:100%; height: 100%; }
`
  , S0 = `
<dialog id="shaclMapDialog" onclick="event.target==this && this.close()">
<div id="shaclMapDialogContainer"></div>
<div class="hint">&#x24D8; Draw a polygon or marker, then close dialog</div>
<button class="closeButton" type="button" onclick="this.parentElement.close()">&#x2715;</button>
</dialog>`
  , Zh = {
    lng: 8.657238961696038,
    lat: 49.87627570549512
}
  , Xh = '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
  , Qh = "https://tile.openstreetmap.de/{z}/{x}/{y}.png"
  , Jh = Dt.icon({
    iconUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABkAAAApCAYAAADAk4LOAAAFgUlEQVR4Aa1XA5BjWRTN2oW17d3YaZtr2962HUzbDNpjszW24mRt28p47v7zq/bXZtrp/lWnXr337j3nPCe85NcypgSFdugCpW5YoDAMRaIMqRi6aKq5E3YqDQO3qAwjVWrD8Ncq/RBpykd8oZUb/kaJutow8r1aP9II0WmLKLIsJyv1w/kqw9Ch2MYdB++12Onxee/QMwvf4/Dk/Lfp/i4nxTXtOoQ4pW5Aj7wpici1A9erdAN2OH64x8OSP9j3Ft3b7aWkTg/Fm91siTra0f9on5sQr9INejH6CUUUpavjFNq1B+Oadhxmnfa8RfEmN8VNAsQhPqF55xHkMzz3jSmChWU6f7/XZKNH+9+hBLOHYozuKQPxyMPUKkrX/K0uWnfFaJGS1QPRtZsOPtr3NsW0uyh6NNCOkU3Yz+bXbT3I8G3xE5EXLXtCXbbqwCO9zPQYPRTZ5vIDXD7U+w7rFDEoUUf7ibHIR4y6bLVPXrz8JVZEql13trxwue/uDivd3fkWRbS6/IA2bID4uk0UpF1N8qLlbBlXs4Ee7HLTfV1j54APvODnSfOWBqtKVvjgLKzF5YdEk5ewRkGlK0i33Eofffc7HT56jD7/6U+qH3Cx7SBLNntH5YIPvODnyfIXZYRVDPqgHtLs5ABHD3YzLuespb7t79FY34DjMwrVrcTuwlT55YMPvOBnRrJ4VXTdNnYug5ucHLBjEpt30701A3Ts+HEa73u6dT3FNWwflY86eMHPk+Yu+i6pzUpRrW7SNDg5JHR4KapmM5Wv2E8Tfcb1HoqqHMHU+uWDD7zg54mz5/2BSnizi9T1Dg4QQXLToGNCkb6tb1NU+QAlGr1++eADrzhn/u8Q2YZhQVlZ5+CAOtqfbhmaUCS1ezNFVm2imDbPmPng5wmz+gwh+oHDce0eUtQ6OGDIyR0uUhUsoO3vfDmmgOezH0mZN59x7MBi++WDL1g/eEiU3avlidO671bkLfwbw5XV2P8Pzo0ydy4t2/0eu33xYSOMOD8hTf4CrBtGMSoXfPLchX+J0ruSePw3LZeK0juPJbYzrhkH0io7B3k164hiGvawhOKMLkrQLyVpZg8rHFW7E2uHOL888IBPlNZ1FPzstSJM694fWr6RwpvcJK60+0HCILTBzZLFNdtAzJaohze60T8qBzyh5ZuOg5e7uwQppofEmf2++DYvmySqGBuKaicF1blQjhuHdvCIMvp8whTTfZzI7RldpwtSzL+F1+wkdZ2TBOW2gIF88PBTzD/gpeREAMEbxnJcaJHNHrpzji0gQCS6hdkEeYt9DF/2qPcEC8RM28Hwmr3sdNyht00byAut2k3gufWNtgtOEOFGUwcXWNDbdNbpgBGxEvKkOQsxivJx33iow0Vw5S6SVTrpVq11ysA2Rp7gTfPfktc6zhtXBBC+adRLshf6sG2RfHPZ5EAc4sVZ83yCN00Fk/4kggu40ZTvIEm5g24qtU4KjBrx/BTTH8ifVASAG7gKrnWxJDcU7x8X6Ecczhm3o6YicvsLXWfh3Ch1W0k8x0nXF+0fFxgt4phz8QvypiwCCFKMqXCnqXExjq10beH+UUA7+nG6mdG/Pu0f3LgFcGrl2s0kNNjpmoJ9o4B29CMO8dMT4Q5ox8uitF6fqsrJOr8qnwNbRzv6hSnG5wP+64C7h9lp30hKNtKdWjtdkbuPA19nJ7Tz3zR/ibgARbhb4AlhavcBebmTHcFl2fvYEnW0ox9xMxKBS8btJ+KiEbq9zA4RthQXDhPa0T9TEe69gWupwc6uBUphquXgf+/FrIjweHQS4/pduMe5ERUMHUd9xv8ZR98CxkS4F2n3EUrUZ10EYNw7BWm9x1GiPssi3GgiGRDKWRYZfXlON+dfNbM+GgIwYdwAAAAASUVORK5CYII=",
    shadowUrl: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACkAAAApCAQAAAACach9AAACMUlEQVR4Ae3ShY7jQBAE0Aoz/f9/HTMzhg1zrdKUrJbdx+Kd2nD8VNudfsL/Th///dyQN2TH6f3y/BGpC379rV+S+qqetBOxImNQXL8JCAr2V4iMQXHGNJxeCfZXhSRBcQMfvkOWUdtfzlLgAENmZDcmo2TVmt8OSM2eXxBp3DjHSMFutqS7SbmemzBiR+xpKCNUIRkdkkYxhAkyGoBvyQFEJEefwSmmvBfJuJ6aKqKWnAkvGZOaZXTUgFqYULWNSHUckZuR1HIIimUExutRxwzOLROIG4vKmCKQt364mIlhSyzAf1m9lHZHJZrlAOMMztRRiKimp/rpdJDc9Awry5xTZCte7FHtuS8wJgeYGrex28xNTd086Dik7vUMscQOa8y4DoGtCCSkAKlNwpgNtphjrC6MIHUkR6YWxxs6Sc5xqn222mmCRFzIt8lEdKx+ikCtg91qS2WpwVfBelJCiQJwvzixfI9cxZQWgiSJelKnwBElKYtDOb2MFbhmUigbReQBV0Cg4+qMXSxXSyGUn4UbF8l+7qdSGnTC0XLCmahIgUHLhLOhpVCtw4CzYXvLQWQbJNmxoCsOKAxSgBJno75avolkRw8iIAFcsdc02e9iyCd8tHwmeSSoKTowIgvscSGZUOA7PuCN5b2BX9mQM7S0wYhMNU74zgsPBj3HU7wguAfnxxjFQGBE6pwN+GjME9zHY7zGp8wVxMShYX9NXvEWD3HbwJf4giO4CFIQxXScH1/TM+04kkBiAAAAAElFTkSuQmCC",
    iconSize: [25, 41],
    shadowSize: [41, 41],
    iconAnchor: [12, 41],
    shadowAnchor: [14, 41],
    popupAnchor: [-3, -76]
});
class rw extends qf {
    constructor(e) {
        super(e, v0 + `
` + b0 + `
` + E0)
    }
    initEditMode(e) {
        e.insertAdjacentHTML("beforeend", S0);
        const n = e.querySelector("#shaclMapDialogContainer");
        this.map = Dt.map(n, {
            fullscreenControl: !0,
            editable: !0,
            layers: [Dt.tileLayer(Qh)],
            zoom: 5,
            maxBounds: Kh,
            center: Zh
        }),
        this.map.attributionControl.addAttribution(Xh);
        const r = Dt.Control.extend({
            options: {
                position: "topleft",
                callback: null,
                kind: "",
                html: ""
            },
            onAdd: function(a) {
                let l = Dt.DomUtil.create("div", "leaflet-control leaflet-bar")
                  , u = Dt.DomUtil.create("a", "", l);
                return u.href = "#",
                u.title = "Create a new " + this.options.kind,
                u.innerHTML = this.options.html,
                Dt.DomEvent.on(u, "click", Dt.DomEvent.stop).on(u, "click", ()=>{
                    window.LAYER = this.options.callback.call(a.editTools)
                }
                , this),
                l
            }
        });
        this.map.addControl(new (r.extend({
            options: {
                callback: ()=>{
                    this.displayedShape?.remove(),
                    this.displayedShape = this.map?.editTools.startPolygon()
                }
                ,
                kind: "polygon",
                html: ""
            }
        }))),
        this.map.addControl(new (r.extend({
            options: {
                callback: ()=>{
                    this.displayedShape?.remove(),
                    this.displayedShape = this.map?.editTools.startMarker(void 0, {
                        icon: Jh
                    })
                }
                ,
                kind: "marker",
                html: ""
            }
        }))),
        this.map.on("editable:drawing:end", ()=>{
            this.saveChanges()
        }
        ),
        this.map.on("editable:vertex:dragend", ()=>{
            this.saveChanges()
        }
        );
        const o = e.querySelector("#shaclMapDialog");
        return o.addEventListener("close", ()=>{
            const a = document.body.style.top;
            document.body.style.position = "",
            document.body.style.top = "",
            window.scrollTo(0, parseInt(a || "0") * -1),
            this.currentEditor && this.createdGeometry && (this.currentEditor.value = T0(this.createdGeometry),
            this.currentEditor.dispatchEvent(new Event("change",{
                bubbles: !0
            })))
        }
        ),
        o
    }
    createEditor(e, n) {
        let r = e.config.form.querySelector("#shaclMapDialog");
        r || (r = this.initEditMode(e.config.form));
        const o = e.config.theme.createButton("Open&#160;map...", !1);
        o.style.marginLeft = "5px",
        o.classList.add("open-map-button"),
        o.onclick = ()=>{
            this.currentEditor = a.querySelector(".editor"),
            this.createdGeometry = void 0,
            this.displayedShape?.remove(),
            this.drawAndZoomToGeometry(Yh(this.currentEditor.value || ""), this.map),
            document.body.style.top = `-${window.scrollY}px`,
            document.body.style.position = "fixed",
            r.showModal()
        }
        ;
        const a = $f(e, n || null, !0);
        return a.appendChild(o),
        a
    }
    createViewer(e, n) {
        const r = document.createElement("div")
          , o = Yh(n.value);
        if (o?.coordinates?.length) {
            const a = Dt.map(r, {
                fullscreenControl: !0,
                layers: [Dt.tileLayer(Qh)],
                zoom: 5,
                center: Zh,
                maxBounds: Kh
            });
            a.attributionControl.addAttribution(Xh),
            this.drawAndZoomToGeometry(o, a)
        }
        return r
    }
    drawAndZoomToGeometry(e, n) {
        if (setTimeout(()=>{
            n.invalidateSize()
        }
        ),
        e?.type === "Point") {
            const r = {
                lng: e.coordinates[0],
                lat: e.coordinates[1]
            };
            this.displayedShape = Dt.marker(r, {
                icon: Jh
            }).addTo(n),
            n.setView(r, 15, {
                animate: !1
            })
        } else if (e?.type === "Polygon") {
            const r = e.coordinates[0].map(a=>({
                lng: a[0],
                lat: a[1]
            }))
              , o = Dt.polygon(r).addTo(n);
            this.displayedShape = o,
            n.fitBounds(o.getBounds(), {
                animate: !1
            }),
            setTimeout(()=>{
                n.fitBounds(o.getBounds(), {
                    animate: !1
                }),
                n.setView(o.getCenter(), void 0, {
                    animate: !1
                })
            }
            , 1)
        } else
            n.setZoom(5)
    }
    saveChanges() {
        if (this.displayedShape instanceof Dt.Marker) {
            const e = this.displayedShape.getLatLng();
            this.createdGeometry = {
                type: "Point",
                coordinates: [e.lng, e.lat]
            }
        } else if (this.displayedShape instanceof Dt.Polygon) {
            const e = this.displayedShape.getLatLngs();
            e[0][0].equals(e[0][e[0].length - 1]) || e[0].push(e[0][0]),
            this.createdGeometry = {
                type: "Polygon",
                coordinates: [e[0].map(n=>[n.lng, n.lat])]
            }
        } else
            this.createdGeometry = void 0
    }
}
const Kh = [[-90, -180], [90, 180]];
function Yh(i) {
    const e = i.match(/^POINT\((.*)\)$/);
    if (e?.length == 2) {
        const r = e[1].split(" ");
        if (r.length === 2)
            return {
                type: "Point",
                coordinates: [parseFloat(r[0]), parseFloat(r[1])]
            }
    }
    const n = i.match(/^POLYGON[(]{2}(.*)[)]{2}$/);
    if (n?.length == 2) {
        const r = n[1].split(",");
        if (r.length > 2) {
            const o = []
              , a = [];
            o.push(a);
            for (const l of r) {
                const u = l.split(" ");
                u.length === 2 && a.push([parseFloat(u[0]), parseFloat(u[1])])
            }
            return {
                type: "Polygon",
                coordinates: o
            }
        }
    }
}
function T0(i) {
    return i.type === "Point" ? `POINT(${i.coordinates.join(" ")})` : i.type === "Polygon" ? `POLYGON((${i.coordinates[0].map(e=>e.join(" ")).join(",")}))` : ""
}
export {Hh as Config, ey as DefaultTheme, iw as FileUploadPlugin, rw as LeafletPlugin, qf as Plugin, m0 as ShaclForm, Um as Theme, Wi as findLabel, T0 as geometryToWkt, g0 as initTimeout, jm as loadGraphs, Bi as prefixes, Wm as registerPlugin, Yh as wktToGeometry, Kh as worldBounds};
